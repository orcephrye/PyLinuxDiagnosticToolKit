{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyLinuxDiagnosticToolKit Wiki can be viewed on GitHub Pages. URL: https://orcephrye.github.io/PyLinuxDiagnosticToolKit/ These documentation pages are made by Portray: https://timothycrosley.github.io/portray/ REQUIRES: Python 3.7+, PyMultiTasking, PyCustomParsers, PyCustomCollections and Paramiko # Install requirements (pip should point to a Python 3.7+ environment.) pip install -r requirements.txt # Install the whole package pip install . The Linux Diagnostic Tool Kit: This is a set of Modules (python packages) themed after linux commands or programs, packaged together with some tools to interact with a remote machine. Currently, the only 'connector' is the 'sshConnector' which provides connectivity too Linux machines. The tools, connectors, and modules are tied together by the ToolKitInterface class in the ldtk.py package. The ToolKitInterface class should be the primary class a python script interacts with. It is as simple as importing the package and instantiating an object. from PyLinuxDiagnosticToolKit.ldtk import ToolKitInterface tki = ToolKitInterface () In order to get login information the TKI uses the ArgumentWrapper package. This is a highly customizable NamespaceDict object. If you are not creating a callable script but utilizing this program within an environment like ipython then you will need too pass the ArgumentWrapper manually. from PyLinuxDiagnosticToolKit.libs import ArgumentWrapper args = ArgumentWrapper . arguments () . parse_known_args ()[ 0 ] args . host = '127.0.0.1' ; args . username = 'server' ; args . password = 'abc123' ; args . root = True ; args . rootpwd = 'abc123' tki = ToolKitInterface ( arguments = args ) or args = ArgumentWrapper . parseString ( \"--host 127.0.0.1 --username server --password abc123 -r --rootpwd abc123\" ) tki = ToolKitInterface ( arguments = args ) Note: There is a massive list of possible arguments please review the ArgumentWrapper for all possible options. Also, you do not necessarily need to provide it the exact class with all arguments. Simply any NamespaceDict object will do. For more information on Argument Wrapper please review its readme file: tutorial Execute Commands: From here if a dev wants to run a custom command it is as simple as: results = tki . execute ( \"whoami\" , threading = False ) print ( results ) or cc = tki . execute ( \"whoami\" , threading = True ) # Threading is True by default results = cc . waitForResults () print ( cc . results ) # This demonstrates that the 'CommandContainer' object also stores the results Execute returns a CommandContainer if threading is True. If Threading is false then it returns the output of the command as a string. We will get to how to use CommandContainer later. For a full explanation go to the CommandContainer page. Modules: Currently, there are only 'LinuxModulse' which contain 'CommandModules', 'OtherModules', and 'ProgramModules'. Eventually These will be reorganized once Windows is supported. Command Modules are common Linux specific commands (i.e: cat, ps, etc...) Program Modules are programs that run on the target remote OS. (i.e: MySQL, Oracle, etc...) To get a list of modules use the 'getAvailableModules' method. This returns a list of strings that represent the supported commands. from PyLinuxDiagnosticToolKit.ldtk import ToolKitInterface tki = ToolKitInterface() tki.getAvailableModules() Any command regardless if it is present in the list of supported modules can be executed via the 'execute' method. Modules are a more 'pythonic' or programmatic way of handling shell commands. They also can have special methods specific to the nature of the command they represent. An example of this would be 'ps' command module having a method 'getTopCPU' or the 'll' module which has the method 'fileExist'. Also not all modules directly map too a single command. Some modules use multiple commands together when using a certain methods while others are a collection of commands following a particular theme. An example of this would be the 'touch' modules 'isWritable' method which determines if a filesystem can be written too. It also uses the 'rm' module. While the service module combines the commands service, chkconfig, and systemctl all in one. The CommandModules: These command modules are packages that all inherit from genericCmdModule and they are themed around certain bash commands. For example the psmodule uses the 'ps' command and has custom parsing tools to handle the output. To use a module: ps = tki . getModule ( 'ps' ) print ( ps ()) print ( ps ( rerun = False )) print ( ps ( wait = 10 , rerun = True )) print ( ps ( '-ef' )) print ( type ( ps . ef )) print ( ps . getTopCPU ()) The first command creates an instance of the psmodule and makes it aware of the ToolKitInterface. The second command simply runs the 'ps' with default flags. Review the module itself or if in ipython simply run: 'ps?'. All results of commands are cached. So the 'rerun' parameter is a standard option to tell the method to rerun the command on the remote target even if the object already has results for that command. In the case of the 'ps' command the rerun flag defaults too True. Most command modules the 'rerun' parameter is False. All commands run on a spawned worker thread that represents a Paramiko SSH Channel. The parameter wait is uses to tell the method how long it is acceptable to wait for data back. If the command is not yet finished it doesn't stop running the method simply returns None. If wait is None then the method will return a CommandObject if its running a new command or a cached results. The arguments '-ef' are considered custom flags. The ps module will then bypass normal behavior and simply run 'ps -ef'. This still means the results will be cached and the standard parameters are accepted. The method 'getTopCPU' was added to the psModule to parse the ps data in a common way. There are lots of these 'helper' methods across a lot of the Modules. Note: Threading can be tricky and may cause unexpected behavior. For example if you run 'cat('/etc/hosts')' ten times in a loop it will not spin up 10 cat commands but actually just one. It will run the first command to completion and then the remaining 9 will return the cache result. If you run it with 'wait=None' the cache process is thread safe so the first cat command will return the CommandObject which will be the same CommandObject for the remaining 9 runs. However, if you have that same loop run ten different cat commands (ie: cat /tmp/hosts, cat /etc/resolv.conf, etc...) commands (with wait=None) it will run all 10 in as many threads as is allowed. (default is 8). If you want the same command to run over and over again the flag 'rerun' can be set to True. If 'wait' is set to anything other than None it is considering 'blocking' and will wait until either the command is finished or the wait time is reached. The SCP and SFTP: Getting and using a SFTP connection sftp = tki . getSFTPClient () sftp . put ( '/path/too/file.out' , '/remote/path/too/new/filename' ) Getting and using a SCP connection scp = tki . getSCPClient () scp . put ( '/path/too/file.out' , '/remote/path/too/new/filename' ) SCP and SFTP can use 'with' with tki . getSFTPClient () as sftp : sftp . put ( '/path/too/file.out' , '/remote/path/too/new/filename' ) Both SCP and SFTP can handle IO and file objects from io import StringIO sIO = StringIO ( \"Some file saved in memory as a str\" ) with tki . getSFTPClient () as sftp : sftp . put ( sIO , '/remote/path/too/new/filename' ) The sshConnector: This is more 'under the hood' stuff that is likely not necessary for most automation. The ssh Connector is a wrapper around Paramiko and adds extra functionality to make managing users and extra channels and sftp connections. A few things to note is how to escalate too a specific user, change environment and how to make custom channels and run commands on them. Many methods have an optional parameter 'environment' that allows the programmer to specify a ssh channel to act on. By default environment=None and thus any are done to whatever SSH channel is available. Escalate too root (if the correct information is already passed in via arguments to the script) tki . becomeRoot () tki . becomeRoot ( environment =< sshEnvironment > ) Escalate too root (with custom options, this also works for any other user) tki . becomeUser ( 'root' , 'abc123' , loginCmd = 'sudo' ) tki . becomeUser ( 'root' , 'abc123' , loginCmd = 'sudo' , environment =< ChannelObject > ) Escalate to root before executing a command without dealing with environment directly using the standard root keyword. cc = tki . execute ( 'whoami' , root = True ) NOTE: There is an argument in the ArgumentWrapper '-r' or '--root' the default is False. If passed the script will always automatically attempt to run the 'becomeRoot' method. NOTE: The TKI is aware of sudo's ability to cache creds, and is also aware of sudo requesting different passwords such as 'server'. When uses 'sudo' it uses 'sudo -k'. It also is aware when 'sudo' asks for the password of a different user. It can look at the password for the requested user. It will also attempt to retry using different methods like 'su -' and if that failed then 'sudo su -'. This behavior is controled with the '--rootLoginExplicit' flag. Escalate too a different console, environment param optional tki . consoleEscalation ( 'bash' , '-norc' , name = 'BASH' ) Change an environment variable, environment param optional tki . environmentChange ( \"export=CHEESE='blah'\" , name = 'cheese' ) Creating a custom channel to then mess with. environment = tki . createEnvironment ( label = 'cheese' ) tki . becomeUser ( 'root' , 'abc123' , loginCmd = 'sudo' , environment = environment ) Run a command on your customer channel. tki . execute ( 'whoami' , labelReq = 'cheese' ) Also with a commandModule print ( ps ( rerun = True , wait = 10 , labelReq = 'cheese' )) So why don't we pass the environment directly into execute or simpleExecute? Well this is because you can make multi channels with the same label. Each with an identical environment and then run possibly 100s of commands each one finding a thread/channel pair to execute on. The CommandContainer: This is where a lot of the heaving lifting for command execution happens. These objects are thread safe and customizable. So far we have only shown what it looks like to run a single command. However, TKI can run hundreds of commands all in specific order, all aware of each other, and all customizable in the middle of execution, while also all still being thread safe and simple. List/Tuples are ordered data types and imply a queue and thus commands in a list or tuple run sequentially. Dict/Set are unordered data types and imply a batch and run asynchronously. Examples: An Que of commands that will run one at a time. tki . execute ([ 'whoami' , 'id' , 'w' ]) batch of commands that will run all at once. tki . execute ({ 'whoami' , 'id' , 'w' }) A Que of commands with custom arguments. queCmds = [{ 'command' : 'whoami' , 'commandKey' : 'username' , 'preparser' : _someMethod }, { 'command' : 'id' , 'commandKey' : 'userInfo' , 'preparser' : _someOtherMethod }] tki . execute ( queCmds ) The CommandContainer is explained in more detail in the documentation for it. In most cases you will never need its more advanced features. Threading: The ToolKitInterface and specifically the sshConnector handles threading. This tool uses the 'threading' module within Python. This means it doesn't handle multipleprocess nor does it work with asyncio modules. Threading is acceptable because the CPU bound commands happen on a remote machine. This could technically benefit from asyncio however Paramiko doesn't support async as of writing this. Below are some ways to interact with this threaded environment. Firstly when executing a command with the 'execute' method it will return a CommandContainer from the 'CommandContainers' package. This is a thread safe object that acts like a task or container where the command and its results are stored. You can string multiple commands together and wait on each of them individually or use a method like 'waitForIdle'. Methods that wait on threads will return a None by default implying that the thread is not yet finished. You can change this behavior with parameters. cmd1 = tki . execute ( 'w' ) cmd1 . waitForResults ( wait = 10 ) print ( f \"w output: { cmd1 . results } \" ) or... cmd1 = tki . execute ( 'w' ) cmd2 = tki . execute ( 'ps awux' ) tki . waitForIdle ( timeout = 60 ) print ( f \"W output: { cmd1 . results } \\n ps awux output: { cmd2 . results } \" If you are using command modules the default value for 'wait' in the parameters is 60. This means each command ran will run one at a time finishing or at least waiting for 60 seconds before continuing to the next. 'wait' can be set to False or 0. That way multiple commands from the CommandModules can be ran asynchronously. Setting 'wait' too False will return a CC (CommandContainer) while a 0 will return a None. The CC is created but cached on the module object and can be retrived by running the method again. w , ps = tki . getModules ( 'w' , 'ps' ) cmd1 = w ( '-f' , wait = False ) ps ( wait = None ) tki . waitForIdle ( timeout = 60 ) print ( f \"W output: { cmd1 . results } \\n ps awux output: { ps () } ) By default the max aloud threads, and thus ssh channels for the ThreadingPool to manage is determined by the the 'MaxSessions' variable in the '/etc/ssh/sshd_conf' configuration file on the target machine. This value is retrieved when the sshConnector first connects to a target box. It will default to 8 if it fails to get the value. There is also running Ques and Batches. In this case the returning CommandContainer has a list/set of 'children' which all have there data. A list/tuple of commands is treated as a queue of commands and thus is executed sequentially while a Dictionary/Set of commands is treated as a batch of commands and thus are executed asynchronously. This example takes roughly 15 seconds: results = tki . execute ([ 'sleep(5); echo \"one\"' , sleep ( 5 ); echo \"two\" , sleep ( 5 ); echo \"three\" ]) results . waitForResults ( wait = 60 ) for child in results . children : print ( child . results ) This example takes roughly 5 seconds: results = tki . execute ({ 'sleep(5); echo \"one\"' , sleep ( 5 ); echo \"two\" , sleep ( 5 ); echo \"three\" }) results . waitForResults ( wait = 60 ) for child in results . children : print ( child . results )","title":"Summary"},{"location":"#pylinuxdiagnostictoolkit","text":"Wiki can be viewed on GitHub Pages. URL: https://orcephrye.github.io/PyLinuxDiagnosticToolKit/ These documentation pages are made by Portray: https://timothycrosley.github.io/portray/ REQUIRES: Python 3.7+, PyMultiTasking, PyCustomParsers, PyCustomCollections and Paramiko # Install requirements (pip should point to a Python 3.7+ environment.) pip install -r requirements.txt # Install the whole package pip install . The Linux Diagnostic Tool Kit: This is a set of Modules (python packages) themed after linux commands or programs, packaged together with some tools to interact with a remote machine. Currently, the only 'connector' is the 'sshConnector' which provides connectivity too Linux machines. The tools, connectors, and modules are tied together by the ToolKitInterface class in the ldtk.py package. The ToolKitInterface class should be the primary class a python script interacts with. It is as simple as importing the package and instantiating an object. from PyLinuxDiagnosticToolKit.ldtk import ToolKitInterface tki = ToolKitInterface () In order to get login information the TKI uses the ArgumentWrapper package. This is a highly customizable NamespaceDict object. If you are not creating a callable script but utilizing this program within an environment like ipython then you will need too pass the ArgumentWrapper manually. from PyLinuxDiagnosticToolKit.libs import ArgumentWrapper args = ArgumentWrapper . arguments () . parse_known_args ()[ 0 ] args . host = '127.0.0.1' ; args . username = 'server' ; args . password = 'abc123' ; args . root = True ; args . rootpwd = 'abc123' tki = ToolKitInterface ( arguments = args ) or args = ArgumentWrapper . parseString ( \"--host 127.0.0.1 --username server --password abc123 -r --rootpwd abc123\" ) tki = ToolKitInterface ( arguments = args ) Note: There is a massive list of possible arguments please review the ArgumentWrapper for all possible options. Also, you do not necessarily need to provide it the exact class with all arguments. Simply any NamespaceDict object will do. For more information on Argument Wrapper please review its readme file: tutorial Execute Commands: From here if a dev wants to run a custom command it is as simple as: results = tki . execute ( \"whoami\" , threading = False ) print ( results ) or cc = tki . execute ( \"whoami\" , threading = True ) # Threading is True by default results = cc . waitForResults () print ( cc . results ) # This demonstrates that the 'CommandContainer' object also stores the results Execute returns a CommandContainer if threading is True. If Threading is false then it returns the output of the command as a string. We will get to how to use CommandContainer later. For a full explanation go to the CommandContainer page. Modules: Currently, there are only 'LinuxModulse' which contain 'CommandModules', 'OtherModules', and 'ProgramModules'. Eventually These will be reorganized once Windows is supported. Command Modules are common Linux specific commands (i.e: cat, ps, etc...) Program Modules are programs that run on the target remote OS. (i.e: MySQL, Oracle, etc...) To get a list of modules use the 'getAvailableModules' method. This returns a list of strings that represent the supported commands. from PyLinuxDiagnosticToolKit.ldtk import ToolKitInterface tki = ToolKitInterface() tki.getAvailableModules() Any command regardless if it is present in the list of supported modules can be executed via the 'execute' method. Modules are a more 'pythonic' or programmatic way of handling shell commands. They also can have special methods specific to the nature of the command they represent. An example of this would be 'ps' command module having a method 'getTopCPU' or the 'll' module which has the method 'fileExist'. Also not all modules directly map too a single command. Some modules use multiple commands together when using a certain methods while others are a collection of commands following a particular theme. An example of this would be the 'touch' modules 'isWritable' method which determines if a filesystem can be written too. It also uses the 'rm' module. While the service module combines the commands service, chkconfig, and systemctl all in one. The CommandModules: These command modules are packages that all inherit from genericCmdModule and they are themed around certain bash commands. For example the psmodule uses the 'ps' command and has custom parsing tools to handle the output. To use a module: ps = tki . getModule ( 'ps' ) print ( ps ()) print ( ps ( rerun = False )) print ( ps ( wait = 10 , rerun = True )) print ( ps ( '-ef' )) print ( type ( ps . ef )) print ( ps . getTopCPU ()) The first command creates an instance of the psmodule and makes it aware of the ToolKitInterface. The second command simply runs the 'ps' with default flags. Review the module itself or if in ipython simply run: 'ps?'. All results of commands are cached. So the 'rerun' parameter is a standard option to tell the method to rerun the command on the remote target even if the object already has results for that command. In the case of the 'ps' command the rerun flag defaults too True. Most command modules the 'rerun' parameter is False. All commands run on a spawned worker thread that represents a Paramiko SSH Channel. The parameter wait is uses to tell the method how long it is acceptable to wait for data back. If the command is not yet finished it doesn't stop running the method simply returns None. If wait is None then the method will return a CommandObject if its running a new command or a cached results. The arguments '-ef' are considered custom flags. The ps module will then bypass normal behavior and simply run 'ps -ef'. This still means the results will be cached and the standard parameters are accepted. The method 'getTopCPU' was added to the psModule to parse the ps data in a common way. There are lots of these 'helper' methods across a lot of the Modules. Note: Threading can be tricky and may cause unexpected behavior. For example if you run 'cat('/etc/hosts')' ten times in a loop it will not spin up 10 cat commands but actually just one. It will run the first command to completion and then the remaining 9 will return the cache result. If you run it with 'wait=None' the cache process is thread safe so the first cat command will return the CommandObject which will be the same CommandObject for the remaining 9 runs. However, if you have that same loop run ten different cat commands (ie: cat /tmp/hosts, cat /etc/resolv.conf, etc...) commands (with wait=None) it will run all 10 in as many threads as is allowed. (default is 8). If you want the same command to run over and over again the flag 'rerun' can be set to True. If 'wait' is set to anything other than None it is considering 'blocking' and will wait until either the command is finished or the wait time is reached. The SCP and SFTP: Getting and using a SFTP connection sftp = tki . getSFTPClient () sftp . put ( '/path/too/file.out' , '/remote/path/too/new/filename' ) Getting and using a SCP connection scp = tki . getSCPClient () scp . put ( '/path/too/file.out' , '/remote/path/too/new/filename' ) SCP and SFTP can use 'with' with tki . getSFTPClient () as sftp : sftp . put ( '/path/too/file.out' , '/remote/path/too/new/filename' ) Both SCP and SFTP can handle IO and file objects from io import StringIO sIO = StringIO ( \"Some file saved in memory as a str\" ) with tki . getSFTPClient () as sftp : sftp . put ( sIO , '/remote/path/too/new/filename' ) The sshConnector: This is more 'under the hood' stuff that is likely not necessary for most automation. The ssh Connector is a wrapper around Paramiko and adds extra functionality to make managing users and extra channels and sftp connections. A few things to note is how to escalate too a specific user, change environment and how to make custom channels and run commands on them. Many methods have an optional parameter 'environment' that allows the programmer to specify a ssh channel to act on. By default environment=None and thus any are done to whatever SSH channel is available. Escalate too root (if the correct information is already passed in via arguments to the script) tki . becomeRoot () tki . becomeRoot ( environment =< sshEnvironment > ) Escalate too root (with custom options, this also works for any other user) tki . becomeUser ( 'root' , 'abc123' , loginCmd = 'sudo' ) tki . becomeUser ( 'root' , 'abc123' , loginCmd = 'sudo' , environment =< ChannelObject > ) Escalate to root before executing a command without dealing with environment directly using the standard root keyword. cc = tki . execute ( 'whoami' , root = True ) NOTE: There is an argument in the ArgumentWrapper '-r' or '--root' the default is False. If passed the script will always automatically attempt to run the 'becomeRoot' method. NOTE: The TKI is aware of sudo's ability to cache creds, and is also aware of sudo requesting different passwords such as 'server'. When uses 'sudo' it uses 'sudo -k'. It also is aware when 'sudo' asks for the password of a different user. It can look at the password for the requested user. It will also attempt to retry using different methods like 'su -' and if that failed then 'sudo su -'. This behavior is controled with the '--rootLoginExplicit' flag. Escalate too a different console, environment param optional tki . consoleEscalation ( 'bash' , '-norc' , name = 'BASH' ) Change an environment variable, environment param optional tki . environmentChange ( \"export=CHEESE='blah'\" , name = 'cheese' ) Creating a custom channel to then mess with. environment = tki . createEnvironment ( label = 'cheese' ) tki . becomeUser ( 'root' , 'abc123' , loginCmd = 'sudo' , environment = environment ) Run a command on your customer channel. tki . execute ( 'whoami' , labelReq = 'cheese' ) Also with a commandModule print ( ps ( rerun = True , wait = 10 , labelReq = 'cheese' )) So why don't we pass the environment directly into execute or simpleExecute? Well this is because you can make multi channels with the same label. Each with an identical environment and then run possibly 100s of commands each one finding a thread/channel pair to execute on. The CommandContainer: This is where a lot of the heaving lifting for command execution happens. These objects are thread safe and customizable. So far we have only shown what it looks like to run a single command. However, TKI can run hundreds of commands all in specific order, all aware of each other, and all customizable in the middle of execution, while also all still being thread safe and simple. List/Tuples are ordered data types and imply a queue and thus commands in a list or tuple run sequentially. Dict/Set are unordered data types and imply a batch and run asynchronously. Examples: An Que of commands that will run one at a time. tki . execute ([ 'whoami' , 'id' , 'w' ]) batch of commands that will run all at once. tki . execute ({ 'whoami' , 'id' , 'w' }) A Que of commands with custom arguments. queCmds = [{ 'command' : 'whoami' , 'commandKey' : 'username' , 'preparser' : _someMethod }, { 'command' : 'id' , 'commandKey' : 'userInfo' , 'preparser' : _someOtherMethod }] tki . execute ( queCmds ) The CommandContainer is explained in more detail in the documentation for it. In most cases you will never need its more advanced features. Threading: The ToolKitInterface and specifically the sshConnector handles threading. This tool uses the 'threading' module within Python. This means it doesn't handle multipleprocess nor does it work with asyncio modules. Threading is acceptable because the CPU bound commands happen on a remote machine. This could technically benefit from asyncio however Paramiko doesn't support async as of writing this. Below are some ways to interact with this threaded environment. Firstly when executing a command with the 'execute' method it will return a CommandContainer from the 'CommandContainers' package. This is a thread safe object that acts like a task or container where the command and its results are stored. You can string multiple commands together and wait on each of them individually or use a method like 'waitForIdle'. Methods that wait on threads will return a None by default implying that the thread is not yet finished. You can change this behavior with parameters. cmd1 = tki . execute ( 'w' ) cmd1 . waitForResults ( wait = 10 ) print ( f \"w output: { cmd1 . results } \" ) or... cmd1 = tki . execute ( 'w' ) cmd2 = tki . execute ( 'ps awux' ) tki . waitForIdle ( timeout = 60 ) print ( f \"W output: { cmd1 . results } \\n ps awux output: { cmd2 . results } \" If you are using command modules the default value for 'wait' in the parameters is 60. This means each command ran will run one at a time finishing or at least waiting for 60 seconds before continuing to the next. 'wait' can be set to False or 0. That way multiple commands from the CommandModules can be ran asynchronously. Setting 'wait' too False will return a CC (CommandContainer) while a 0 will return a None. The CC is created but cached on the module object and can be retrived by running the method again. w , ps = tki . getModules ( 'w' , 'ps' ) cmd1 = w ( '-f' , wait = False ) ps ( wait = None ) tki . waitForIdle ( timeout = 60 ) print ( f \"W output: { cmd1 . results } \\n ps awux output: { ps () } ) By default the max aloud threads, and thus ssh channels for the ThreadingPool to manage is determined by the the 'MaxSessions' variable in the '/etc/ssh/sshd_conf' configuration file on the target machine. This value is retrieved when the sshConnector first connects to a target box. It will default to 8 if it fails to get the value. There is also running Ques and Batches. In this case the returning CommandContainer has a list/set of 'children' which all have there data. A list/tuple of commands is treated as a queue of commands and thus is executed sequentially while a Dictionary/Set of commands is treated as a batch of commands and thus are executed asynchronously. This example takes roughly 15 seconds: results = tki . execute ([ 'sleep(5); echo \"one\"' , sleep ( 5 ); echo \"two\" , sleep ( 5 ); echo \"three\" ]) results . waitForResults ( wait = 60 ) for child in results . children : print ( child . results ) This example takes roughly 5 seconds: results = tki . execute ({ 'sleep(5); echo \"one\"' , sleep ( 5 ); echo \"two\" , sleep ( 5 ); echo \"three\" }) results . waitForResults ( wait = 60 ) for child in results . children : print ( child . results )","title":"PyLinuxDiagnosticToolKit"},{"location":"TUTORIAL/","text":"A short introduction. This tutorial is meant to run in ipython in a directory that has both the PyLinuxDiagnosticToolkit (probably development branch) and other Py* packages from my repo. This goes over some useful abilities of the LDTK and how to use them. Step 1) Imports (Inside of IPython): import PyMultiTasking ; import PyCustomCollections ; import PyLinuxDiagnosticToolKit ; import PyLinuxDiagnosticToolkit ; from ldtk import ToolKitInterface % pycat PyLinuxDiagnosticToolkit / __init__ . py Notes: Explain that when you import a package from any Py* package and PyLinuxDiagnosticToolkit the init file imports all other directories into the namespace. Step 2) ArgumentWrapper: import ArgumentWrapper ; args = ArgumentWrapper . arguments () . parse_args (); args . host = \"127.0.0.1\" ; args . password = \"\" ; args . username = \"rye\" ; args . rootpwd = \"\" args tki = ToolKitInterface ( arguments = args ) Notes: ToolKitInterface uses argparse or rather our own version of it. Normally scripts are executed with arguments just like any other shell command. However, when using ipython to test code you will have to set the flags manually as demonstrated above. Step 3) Load modules: cat = tki . getModules ( 'cat' ) id ( cat ) cat , ps , kill = tki . getModules ( 'cat' , 'ps' , 'kill' ) id ( cat ) id ( tki . modules . cat ) Notes: Show off how to pull in different modules. Show off how the tki knows what modules are loaded and not so that it will not reload modules. There is only one of each module. Step 4) Use Modules: filename = '/Path/too/a/simple/file.txt' cat = tki . modules . cat cat ? % time cat ( filename ) % time cat ( filename ) % time cat ( filename , rerun = True ) type ( cat . catPathtooasimplefiletxt ) print ( cat . catPathtooasimplefiletxt . results ) Notes: Show that the first command you run requires logging into a shell first. Shows how a module saves the output of commands and how to rerun commands. Also show how it saves output by binding it to the module. Step 5) More using modules: (You will need to replace 'rye' with a user on the machine you are SSH'ed into) (You may need to replace 'firefox' with 'chrome' or the name of some other programming running on the machine ou are SSH'ed into) ps = tki . modules . ps ps ? % pycat PyLinuxDiagnosticToolkit / LinuxModules / CommandModules / processModules / psmodule . py % time output = ps () ps [ 0 ] ps [ 'PID' ] ps [( 'USER' , 'rye' )] print ( ps . formatLines ( ps [( 'USER' , 'rye' )])) ps . findProcess ( 'firefox' ) ps . findProcess ( 'firefox' )[ 'PID' ] print ( ps . formatLines ( ps . findProcess ( 'firefox' ))) print ( ps . getRunQue ()) print ( ps ( '-ef' )) Notes: Shows how a module can be a callable object that also can have methods that act upon the data from the default command. Also how that data is stored in a database like object that also is printable. This also shows how this may work with other modules. Step 6) SFTP file upload: (NOTE: You will need to make a simple text BASH script ie: echo -e '#!/bin/bash\\necho \"cheese\"' >> testScript.sh and then you will need too make a tar ball with it via: tar czvf testScript.tar.gz testScript.tar.gz ) tki . putSFTP ? tki . putSFTP ( '~/testScript.tar.gz' , '/tmp/testScript.tar.gz' ) tar = tki . getModules ( 'tar' ) tar ( 'xvfz /tmp/testScript.tar.gz -C /tmp/' ) print ( tki . execute ( 'bash /tmp/testScript.sh' ) . waitForResults ( wait = 10 )) Notes: This is pretty simple. It is an example of how to use the tki to upload a tar ball and then remotely unzip it and execute the bash script on the remote machine. Step 7) Running commands without modules and special flags: cmdObj = tki . execute ( 'w' ) print ( cmdObj . waitForResults ( wait = 10 )) print ( tki . execute ( 'touch /etc/os-release' ) . waitForResults ( wait = 60 )) def testRequirement ( * args , ** kwargs ): cmdObj = tki . execute ( 'which touch' ) cmdObj . waitForResults ( wait = 60 ) print ( f \"Is touch command installed?: { cmdObj . results } \" ) if '/touch' in cmdObj . results : return cmdObj . results raise Exception ( 'could not find touch cmd!' ) print ( tki . execute ( 'touch /etc/os-release' , requirements = { 'testReq' : testRequirement }) . waitForResults ( wait = 60 )) def testPreparser ( * args , ** kwargs ): this = kwargs . get ( \"this\" ) print ( f \"The kwarg this type is: { type ( this ) } \" ) if not this . requirementResults : return False print ( f \"The results of the requirements are: { this . requirementResults } \" ) this . command %= str ( this . requirementResults . get ( 'testReq' , '' )) return True print ( tki . execute ( ' %s /etc/os-release' , requirements = { 'testReq' : testRequirement }, preparser = testPreparser ) . waitForResults ( wait = 60 )) print ( tki . execute ( ' %s /etc/os-release; echo $?' , requirements = { 'testReq' : testRequirement }, preparser = testPreparser ) . waitForResults ( wait = 60 )) def testPostpaser ( results , * args , ** kwargs ): if '0' == results : return True return False print ( tki . execute ( ' %s /etc/os-release; echo $?' , requirements = { 'testReq' : testRequirement }, preparser = testPreparser , postparser = testPostpaser ) . waitForResults ( wait = 60 )) tki . getHistory () Notes: Explain requirements, preparses, postpares. There is also onFailure and completiontask. All of these are functions or methods that can run as part of a command. These functions can do things like stop the command from running if some requirement isn't met or even change the type of command based on additional data gained at the time of execution. Step 8) Controlling order of Execution: (This assumes you have the functions 'testRequirement', 'testPreparser', 'testPostpaser' from step 7.) cmdObj1 = tki . execute ( 'sleep 10; echo \"One\"' ); cmdObj2 = tki . execute ( 'sleep 10; echo \"Two\"' ); cmdObj3 = tki . execute ( 'sleep 10; echo \"Three\"' ) tki . waitForIdle ( timeout = 30 ) print ( cmdObj1 . results ) tki . waitForIdle ? queOfCmds = [ 'sleep 2; echo \"One\"' , 'sleep 2; echo \"Two\"' , 'sleep 2; echo \"Three\"' ] batchOfCmds = { 'sleep 2; echo \"One\"' , 'sleep 2; echo \"Two\"' , 'sleep 2; echo \"Three\"' } % time cmdObjQue = tki . execute ( queOfCmds ); print ( cmdObjQue . waitForResults ( wait = 30 )) % time cmdObjBatch = tki . execute ( batchOfCmds ); print ( cmdObjBatch . waitForResults ( wait = 30 )) for child in cmdObjQue . children : print ( child . results ) for child in cmdObjBatch . children : print ( child . results ) jsonStyleCommands = { 'que1' : ( 'sleep 2; echo \"One\"' , 'sleep 2; echo \"Two\"' , 'sleep 2; echo \"Three\"' ), 'que2' : ( 'id' , 'who' , 'last' ), 'que3' : ( 'df' , 'du /tmp' , 'cat /etc/os-release' )} import json print ( json . dumps ( jsonStyleCommands , indent = 4 , sort_keys = True )) % time jsonStyleCmdObj = tki . execute ( jsonStyleCommands ); print ( jsonStyleCmdObj . waitForResults ( wait = 30 )) jsonStyleCmdObj . results . keys () for key , item in jsonStyleCmdObj . results [ 'que2' ] . items (): print ( f \"Command: { key } \" ) print ( f \"Output: { item } \" ) from PyCustomCollections.PyCustomCollections.CustomDataStructures import FrozenDict jsonStyleCommands2 = {( 'id' , 'who' ),( 'df' , 'cat /etc/os-release' ), FrozenDict ({ 'sleep1' : 'sleep 2; echo \"One\"' , 'sleep2' : 'sleep 2; echo \"Two\"' , 'sleep3' : 'sleep 2; echo \"Three\"' }), FrozenDict ({ 'command' : ' %s /etc/os-release; echo $?' , 'commandKey' : 'touchCmd' , 'requirements' : FrozenDict ({ 'testReq' : testRequirement }), 'preparser' : testPreparser , 'postparser' : testPostpaser })} % time jsonStyleCmdObj2 = tki . execute ( jsonStyleCommands2 ); print ( jsonStyleCmdObj2 . waitForResults ( wait = 30 )) jsonStyleCmdObj2 . results [ 'touchCmd' ] Notes: You can run group of commands in any order. The rule of thumb is if the data type is ordered (list, tuple, OrderedDict) then it runs like a Queue executing each Command one at a time. If the datatype is unordered (Dictionary, Set) then it runs as a Batch. You can create data structure that are similar in nature to Json that will run lots of commands in any order specified. There is a FrozenDict type from CustomDataStructures in the PyCustomCollections package that allows for a static hashable Dictionary. This is useful if you want to also inject requirements,pre/post parsers and other kwargs into a specific command.","title":"Tutorial"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/","text":"CommandContainer Summary: The CC is designed to make running commands within a threaded environment easier by wrapping the command and any other functions the programmer wishes to run before/after the command has been executed into a thread safe container. The container also can handle multiple commands and execute them in order or in parallel. In most cases a CommandContainer or 'CC' for short is just given a string for the 'command' parameter with the command too execute. To run multiple commands the 'command' parameter is either a List/Tuple or Set/Dict. A list or tuple tells the CC that the commands provided are meant to be executed in order. While a Set/Dict tells the CC that the commands are meant to be executed as a 'batch' or in parallel. In order to run other methods before and/or after the command executed the CC has additional kwarg parameters. The most common is the preparser and postpaser. These should be either a callable object like a reference to a method/function or a partial object from 'functools'. They can also be a list of callable objects if multiple methods need to run. As the name suggests the preparser runs before the command is executed and the postparser runs afterward. The preparser gets passed the 'this' keyword argument which is a reference to the CC object itself. While the postparser and all other methods that run after command execution get both the 'result' keyword and 'this'. If a CC is given one of these keyword arguments it will attempt to run this function when appropriate. Other functions are requirements, onComplete, onFail. The order of execution is: requirements, preparsers, execute command, postparsers, then either onComplete or onFail. onFail may run at any point of failure. The point of this is too allow these methods to run along with the thread that is handling the command in a safe way that allows the developer to simply wait on the CC for the finial results. It can also be used to create some rather complex execution paths that can be reduced down to just simple YAML/Json. In depth review Definitions: wait : The length of time to wait for a command container to complete. timeout : Same as wait except that an exception will be raised if exceeded. delay : The length of time between each action in a collection (delay between each retry) Structure There are 5 main classes that make up a CommandObject. The classes are divided based on purpose: Data , Parsers , Requirements , Setup , Logic Each of these inherits the one before it in the following order: CommandData , CommandParsers , CommandRequirements , CommandSetup , CommandContainer CommandData: As its name implies it has all the data things. It contains basic data and attribute modifiers for use under the hood. CommandParsers: This parses and houses the command and commandKey for the CommandObject. This is another class that operates under the hood when the CommandObject is created. CommandRequirements: This auxiliary workhorse handles parsing and running of command requirements using threading. Parsing occurs during instantiation and running of requirements happens near the start of main execution. CommandSetup: This handles the custom methods and sets them on the CommandObject during instantiation. This also handles the most basic checks to ensure the acceptable state of the CommandObject before main execution. Execution of the preparser(s) also happens here. This class is a little odd since the checks run before requirements and the preparser runs immediately afterward. CommandObject: The workhorse that runs the execution portions of CommandRequirements and CommandSetup as well all commands. This contains most of the logic that manipulates data and calls custom parsing. Execution of Commands A single Command A single command is simple enough: The CommandData gets the command through the positional argument(s) 'command' and/or 'commandKey'. These are wrapped into properties and are parsed by the private methods _parseCommand and _parseCommandInput. The commandKey (the second positional argument) is designed to be a way to identify the CommandObject. If the CommandContainer is not provided with a commandKey it attempts to derive it from the command itself. NOTE : The 'command' positional argument can be many different data types, and this is what determines behavior. If it's a string then it assumes it's a command to run. If it's a single length item (len(item) == 1) then it pulls that item, assuming it's a command to run. An example of this would be a list with a single item, or a dict, or whatever data type with just one entry. Other data types will be explained later. CommandData sets up other variables. CommandRequirements parses the requirements and prepares them for execution. CommandSetup configures any custom methods on the CommandObject. Now the CommandObject is finished and it is ready for execution. Executing a CommandObject requires adding it to the sshThreader. Eventually it will be pulled by a Thread and passed to the _exeThread method within sshThreader. The _exeThread function's job is to safely call the CO's method 'executor' and pass it all the finial parameters necessary for the CO to run correctly. The 'executor' method first runs the setup method from CommandSetup to finish CO configuration using the parameters passed to it by _exeThread. Then it checks for requirements to run before the command, kicks off a thread for each, and waits for completion. After requirements the CommandObject runs preparser(s) to perform the final command preconfiguration. It then sends the command to a threaded channel or the main thread for execution. Once execution completes, it kicks off the default parser and any customer parsers. Lastly it runs the completion task(s). Once the thread is done, the 'with' statement inside the '_exeThread' exits the CommandObject, and finalizes the completion of the CommandObject. 1) CommandObject (CO) is created with the command(s) and other options. 2) A 'with' is used on the CO in a thread. 3) _exeThread() calls executor() and passes final setup parameters. 4) executor() checks to make sure the CO is ready for execution. 5) executor() completes the setup of the CO. 6) The setup routine check to ensure the CommandObject can be run. 7) Requirements are run if applicable. 8) The preparsers are run if applicable. 9) executor() passes the command string to be executed based on parameters provided at CO's creation. 10) Postparsers are run if applicable. 11) The completion task is run if applicable. 11) In the event of a failure setFailure() is kicked off, otherwise executor() completes finally. 12) _exeThread() now exists the 'with' statement on the CO back in step 2. 13) Exiting the with statement completes the process. Multi Commands Ok, so this is where data types get really tricky. Depending on the data type and how it is formatted will determine if the CommandObject kicks off children, and also in what order those children are run. Any data type that is ordered implies that the commands within that data type run in that order sequentially, for example, list, tuple, or OrderedDict. Any data type that is unordered implies that the commands within that data type run in parallel in whatever order the threads happen to execute them; examples are set, dict. You can compound commands within this data structure. Basically, you can layer this to your hearts content. All the commands are linked to each other through their parents. Parents keep track of their children so that children can become aware of each other and their state, including whether they have finished executing or not and what their results are. This allows you to piercingly control the order of operations of commands, and gives you the ability to execute commands in queues, ensuring that each finish before the other, while at the same time asynchronously other commands are executing and acting on each other. Now, if you want to pass custom arguments instead of just the 'command' argument, that is where dicts come in. Dicts can be passed in as kwargs, and any item in a list or set can be a dict. If it is, the CommandObject will create a new CommandObject by simply saying CommandObject( item). This allows you to create extremely controlled AND customized executions of commands. A helpful hint: In the repo 'PyCustomCollections' there is a Python Package called 'CustomDataStructures' that contains a class called 'FrozenDict'. This is an immutable hashable dictionary, meaning that you can use it within a set. This can be helpful if you have a set of 10 commands, but you only want to customize 1 or 2 of them. Normally you would have to make the set a dictionary of dictionaries, but with a FrozenDict, you can just change the necessary items in the set. There is a lot more going on, but that is the basics. The CommandObject/CommandContainer can be as simple as passing 'whoami', or as complicated as passing 150 commands that all need to run in a specific order and relay data to each other. Most of the time you will not to need directly touch the CO. You will use the 'execute' or 'simpleExecute' functions. The 'execute' method is located within the 'ldtk.py', and 'simpleExecute' within the 'genericCmdModule.py'. Bread and butter routines used exclusively by the executor method * NOTE on setLastResults: This is the facilitator method and tracks stuff when it gets data. Tracks the overall timeout for the CommandObject and raises an exception when exceeded Tracks and sets lastResults for both parents and children recursively Checks for failures and stopOnFailure and calls the setFailure method Returns False when a failure is detected and True otherwise NOTE on finalizeExecution: This runs tasks after execution and finalizes the results for the CommandObject. Tracks failures and when to stop with stopOnFailure Fully executes postparsers and the completion task Control Methods Control methods (passed through kwargs and must accept args and kwargs): preparser: A function or list of functions to preparse the command before running it. Passed the command object as this=self so has access to and can manipulate all elements of the object. Does not need to return anything and results will not be checked. Changes to the command object must be done directly on the object passed to it (this). Failure is recognized by: raising or returning an exception Failure will stop the process before requirements are run. requirements: A dictionary of functions that are required to run and succeed before any commands or children. The values can also be an indexed iterable (list, tuple) of length 2 with: The first value as the function to be run as the requirement. [3] The second value will be the condition used to check the results for success or failure. [4] This can be any value checked == results or a function that must raise or return an exception. Anything other than an exception raised or returned from the function will be considered a success. Run threaded and passed wait, timeoutExceptions, outputChecker, and kwargs. Failure is recognized by: checking results for an instance of Exception checking results == failure condition (defaults to None [1] for timeout) checking result of failureCondition(results) for an instance of Exception raising or returning an exception Failure condition can be set and defaults to None [1] , or an exception can be raised or returned. Failure will stop the process before any commands are run. postparser: Can be a function or list of postparser functions that decide if the command(s) succeeded. Results of this/these function(s) replace the command(s) results. Passed the command or children results, the command object as this=self, and kwargs. Failure is recognized by: raising or returning an exception Failure does not stop the process. completiontask: A function to be run after all other tasks before exiting the command object. Passed command results, command object as this=self, kwargs, so can modify the object if needed. Can be skipped if stopOnComplete is set and a failure has been recognized. Failure is recognized by: raising or returning an exception Results of this task do not directly affect the overall results. onFail: A custom function to define the behavior and results of the command object if a failure is recognized. Passed the command results, the command object as this=self, and kwargs. Results of this function replace the results of the command object. Failure is recognized by: raising or returning an exception Control flags: noParsing: Do not create the command tags for output and do not parse the results as a string. This will still attempt to remove the command tags in case they are present. stopOnFailure: Causes ordered commands to stop execution if a member of the queue fails, halting further execution. Also allows exceptions to be returned from batch execution if a command fails. timeoutExceptions [2] : Causes exceptions to be returned instead of None in the event that a piece of the process times out. Normally a result of None is the only indicator that a command or function has not completed. requirementsCondition: This can be set to any value or function and will be used to verify if the requirements succeeded. This is a global condition for all requirements and is only used if provided. Specific conditions for individual requirements [3] will override this. This is used in the same way as the failure conditions for individual requirements [4] . [1] The default exists to track timeouts. [2] Existence of this is questionable and may be removed at some point. [2] Update the timeouts/waits/delays and so on.","title":"CommandContainer"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#commandcontainer","text":"","title":"CommandContainer"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#summary","text":"The CC is designed to make running commands within a threaded environment easier by wrapping the command and any other functions the programmer wishes to run before/after the command has been executed into a thread safe container. The container also can handle multiple commands and execute them in order or in parallel. In most cases a CommandContainer or 'CC' for short is just given a string for the 'command' parameter with the command too execute. To run multiple commands the 'command' parameter is either a List/Tuple or Set/Dict. A list or tuple tells the CC that the commands provided are meant to be executed in order. While a Set/Dict tells the CC that the commands are meant to be executed as a 'batch' or in parallel. In order to run other methods before and/or after the command executed the CC has additional kwarg parameters. The most common is the preparser and postpaser. These should be either a callable object like a reference to a method/function or a partial object from 'functools'. They can also be a list of callable objects if multiple methods need to run. As the name suggests the preparser runs before the command is executed and the postparser runs afterward. The preparser gets passed the 'this' keyword argument which is a reference to the CC object itself. While the postparser and all other methods that run after command execution get both the 'result' keyword and 'this'. If a CC is given one of these keyword arguments it will attempt to run this function when appropriate. Other functions are requirements, onComplete, onFail. The order of execution is: requirements, preparsers, execute command, postparsers, then either onComplete or onFail. onFail may run at any point of failure. The point of this is too allow these methods to run along with the thread that is handling the command in a safe way that allows the developer to simply wait on the CC for the finial results. It can also be used to create some rather complex execution paths that can be reduced down to just simple YAML/Json.","title":"Summary:"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#in-depth-review","text":"","title":"In depth review"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#definitions","text":"wait : The length of time to wait for a command container to complete. timeout : Same as wait except that an exception will be raised if exceeded. delay : The length of time between each action in a collection (delay between each retry)","title":"Definitions:"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#structure","text":"There are 5 main classes that make up a CommandObject. The classes are divided based on purpose: Data , Parsers , Requirements , Setup , Logic Each of these inherits the one before it in the following order: CommandData , CommandParsers , CommandRequirements , CommandSetup , CommandContainer CommandData: As its name implies it has all the data things. It contains basic data and attribute modifiers for use under the hood. CommandParsers: This parses and houses the command and commandKey for the CommandObject. This is another class that operates under the hood when the CommandObject is created. CommandRequirements: This auxiliary workhorse handles parsing and running of command requirements using threading. Parsing occurs during instantiation and running of requirements happens near the start of main execution. CommandSetup: This handles the custom methods and sets them on the CommandObject during instantiation. This also handles the most basic checks to ensure the acceptable state of the CommandObject before main execution. Execution of the preparser(s) also happens here. This class is a little odd since the checks run before requirements and the preparser runs immediately afterward. CommandObject: The workhorse that runs the execution portions of CommandRequirements and CommandSetup as well all commands. This contains most of the logic that manipulates data and calls custom parsing.","title":"Structure"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#execution-of-commands","text":"","title":"Execution of Commands"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#a-single-command","text":"A single command is simple enough: The CommandData gets the command through the positional argument(s) 'command' and/or 'commandKey'. These are wrapped into properties and are parsed by the private methods _parseCommand and _parseCommandInput. The commandKey (the second positional argument) is designed to be a way to identify the CommandObject. If the CommandContainer is not provided with a commandKey it attempts to derive it from the command itself. NOTE : The 'command' positional argument can be many different data types, and this is what determines behavior. If it's a string then it assumes it's a command to run. If it's a single length item (len(item) == 1) then it pulls that item, assuming it's a command to run. An example of this would be a list with a single item, or a dict, or whatever data type with just one entry. Other data types will be explained later. CommandData sets up other variables. CommandRequirements parses the requirements and prepares them for execution. CommandSetup configures any custom methods on the CommandObject. Now the CommandObject is finished and it is ready for execution. Executing a CommandObject requires adding it to the sshThreader. Eventually it will be pulled by a Thread and passed to the _exeThread method within sshThreader. The _exeThread function's job is to safely call the CO's method 'executor' and pass it all the finial parameters necessary for the CO to run correctly. The 'executor' method first runs the setup method from CommandSetup to finish CO configuration using the parameters passed to it by _exeThread. Then it checks for requirements to run before the command, kicks off a thread for each, and waits for completion. After requirements the CommandObject runs preparser(s) to perform the final command preconfiguration. It then sends the command to a threaded channel or the main thread for execution. Once execution completes, it kicks off the default parser and any customer parsers. Lastly it runs the completion task(s). Once the thread is done, the 'with' statement inside the '_exeThread' exits the CommandObject, and finalizes the completion of the CommandObject. 1) CommandObject (CO) is created with the command(s) and other options. 2) A 'with' is used on the CO in a thread. 3) _exeThread() calls executor() and passes final setup parameters. 4) executor() checks to make sure the CO is ready for execution. 5) executor() completes the setup of the CO. 6) The setup routine check to ensure the CommandObject can be run. 7) Requirements are run if applicable. 8) The preparsers are run if applicable. 9) executor() passes the command string to be executed based on parameters provided at CO's creation. 10) Postparsers are run if applicable. 11) The completion task is run if applicable. 11) In the event of a failure setFailure() is kicked off, otherwise executor() completes finally. 12) _exeThread() now exists the 'with' statement on the CO back in step 2. 13) Exiting the with statement completes the process.","title":"A single Command"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#multi-commands","text":"Ok, so this is where data types get really tricky. Depending on the data type and how it is formatted will determine if the CommandObject kicks off children, and also in what order those children are run. Any data type that is ordered implies that the commands within that data type run in that order sequentially, for example, list, tuple, or OrderedDict. Any data type that is unordered implies that the commands within that data type run in parallel in whatever order the threads happen to execute them; examples are set, dict. You can compound commands within this data structure. Basically, you can layer this to your hearts content. All the commands are linked to each other through their parents. Parents keep track of their children so that children can become aware of each other and their state, including whether they have finished executing or not and what their results are. This allows you to piercingly control the order of operations of commands, and gives you the ability to execute commands in queues, ensuring that each finish before the other, while at the same time asynchronously other commands are executing and acting on each other. Now, if you want to pass custom arguments instead of just the 'command' argument, that is where dicts come in. Dicts can be passed in as kwargs, and any item in a list or set can be a dict. If it is, the CommandObject will create a new CommandObject by simply saying CommandObject( item). This allows you to create extremely controlled AND customized executions of commands. A helpful hint: In the repo 'PyCustomCollections' there is a Python Package called 'CustomDataStructures' that contains a class called 'FrozenDict'. This is an immutable hashable dictionary, meaning that you can use it within a set. This can be helpful if you have a set of 10 commands, but you only want to customize 1 or 2 of them. Normally you would have to make the set a dictionary of dictionaries, but with a FrozenDict, you can just change the necessary items in the set. There is a lot more going on, but that is the basics. The CommandObject/CommandContainer can be as simple as passing 'whoami', or as complicated as passing 150 commands that all need to run in a specific order and relay data to each other. Most of the time you will not to need directly touch the CO. You will use the 'execute' or 'simpleExecute' functions. The 'execute' method is located within the 'ldtk.py', and 'simpleExecute' within the 'genericCmdModule.py'. Bread and butter routines used exclusively by the executor method * NOTE on setLastResults: This is the facilitator method and tracks stuff when it gets data. Tracks the overall timeout for the CommandObject and raises an exception when exceeded Tracks and sets lastResults for both parents and children recursively Checks for failures and stopOnFailure and calls the setFailure method Returns False when a failure is detected and True otherwise NOTE on finalizeExecution: This runs tasks after execution and finalizes the results for the CommandObject. Tracks failures and when to stop with stopOnFailure Fully executes postparsers and the completion task","title":"Multi Commands"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#control-methods","text":"Control methods (passed through kwargs and must accept args and kwargs): preparser: A function or list of functions to preparse the command before running it. Passed the command object as this=self so has access to and can manipulate all elements of the object. Does not need to return anything and results will not be checked. Changes to the command object must be done directly on the object passed to it (this). Failure is recognized by: raising or returning an exception Failure will stop the process before requirements are run. requirements: A dictionary of functions that are required to run and succeed before any commands or children. The values can also be an indexed iterable (list, tuple) of length 2 with: The first value as the function to be run as the requirement. [3] The second value will be the condition used to check the results for success or failure. [4] This can be any value checked == results or a function that must raise or return an exception. Anything other than an exception raised or returned from the function will be considered a success. Run threaded and passed wait, timeoutExceptions, outputChecker, and kwargs. Failure is recognized by: checking results for an instance of Exception checking results == failure condition (defaults to None [1] for timeout) checking result of failureCondition(results) for an instance of Exception raising or returning an exception Failure condition can be set and defaults to None [1] , or an exception can be raised or returned. Failure will stop the process before any commands are run. postparser: Can be a function or list of postparser functions that decide if the command(s) succeeded. Results of this/these function(s) replace the command(s) results. Passed the command or children results, the command object as this=self, and kwargs. Failure is recognized by: raising or returning an exception Failure does not stop the process. completiontask: A function to be run after all other tasks before exiting the command object. Passed command results, command object as this=self, kwargs, so can modify the object if needed. Can be skipped if stopOnComplete is set and a failure has been recognized. Failure is recognized by: raising or returning an exception Results of this task do not directly affect the overall results. onFail: A custom function to define the behavior and results of the command object if a failure is recognized. Passed the command results, the command object as this=self, and kwargs. Results of this function replace the results of the command object. Failure is recognized by: raising or returning an exception","title":"Control Methods"},{"location":"PyLinuxDiagnosticToolKit/LinuxModules/#control-flags","text":"noParsing: Do not create the command tags for output and do not parse the results as a string. This will still attempt to remove the command tags in case they are present. stopOnFailure: Causes ordered commands to stop execution if a member of the queue fails, halting further execution. Also allows exceptions to be returned from batch execution if a command fails. timeoutExceptions [2] : Causes exceptions to be returned instead of None in the event that a piece of the process times out. Normally a result of None is the only indicator that a command or function has not completed. requirementsCondition: This can be set to any value or function and will be used to verify if the requirements succeeded. This is a global condition for all requirements and is only used if provided. Specific conditions for individual requirements [3] will override this. This is used in the same way as the failure conditions for individual requirements [4] . [1] The default exists to track timeouts. [2] Existence of this is questionable and may be removed at some point. [2] Update the timeouts/waits/delays and so on.","title":"Control flags:"},{"location":"PyLinuxDiagnosticToolKit/sshConnector/","text":"SSH Connector This is a 'Connector' for the OS Diagnostic Tool Kit or OSDTK . (Currently called Linux Diagnostic Tool Kit/LDTK). As the name suggest, this connector uses the SSH protocol to connect to its target. It uses the Python library Paramiko. This adds support for threading, supports the CommandContainer object which is used by the OSDTK to handle executing commands and helps manage the environment on the remote target. IE: console variables, prompt, user permissions, etc... The SSH Connector uses inheritance to break up the code into logical packages. Here is the list of classes in order from top child class to the first parent. 1) sshThreader This is the top level class and as the name implies it handles threading. 2) sshEnvironmentManager The next class has the logic for handling the multiple TTYs/Paramiko Channels. Each channel has its own environment that the SSH Connector can execute code on simultaneously. 3) sshEnvironmentControl This holds the code for changing the state of the remote Environment. It can change the user that the environment is loged in as or perhaps change the console type such as from BASH to MySQL and so on. 4) sshBufferControl This holds the logic for executing commands over the Paramiko SSH Channel. 5) sshConnect This holds the logic for logging into and disconnecting from a target machine. The SSH Connector also has libraries of its own. 1) sshChannelEnvironment This is a special set of classes that wrap around a Paramiko Channel. These classes store relevant information about the remote target shell environment. This data is both used and manipulated by the main SSH Connector classes noted above. The main class is EnvironmentControls and inherits sshEnvironment which inherits sshChannelWrapper which inherits Paramko.Channel. Thus this object is used inplace of the Paramko Channel object. 2) SFTPChannel This is a special package which includes a class and functions for interacting with a remote box via sFTP protocol. 3) SCPChannel This is a special package which includes a class and functions for interacting with a remote box as if using the 'scp' command.","title":"sshConnector"},{"location":"PyLinuxDiagnosticToolKit/sshConnector/#ssh-connector","text":"This is a 'Connector' for the OS Diagnostic Tool Kit or OSDTK . (Currently called Linux Diagnostic Tool Kit/LDTK). As the name suggest, this connector uses the SSH protocol to connect to its target. It uses the Python library Paramiko. This adds support for threading, supports the CommandContainer object which is used by the OSDTK to handle executing commands and helps manage the environment on the remote target. IE: console variables, prompt, user permissions, etc... The SSH Connector uses inheritance to break up the code into logical packages. Here is the list of classes in order from top child class to the first parent. 1) sshThreader This is the top level class and as the name implies it handles threading. 2) sshEnvironmentManager The next class has the logic for handling the multiple TTYs/Paramiko Channels. Each channel has its own environment that the SSH Connector can execute code on simultaneously. 3) sshEnvironmentControl This holds the code for changing the state of the remote Environment. It can change the user that the environment is loged in as or perhaps change the console type such as from BASH to MySQL and so on. 4) sshBufferControl This holds the logic for executing commands over the Paramiko SSH Channel. 5) sshConnect This holds the logic for logging into and disconnecting from a target machine. The SSH Connector also has libraries of its own. 1) sshChannelEnvironment This is a special set of classes that wrap around a Paramiko Channel. These classes store relevant information about the remote target shell environment. This data is both used and manipulated by the main SSH Connector classes noted above. The main class is EnvironmentControls and inherits sshEnvironment which inherits sshChannelWrapper which inherits Paramko.Channel. Thus this object is used inplace of the Paramko Channel object. 2) SFTPChannel This is a special package which includes a class and functions for interacting with a remote box via sFTP protocol. 3) SCPChannel This is a special package which includes a class and functions for interacting with a remote box as if using the 'scp' command.","title":"SSH Connector"},{"location":"reference/CommandContainers/","text":"Module CommandContainers View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Ryan Henrichson, Timothy Nodine # Version: 1.1.0 # Description: This is an object that contains/wraps a single command or other CommandContainers too support multiple # commands. It is designed to be thread safe and has many helper functions designed to assist in working with commands # in a threaded/network environment. It is highly customizable allowing for both a simple single command or to be part # of a batch or queue. It also provides the ability for custom pre/post tasks which are functions to run specifically # when failures are detected and tasks to run when commands complete. # For more information review the README file found in the same directory as this. from __future__ import annotations import logging import re import traceback import time import uuid from collections import OrderedDict from threading import RLock , Event from functools import partial from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import SSHExceptionConn , RequirementsException , PreparserException , \\ ExecutionException , PostParserException , SetFailureException , CompletionTaskException , TimeoutException , \\ DataFormatException , ForceCompleteException , BetweenBitException , TimeToFirstBitException from PyMultiTasking import safe_acquire , safe_release , method_wait , MultiEvent , PriorityTaskQueue , Task from PyMultiTasking.ThreadingUtils import ThreadPool as Pool from LinuxModules import genericCmdModule from typing import Any , Optional , Union , Hashable , Iterable , List , Callable # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.INFO) log = logging . getLogger ( 'CommandContainers' ) # Regex's used to pull command tags. # ensure that data was returned matchRe = re . compile ( r '(?<=^CMDSTART).+' , flags = re . MULTILINE | re . DOTALL ) # clean up any errors or other data that may appear before the start tag startSubRe = re . compile ( r '.*?(?=^CMDSTART)' , flags = re . MULTILINE | re . DOTALL ) # clean up all data after the end tag endSubRe = re . compile ( r 'CMDEND.*' , flags = re . MULTILINE | re . DOTALL ) #Unparse the command string unParseCmd = re . compile ( r 'echo CMDSTART &&(.*)&& echo CMDEND' ) class CommandData ( object ): \"\"\" This is where all the data associated with the Command is located. \"\"\" _results : Any = None _lastResults : Any = None failure = None complete : bool = False running : bool = False parsed : bool = False noParsing : Union [ None , bool ] = None children : Any = None parent : Any = None events : list = None timeout : Union [ int , float ] = None __PRIORITY__ : int = 10 __OBJECTLOCK__ : RLock = None kwargs : dict = {} args : tuple = () EnvironmentObject : Optional [ EnvironmentControls ] = None _EnvironmentObjectBackup : Optional [ EnvironmentControls ] = None root : bool = None tki = None _tkiBackup = None _event : MultiEvent = None _completionEvent : Event = None _stopOnFailure : bool = None _timeoutExceptions : bool = None rawResults : str = None def __init__ ( self , timeout : Union [ int , float ] = 300 , root : bool = None , event : Optional [ MultiEvent ] = None , noParsing : Optional [ bool ] = None , stopOnFailure : Optional [ bool ] = None , timeoutExceptions : Optional [ Exception ] = None , * args , ** kwargs ): \"\"\" The bottom level parent. All other classes inherit this class down the chain. - :param timeout: This is the global timeout for encompassing all actions taken on or in this CommandObject. - :param root: This determines if root is required to run this command. - :param event: This provides a pre-existing event that will be set once the CommandObject is complete. - :param noParsing: do not parse results using the default methods - :param stopOnFailure: stop queue or unthreaded execution, or prevent completion tasks if an error occurs - :param timeoutExceptions: return an exception instead of None if something times out - :return: \"\"\" self . timeout = timeout or kwargs . get ( 'runTimeout' ) or kwargs . get ( 'wait' ) or 300 if type ( self . timeout ) not in ( int , float ): self . timeout = 300 self . __OBJECTLOCK__ = RLock () self . __LASTRESULTSLOCK__ = RLock () self . args = args self . kwargs = kwargs self . noParsing = noParsing is True self . _stopOnFailure = stopOnFailure is True self . _timeoutExceptions = timeoutExceptions is True if not self . tki : self . tki = self . _tkiBackup = kwargs . get ( 'tki' , {}) if root is None : root = getattr ( getattr ( self . tki , 'arguments' , None ), 'root' , False ) self . root = root self . children = [] self . parent = None if 'runTimeout' not in self . kwargs : self . kwargs [ 'runTimeout' ] = self . timeout self . _event = MultiEvent () self . _completionEvent = Event () self . _completionEvent . set () if event is None : event = Event () if self . events is None : self . events = [] self . addEvent ( event ) def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ): raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ): self . events . append ( event ) def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: { self } ' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: { self } : { child } ' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) # noinspection PyUnresolvedReferences def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: { self } ' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: { self } : { child } ' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) def _setEvents ( self ) -> None : \"\"\" This transverses the list of events known to this object and sets them. \"\"\" for item in self . events : item . set () @staticmethod def _isKwargs ( item : dict ) -> bool : \"\"\" This is a helper function for _parseCommand. It checks to see if the dictionary type object is a command or multiple commands. \"\"\" return 'command' in item @staticmethod def _hasKwargs ( item : dict ) -> list : \"\"\" This is a helper function for _parseCommand. It checks to see if the parent dictionary type object has custom functions. \"\"\" return [ c for c in [ 'requirements' , 'preparser' , 'postparser' , 'completiontask' ] if c in item ] @staticmethod def _needsKwargs ( item : dict ) -> bool : \"\"\" This is a helper function for _parseCommand. It checks to see if the parent dictionary type object needs updating to be suitable for use as kwargs. \"\"\" return CommandData . _hasKwargs ( item ) or ( not CommandData . _isKwargs ( item ) and len ( item ) - len ( CommandData . _hasKwargs ( item )) == 1 ) @staticmethod def _injectCommandKey ( item : dict , key : Hashable ) -> dict : \"\"\" This is a helper function for _processMultiItemIterable. It makes sure that commandKey is in kwargs because it is a requirement when creating a CommandObject. \"\"\" if 'commandKey' not in item : item [ 'commandKey' ] = key return item @staticmethod def _isQue ( item : Iterable ) -> bool : \"\"\" This is a helper function for _parseCommand. Determines if the iterable datatype is a queue or a batch. - :return: bool: True if queue, False if batch \"\"\" return isinstance ( item , ( OrderedDict , list , tuple )) @staticmethod def _createTags ( command : Optional [ Any ] = None , noParsing : bool = False , ignoreAlias : bool = False ) \\ -> Union [ DataFormatException , Union [ dict , str ]]: \"\"\" This is designed to add command tags to the beginning and end of a command. These tags help determine success and failure and also helps parse the output. The noParsing flag can stop this from being added. The idea here is that not all commands will run on bash. \"\"\" if noParsing : if type ( command ) is dict and len ( command ) > 0 : command = command . values () . pop () if isinstance ( command , str ): return command return DataFormatException ( f \"The command is not formatted correctly: { command } \" ) if isinstance ( command , dict ): for key , value in command . items (): if not re . search ( 'echo CMDSTART.*echo CMDEND' , value , flags = re . DOTALL | re . MULTILINE ): if ignoreAlias : value = \"command \" + value command [ key ] = re . sub ( r '(.+)' , r 'COLUMNS=200; export COLUMNS; echo CMDSTART && \\1 && echo CMDEND' , value , flags = re . DOTALL | re . MULTILINE ) if len ( command ) == 1 : return list ( command . values ()) . pop () return command if not isinstance ( command , str ): return '' if not re . search ( 'echo CMDSTART.*echo CMDEND' , command , flags = re . DOTALL | re . MULTILINE ): if ignoreAlias : command = \"command \" + command return re . sub ( r '(.+)' , r 'COLUMNS=200; export COLUMNS; echo CMDSTART && \\1 && echo CMDEND' , command , flags = re . DOTALL | re . MULTILINE ) return command @property def results ( self ): try : with self . __OBJECTLOCK__ : return self . _results except RuntimeError as e : log . error ( f 'ERROR: for results property: { e } ' ) log . debug ( f '[DEBUG] for results property: { traceback . format_exc () } ' ) @results . setter def results ( self , value ): try : with self . __OBJECTLOCK__ : self . _results = value self . _event . set () self . _setEvents () except RuntimeError as e : log . error ( f 'ERROR: for results.setter property: { e } ' ) log . debug ( f '[DEBUG] for results.setter property: { traceback . format_exc () } ' ) @results . deleter def results ( self ): try : with self . __OBJECTLOCK__ : self . _results = None except RuntimeError as e : log . error ( f 'ERROR: for results.deleter property: { e } ' ) log . debug ( f '[DEBUG] for results.deleter property: { traceback . format_exc () } ' ) @property def lastResults ( self ): try : with self . __LASTRESULTSLOCK__ : return self . _lastResults except RuntimeError as e : log . error ( f 'ERROR: for lastResults property: { e } ' ) log . debug ( f '[DEBUG] for lastResults property: { traceback . format_exc () } ' ) @lastResults . setter def lastResults ( self , value ): try : with self . __LASTRESULTSLOCK__ : self . _lastResults = value except RuntimeError as e : log . error ( f 'ERROR: for lastResults.sette property: { e } ' ) log . debug ( f '[DEBUG] for lastResults.sette property: { traceback . format_exc () } ' ) @lastResults . deleter def lastResults ( self ): try : with self . __LASTRESULTSLOCK__ : self . _lastResults = None except RuntimeError as e : log . error ( f 'ERROR: for lastResults.deleter property: { e } ' ) log . debug ( f '[DEBUG] for lastResults.deleter property: { traceback . format_exc () } ' ) class CommandParsers ( CommandData ): \"\"\" This is where all standard and custom parsing goes. \"\"\" _command : Any = None _commandKey : str = None customPostParser : bool = False def __init__ ( self , command : Any , commandKey : Union [ None , str ], ** kwargs ): \"\"\" Parse the command and the commandKey that identifies the container. - :param command: The datatype of command depends on the behavior of the CommandObject. If it is a string or a single length iterable, then the command becomes a string. - :param commandKey: The name of the command object. This object might be bound to a class if created through the 'simpleExecute' method. In that case, this is also the variable name that gets bound. This also helps determine its __hash__ and __str__. \"\"\" super ( CommandParsers , self ) . __init__ ( ** kwargs ) if isinstance ( command , dict ) and CommandData . _needsKwargs ( command ) and not commandKey : commandKey , command = self . _findCmdAndKey ( command ) self . commandKey = ( command , commandKey ) # print(f'command/type = {command} / {type(command)}') self . commandRaw = self . command = command @staticmethod def _findCmdAndKey ( command : dict ) -> tuple : for cmdKey , cmd in command . items (): if cmdKey not in [ 'requirements' , 'preparser' , 'postparser' , 'completiontask' , 'onFail' ]: return cmdKey , cmd @staticmethod def _parseCommandInput ( command : Optional [ Union [ str , dict ]] = None , commandKey : Optional [ str ] = None ) -> str : \"\"\" Used by simpleExecute. Use it to retrieve a command object by name after using simpleExecute. - :param command: This can either be a str or a single item dict - :param commandKey: - :return: A tuple. First item is the key and the second item is the value \"\"\" if not command and not commandKey : return CommandParsers . _parseCmdObjKey ( str ( uuid . uuid1 ())) if isinstance ( commandKey , str ) or isinstance ( command , str ): return CommandParsers . _parseCmdObjKey ( command , commandKey ) try : if commandKey is None : return CommandParsers . _parseCmdObjKey ( '' . join ( command )) except : pass return CommandParsers . _parseCmdObjKey ( str ( uuid . uuid1 ())) @staticmethod def _parseCmdObjKey ( cmd : Optional [ str ] = None , cmdKey : Optional [ str ] = None ) -> str : \"\"\" This static method is designed to parse the command key. The command key may be used as the name of this object if it is bound to another object. Namespaces have restrictions and cannot have certain characters. This static removes invalid characters. This is static so that it can be accessed outside of the class object allowing a programmer to use this anytime and ensure that the name is always the same. - :param cmd: The command variable from init - :param cmdKey: The commandkey variable from init - :return: str \"\"\" def _replaceStringHelper ( tmpStr ): return tmpStr . replace ( '/' , '' ) . replace ( '-' , '' ) . replace ( '.' , '' ) . replace ( ',' , '' ) . replace ( ';' , '' ) . \\ replace ( \"'\" , '' ) . replace ( '\"' , '' ) . replace ( ' ' , '' ) if not cmd and not cmdKey : return '' if not cmdKey : cmdKey = cmd elif ' %s ' in cmdKey and isinstance ( cmd , str ): return cmdKey % _replaceStringHelper ( cmd ) return _replaceStringHelper ( cmdKey ) @staticmethod def _parseCommand ( command : Any , noParsing : bool = False , ignoreAlias : bool = False ) -> Any : \"\"\" This is an designed to parse the command variable from init. It determines if the command is a single command or a queue or batch of commands. This is based on the command datatype and structure. \"\"\" # print(f'command/type: {command} / {type(command)}') if isinstance ( command , str ): return CommandData . _createTags ( command , noParsing , ignoreAlias ) if len ( command ) == 1 : return CommandParsers . _processSingleItemIterable ( command , noParsing , ignoreAlias ) if isinstance ( command , Iterable ): if CommandData . _isQue ( command ): return CommandParsers . _processMultiItemIterable ( command ) return set ( CommandParsers . _processMultiItemIterable ( command )) @staticmethod def _processSingleItemIterable ( command : Iterable , noParsing : bool , ignoreAlias : bool ) -> str : \"\"\" This is a helper function for '_parseCommand'. This is designed to handle an iterable that only has one command to run. The command is then run in this Object. \"\"\" if isinstance ( command , set ) or isinstance ( command , list ): command = command . pop () elif isinstance ( command , dict ): command = list ( command . values ()) . pop () elif isinstance ( command , tuple ): command = command [ 0 ] return CommandData . _createTags ( command , noParsing , ignoreAlias ) @staticmethod def _processMultiItemIterable ( command : Iterable ) -> Any : \"\"\" This is a helper function for '_parseCommand'. This is designed to handle an iterable that has multiple commands to run. It creates new CommandContainers for each 'command' that it iterates through. \"\"\" children = [] if isinstance ( command , dict ): for key , item in command . items (): if CommandData . _isKwargs ( item ): item = CommandData . _injectCommandKey ( item , key ) children . append ( CommandContainer ( ** item )) else : children . append ( CommandContainer ( item , key )) else : for item in command : if isinstance ( item , dict ) and CommandData . _isKwargs ( item ): children . append ( CommandContainer ( ** item )) else : children . append ( CommandContainer ( item , None )) return children @staticmethod def _singleCommandParser ( cmdResults : Union [ Any , str ]) -> str : \"\"\" This is used specifically by _parseResults but also in all simple parsing functions. Parses only the output of a single command from a string. \"\"\" if not isinstance ( cmdResults , str ): return cmdResults # compile these up front one time for better performance on repeated calls # all this parsing helps us handle custom prompts and other weirdness better # The 'replace' method is to solve oddiets with Ubuntu subsell returning '\\r\\n\\r' which breaks regex cmdOutputRe = matchRe . search ( startSubRe . sub ( '' , cmdResults . replace ( ' \\r\\n\\r ' , ' \\r\\n ' ), count = 1 )) if cmdOutputRe : output = endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ) . strip () if not output : return '' return output return '' @property def command ( self ): try : with self . __OBJECTLOCK__ : return self . _command except RuntimeError as e : log . error ( f 'ERROR: for command property: { e } ' ) log . debug ( f '[DEBUG] for command property: { traceback . format_exc () } ' ) @command . setter def command ( self , value ): \"\"\" This makes sure that command is parsed and calls _handleChildren() to take care of any children. \"\"\" try : with self . __OBJECTLOCK__ : output = self . _parseCommand ( value , self . noParsing , self . kwargs . get ( 'ignoreAlias' , False )) if type ( output ) is list or type ( output ) is set : self . _command = None self . children = output self . handleChildren ( tki = self . tki ) elif isinstance ( output , str ): self . _command = output except RuntimeError as e : log . error ( f 'ERROR: for command.setter property: { e } ' ) log . debug ( f '[DEBUG] for command.setter property: { traceback . format_exc () } ' ) @command . deleter def command ( self ): try : with self . __OBJECTLOCK__ : self . _command = None except RuntimeError as e : log . error ( f 'ERROR: for command.deleter property: { e } ' ) log . debug ( f '[DEBUG] for command.deleter property: { traceback . format_exc () } ' ) @property def commandUnparsed ( self ): command = self . command if '&&' in command and 'CMDSTART' in command : for cmd in unParseCmd . findall ( command ): return cmd return command @property def commandKey ( self ): return self . _commandKey @commandKey . setter def commandKey ( self , value ): \"\"\" This passes the value through _parseCommandInput() before applying the command key value. It requires that value be a tuple. :value: tuple \"\"\" self . _commandKey = self . _parseCommandInput ( * value ) class CommandRequirements ( CommandParsers ): \"\"\" This class handles the Requirements for a Command. It parses the provided requirements and the runRequirements method it has is called when the Requirement phase starts. Which is at the start of the execution. Requirements can either be a list, dict, or callable object. \"\"\" requirements : Any = None requirementTasks : list = None requirementFailureVar : dict = None requirementIncompleteVar : dict = None _requirementKeys : set = None _requirementResults : OrderedDict = None __REQUIREMENT_LOCK__ : RLock = None def __init__ ( self , command : Any , commandKey : Optional [ str ], requirements : Optional [ Any ] = None , ** kwargs ): \"\"\" This init's job is too setup the requirements and make sure that they are correctly formatted. :param command: passing thru to the next container :param commandKey: passing thru to the next container :param requirements: takes this which can either be list, dict, or callable :param kwargs: passed thru to the next container \"\"\" self . __REQUIREMENT_LOCK__ = RLock () super ( CommandRequirements , self ) . __init__ ( command , commandKey , ** kwargs ) if 'requirementsCondition' in kwargs : self . setRequirementsFailureCondition ( kwargs . pop ( 'requirementsCondition' )) self . requirementFailureVar = {} self . requirementIncompleteVar = {} self . _requirementKeys = set () if requirements is not None : self . requirements = requirements if self . requirements : self . _parseRequirements () def runRequirements ( self ) -> Optional [ Exception ]: \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks ) def _parseRequirements ( self ) -> Optional [ Exception ]: \"\"\" This is called by __init__ and its job is to setup the requirements and make it ready for execution. - :return: None. An exception is raised if there is an error. \"\"\" try : if not self . requirements : return None requirements = self . _parseRequirementsHelper ( self . requirements ) if type ( requirements ) is not list : requirements = [ requirements ] self . requirementTasks = requirements if len ( self . requirementTasks ) != len ( self . _requirementKeys ): raise RequirementsException ( f \"The func keys for requirements does not match the number of \" f \"requirementTasks \\n requirementKeys: \" f \" { self . _requirementKeys } \\n requirementTasks: { self . requirementTasks } \" ) self . requirementResults = OrderedDict ([]) except Exception as e : log . error ( f \"ERROR: Requirements setup failed: \\n { e } \\n \" ) log . debug ( f \"[DEBUG] for _parseRequirements: { traceback . format_exc () } \" ) raise e def _parseRequirementsHelper ( self , rawRequirements : Any ) -> Union [ List [ partial ], partial , Exception ]: \"\"\" This is the work horse of the __init__/_parseRequirements methods. This is a recursive method that attempts to parse requirements and turn them into callable partials for the _requirementRunner method to be used by the Pool. - :param rawRequirements: can either be a list, dict, or callable. - :return: This is either a partial a list of partials or an Exception \"\"\" if type ( rawRequirements ) is list : return [ self . _parseRequirementsHelper ( item ) for item in rawRequirements ] if callable ( rawRequirements ): self . _requirementKeys . add ( str ( rawRequirements )) if hasattr ( self , 'requirementsFailureCondition' ): self . requirementFailureVar . update ({ str ( rawRequirements ): self . requirementsFailureCondition }) return partial ( self . _requirementRunner , str ( rawRequirements ), rawRequirements , 0.1 , None , False ) if 'failureVar' in rawRequirements : self . requirementFailureVar . update ({ rawRequirements [ 'funcKey' ]: rawRequirements [ 'failureVar' ]}) elif hasattr ( self , 'requirementsFailureCondition' ): try : # dict of any length self . requirementFailureVar . update ( { rawRequirements . get ( 'funcKey' , rawRequirements . keys ()[ 0 ]): self . requirementsFailureCondition }) except : # callable object self . requirementFailureVar . update ({ str ( rawRequirements ): self . requirementsFailureCondition }) if isinstance ( rawRequirements , dict ): if len ( rawRequirements ) == 1 : funcKey = list ( rawRequirements . keys ())[ 0 ] self . _requirementKeys . add ( funcKey ) return partial ( self . _requirementRunner , funcKey , rawRequirements [ funcKey ], 0.1 , None , False ) if len ( rawRequirements ) > 1 : if 'funcKey' not in rawRequirements or 'func' not in rawRequirements : raise RequirementsException ( \"Invalid requirements format\" ) self . requirementIncompleteVar . update ( { rawRequirements [ 'funcKey' ]: rawRequirements . get ( 'incompleteVar' , None )}) self . _requirementKeys . add ( rawRequirements [ 'funcKey' ]) return partial ( self . _requirementRunner , ** rawRequirements ) raise RequirementsException ( \"Invalid requirements format\" ) def _requirementRunner ( self , funcKey : str , func : Callable , delay : float = 0.1 , incompleteVar : Any = None , raiseExc : bool = False , * args , ** kwargs ) -> None : \"\"\" Created by the _parseRequirementsHelper method and passed to the Pool for threading. This takes the results of methodWait from Pool and stores the output in requirementResults. - :param funcKey: This is used as the key associated with the output for requirementResults. - :param func: The callable that will be passed to methodWait. - :param delay: How long in between runs - :param incompleteVar: The variable used to determine if the 'func' being called has finished - :param raiseExc: Tells methodWait whether or not to raise or return an exception if an exception occurs - :param args: passed to methodWait and then to the 'func' - :param kwargs: passed to methodWait and then to the 'func'. However it may container failureVar which is pulled from kwargs and used as a control for methodWait. - :return: None \"\"\" kwargs . update ({ 'this' : self }) self . requirementResults . update ({ funcKey : method_wait ( func , timeout = self . timeout , delay = delay , incompleteVar = incompleteVar , raiseExc = raiseExc , * args , ** kwargs )}) def _detectRequirementFailure ( self , requirements : Any ) -> Optional [ Exception ]: \"\"\" This attempts to detect if there was a failure in the requirements. Checks to see if requirementResults exists. Then checks requirementResults for length against the original requirements. This can be different if an exception occurred and _requirementRunner did not update requirementResults. Lastly it checks all the results as follows: Results are an exception. Results are equal to incompleteVar (did not finish). Was failureVar provided and if do are results equal to it. All failures are collected into a single RequirementsException. - :param requirements: This is the requirementTasks which is a list of callables. - :return: None or Exception \"\"\" if not self . requirementResults : log . error ( \"ERROR: Requirements results are empty\" ) return RequirementsException ( \"Requirements results are empty\" ) if isinstance ( self . requirementResults , Exception ): log . error ( f \"An Exception occurred within the requirements: { self . requirementResults } \" ) return RequirementsException ( self . requirementResults ) if not isinstance ( self . requirementResults , dict ): log . error ( self . requirementResults ) return DataFormatException ( f \"The requirementsResults should be a dict but instead are \" f \" { type ( self . requirementResults ) } \" ) if self . requirementResults and len ( requirements ) != len ( self . requirementResults ): missingReq = set . difference ( self . _requirementKeys , set ( self . requirementResults . keys ())) log . error ( f \"ERROR: Missing requirements results after execution: { missingReq } \" ) return RequirementsException ( f \"Requirements did not complete: { missingReq } \" ) if self . requirementResults : failedReqs = [] for funcKey , results in self . requirementResults . items (): failureVar = self . requirementFailureVar . get ( funcKey , None ) incompleteVar = self . requirementIncompleteVar . get ( funcKey , None ) if isinstance ( results , Exception ) or \\ results is incompleteVar or \\ funcKey in self . requirementFailureVar and results is failureVar : failedReqs . append ( funcKey ) if failedReqs : return RequirementsException ( f \"Requirements failed: { ', ' . join ( failedReqs ) } \" ) def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition @property def requirementResults ( self ): \"\"\" Wraps requirementResults with a lock. \"\"\" try : with self . __REQUIREMENT_LOCK__ : return self . _requirementResults except RuntimeError as e : log . error ( f 'ERROR: for requirementResults property: { e } ' ) log . debug ( f '[DEBUG] for requirementResults property: { traceback . format_exc () } ' ) @requirementResults . setter def requirementResults ( self , value ): try : with self . __REQUIREMENT_LOCK__ : self . _requirementResults = value except RuntimeError as e : log . error ( f 'ERROR: for requirementResults.setter property: { e } ' ) log . debug ( f '[DEBUG] for requirementResults.setter property: { traceback . format_exc () } ' ) @requirementResults . deleter def requirementResults ( self ): try : with self . __REQUIREMENT_LOCK__ : self . _requirementResults = OrderedDict () except RuntimeError as e : log . error ( f 'ERROR: for requirementResults.deleter property: { e } ' ) log . debug ( f '[DEBUG] for requirementResults.deleter property: { traceback . format_exc () } ' ) # noinspection PyMethodMayBeStatic,PyUnusedLocal class CommandSetup ( CommandRequirements ): \"\"\" This is where the setup before running the command occurs. Requirements and the preparser are executed here. This also does the preliminary checking to ensure commands can be run. \"\"\" def __init__ ( self , command : Any , commandKey : Optional [ str ], preparser : Optional [ Callable ] = None , postparser : Optional [ Callable ] = None , onFail : Optional [ Callable ] = None , completiontask : Optional [ Callable ] = None , ** kwargs ): super ( CommandSetup , self ) . __init__ ( command , commandKey , ** kwargs ) if preparser is not None : self . _preparser = preparser if postparser is not None : self . _postparser = postparser self . customPostParser = True if onFail is not None : self . _onFailure = onFail if completiontask is not None : self . _completionEvent . clear () self . _onComplete = completiontask self . customPostParser = True def _preparser ( self , * args , ** kwargs ) -> Any : \"\"\" Placeholder for custom command preparser. All parsers MUST accept *args and **kwargs. Must return bool value or None (None means Failure). \"\"\" return True def _postparser ( self , results : Optional [ str ] = None , this : Optional [ Any ] = None , ** kwargs ) -> Any : \"\"\" Placeholder for custom command parser. All parsers MUST accept **kwargs. May be a single function or method or a list thereof. Must return results or None (None means Failure). \"\"\" return results def _onFailure ( self , results : Optional [ str ] = None , this : Optional [ Any ] = None , ** kwargs ) -> Any : \"\"\" Standard on fail method and a placeholder for a custom on fail method \"\"\" return results def _onComplete ( self , results : Optional [ str ] = None , this : Optional [ Any ] = None , ** kwargs ) -> Any : \"\"\" Placeholder for custom onComplete function. This is called by performComplete which is called by the exit magic function. :return: bool: True or False \"\"\" return results def runCommandSetup ( self , ** kwargs ) -> Optional [ Exception ]: \"\"\" Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface \"\"\" if ( self . EnvironmentObject is None and 'EnvironmentObject' not in kwargs ) and self . tki is None : log . error ( \"ERROR: ToolKitInterface and EnvironmentObject not found\" ) return ExecutionException ( 'ToolKitInterface and EnvironmentObject not found' ) self . _setup ( ** kwargs ) def _setup ( self , ** kwargs ) -> None : \"\"\" This checks to see if there are any requirements before this command can be executed. If there are, the requirements are executed in a batch using _requirementsRunner. \"\"\" self . EnvironmentObject = self . _EnvironmentObjectBackup = kwargs . get ( 'EnvironmentObject' ) if self . EnvironmentObject : self . EnvironmentObject . commandObject = self if self . root : self . EnvironmentObject . becomeRoot () if 'tki' in kwargs : self . tki = self . _tkiBackup = kwargs . get ( 'tki' ) self . handleChildren ( tki = self . tki ) def _preparserRunner ( self ): try : if type ( self . _preparser ) is list : preparResults = None for prepar in self . _preparser : preparResults = prepar ( this = self ) if self . failure or self . complete : break return preparResults return self . _preparser ( this = self ) except Exception as e : log . error ( f \"ERROR in _preparserRunner: { e } \" ) log . debug ( f \"[DEBUG] for _preparserRunner: { traceback . format_exc () } \" ) return PreparserException ( e , baseException = e ) class CommandContainer ( CommandSetup ): \"\"\" This is most of the logic/work is done. Note that this object is automatically created as an inherited class via CommandContainer below. Type checks are also automatically performed during execution that require this structure. This may be cleaned up at some point but there are no issues due to it so it is low priority. Just remember to use CommandContainer if manually creating CommandObjects. \"\"\" startTime : float = None endTime : float = None def __init__ ( self , * args , ** kwargs ): \"\"\" This class has nothing to do here. It is the work horse not the _setup(). Main user functions (aside from context manager): executor() waitForResults() forceComplete() resetContainers() Other public functions usually not directly accessed by a user: setLastResults() checkResults() (used by setLastResults()) setFailure() (called from setLastResults()) performComplete() finalizeExecution() Note that methods are clustered closest to other dependent methods to promote better reading flow. Statics and privates are mixed in with publics, but properties are always at the bottom and magics on top. \"\"\" log . info ( \"Setting up CommandContainer\" ) super ( CommandContainer , self ) . __init__ ( * args , ** kwargs ) self . startTime = None self . endTime = None def __hash__ ( self ): return hash ( self . commandKey ) def __enter__ ( self ): if safe_acquire ( self . __OBJECTLOCK__ , self . timeout ): self . _event . clear () self . running = True return self else : log . error ( f \"ERROR: CommandObject waitLock failed with timeout: { self . commandKey } : { self . timeout } \" ) log . debug ( f \"[DEBUG] for CommandOBject waitLock: { traceback . format_exc () } \" ) raise RuntimeError ( f \"CommandObject failed to obtain lock within the timeframe: \" f \" { self . commandKey } : { self . timeout } \" ) def __exit__ ( self , exc_type , exc_val , exc_tb ): safe_release ( self . __OBJECTLOCK__ ) self . _completionEvent . set () self . complete = True self . running = False log . debug ( f 'CommandObject completed: { self . commandKey } : { self . _command } ' ) def __str__ ( self ): return str ( self . commandKey ) def executor ( self , ** kwargs ) -> CommandContainer : \"\"\" This is the main function run in order to execute command(s). It requires that the EnvironmentObject and/or the tki variable be set. This is normally run after _setup() and is called from within _exeThread(). Steps: 1. Ensure the CommandObject is executable. 2. Requirements run and return None or an exception. 2. Preparser runs and returns whatever. 4. Execution of the command structure occurs and commands are executed and results returned. 5. Postparser runs using lastResults and returns the updated results. 6. Completion task runs using lastResults and returns nothing but can run setFailure() for stopOnFailure. 7. Finalization occurs moving lastResults to results and setting all remaining events. - :return: a copy of this container \"\"\" try : log . debug ( f \" ===== CommandObject executor running with command and children: \" f \" { self . commandKey } : { self . command } : { [ c . commandKey for c in self . children ] } ===== \" ) # Run requirements and preparser and abort if an exception is found self . startTime = time . time () if self . setLastResults ( self . runCommandSetup ( ** kwargs )): if self . setLastResults ( self . runRequirements (), phase = 'requirements' ): if self . setLastResults ( self . _preparserRunner (), phase = 'preparser' ): # Decision tree for which mode to execute in. Threaded/UnThreaded or unknown if self . EnvironmentObject is not None or self . children : self . setLastResults ( self . _executorThreadHelper (), phase = 'execution' ) elif self . EnvironmentObject is None : self . setLastResults ( self . _executorUnThreadedHelper (), phase = 'execution' ) else : # Y U NO SSH or whatever thing of error self . setLastResults ( self . _executorFailure ()) except Exception as e : # any unexpected exceptions could be anywhere in the process self . setLastResults ( self . _processException ( e )) finally : self . endTime = time . time () return self . finalizeExecution () def _executorThreadHelper ( self ) -> Union [ str , dict , Exception ]: \"\"\" Attempts to execute threaded commands in a batch or a queue, or a single threaded command. - :return: string for single command, dict for multiple commands, exception on error \"\"\" if self . command is not None : log . info ( f \"CommandObject has one threaded command: { self . commandKey } with kwargs: { self . kwargs } \" ) return self . EnvironmentObject . executeOnEnvironment ( cmd = self . command , ** self . kwargs ) if len ( self . children ) > 0 : log . info ( f \"CommandObject has threaded children: { self . commandKey } : { self . children } \" ) if type ( self . children ) is set : log . debug ( f 'CommandObject running batched children: { self . commandKey } : { self . children } ' ) return self . _executorHelper () if type ( self . children ) is list : log . debug ( f 'CommandObject running queued children: { self . commandKey } : { self . children } ' ) return self . _executorHelper ( _queue = True ) log . error ( f \"ERROR: CommandObject format of child data is invalid: { self . commandKey } : { self . children } \" ) return DataFormatException ( f 'CommandObject format of child data is invalid: ' f ' { self . commandKey } : { self . children } ' ) return self . _executorFailure () def _executorUnThreadedHelper ( self ) -> Union [ str , dict , Exception ]: \"\"\" Attempts to execute on the main ssh channel one command at a time. - :return: string for single command, dict for multiple commands, exception on error \"\"\" if self . command is not None : log . info ( f \"CommandObject has one unthreaded command: { self . commandKey } \" ) with self . tki . sshCon . mainEnvironment as env : return self . tki . sshCon . executeOnEnvironment ( env , self . command , ** self . kwargs ) if len ( self . children ) > 0 : log . info ( f \"CommandObject has unthreaded children: { self . commandKey } : { self . children } \" ) return self . _executorHelper ( threading = False ) return self . _executorFailure () def _executorHelper ( self , _queue : Optional [ Iterable ] = None , threading : bool = True ) -> Union [ dict , Exception ]: \"\"\" Designed to be a helper for _executorUnThreadedHelper() and _executorThreadHelper() for multiple commands. It is designed to help execute children. An unthreaded batch (unordered iterable data type only): stopOnFailure has no effect here and will be checked when waiting for results A threaded queue (ordered iterable data type, requires _timeout only): will return an exception if stopOnFailure is set, incomplete children will have required events set on containers to prevent hanging and waiting An unthreaded queue (_executorHelperhreading set to False, no _timeout): will return an exception if stopOnFailure is set, incomplete children will have required events set on containers to prevent hanging and waiting - :return: dict, exception on error if _stopOnFailure or _timeoutExceptions are true \"\"\" log . info ( f 'ExecutorHelper _queue = { _queue } and threading = { threading } ' ) if _queue : exHelperTimeout = sum ([ c . timeout for c in self . children ]) or self . timeout else : exHelperTimeout = max ([ c . timeout for c in self . children ]) or self . timeout _endTime = time . time () + exHelperTimeout log . debug ( f \"Looping through the childern with _endTime = { _endTime } \" ) for child in self . children : log . debug ( f \"Running child: { child . command } \" ) if 0 < _endTime <= time . time (): return TimeoutException ( f 'Batch execution timed out before child command: ' f ' { self . commandKey } : { child . commandKey } ' ) if _queue and ( 'EnvironmentObject' in self . kwargs and 'EnvironmentObject' not in child . kwargs ): child . kwargs [ 'EnvironmentObject' ] = self . kwargs [ 'EnvironmentObject' ] genericCmdModule . GenericCmdModule . simpleExecutor ( self , child , child . commandKey , tki = self . tki , threading = threading , ** child . kwargs ) if _queue or threading is False : # wait for each child in a queue child . waitForResults ( _endTime - time . time ()) # stopOnFailure only matters here if unthreaded or a queue to avoid waiting on each batch item if self . _stopOnFailure and child . failure : log . debug ( f \"Child command failed and stopped queue execution: { self . commandKey } : { child } \" ) return ExecutionException ( f 'Child command failed and stopped queue execution: ' f ' { self . commandKey } : { child } ' ) # wait for the batch to fully complete and always return the results for every scenario if self . children : return self . _waitForChildren ( wait = _endTime - time . time ()) def _executorFailure ( self ) -> Exception : \"\"\" Simply returns an exception when the executor encounters a (usually) internal issue. \"\"\" if self . command is None : log . error ( f \"CommandObject received no command or children: { str ( self ) } \" ) return ExecutionException ( f 'CommandObject received no command or children: { str ( self ) } ' ) log . error ( f \"Failed to determine execution mode for CommandObject: { self . commandKey } \" ) return ExecutionException ( f 'Failed to determine execution mode for CommandObject: { self . commandKey } ' ) def waitForResults ( self , wait : Optional [ Union [ float , int ]] = None ) -> Union [ str , dict , Exception ]: \"\"\" This is designed to wait until the command object is finished executing the command and parsing the results. - :param wait: use when the command object has children, defaults to the timeout attribute of the container \"\"\" if wait is None : wait = self . kwargs . get ( 'wait' , self . timeout ) or self . timeout if wait is True : wait = self . timeout if self . children : if self . _event . wait ( wait ) and self . _completionEvent . wait ( wait ): return self . results elif self . _event . wait ( wait ): return self . results if self . _timeoutExceptions : return TimeoutException ( f 'Command timed out waiting for results: { self . commandKey } ' ) def _waitForChildren ( self , wait : Optional [ Union [ float , int ]] = None ) -> Union [ str , dict , Exception ]: \"\"\" Private method to wait for just the children so the parent knows when to proceed \"\"\" if wait is None : wait = self . kwargs . get ( 'wait' , self . timeout ) or self . timeout if wait is True : wait = self . timeout if self . _event . wait ( wait ): return self . lastResults if self . _timeoutExceptions : return TimeoutException ( f 'Child commands timed out waiting for results: ' f ' { self . commandKey } : { self . children } ' ) def setLastResults ( self , results : Optional [ Any ] = None , resultsOrigin : Optional [ str ] = None , phase : Any = None , ** kwargs ) -> bool : \"\"\" This sets lastResults on the current object and tells the parent to do the same if a parent exists. - :param results: value used to set lastResults - :param resultsOrigin: name of the child command container if called by a child - :param phase: - :return: boolean value: True for success and False for failure found in the results \"\"\" if not self . checkResults ( results ): results = self . setFailure ( results , ** kwargs ) if resultsOrigin : try : self . lastResults . update ({ resultsOrigin : results }) except : self . lastResults = { resultsOrigin : results } else : self . lastResults = results if self . parent : self . parent . setLastResults ( results , self . commandKey ) if phase and self . startTime is not None and time . time () > self . startTime + self . timeout : log . debug ( f 'CommandObject timed out during phase: { self . commandKey } : { phase } ' ) raise TimeoutException ( f \"CommandObject timed out during phase: { self . commandKey } : { phase } \" ) if self . failure : return False return True def checkResults ( self , cmdData : Any = None ) -> bool : \"\"\" Check the cmdData (results) at any time to see if they are an exception. - :param cmdData: the results of the command at any point in the process \"\"\" if ( self . _stopOnFailure or not self . children ) and isinstance ( cmdData , Exception ): return False if self . children and not [ c for c in self . children if not c . failure ]: log . warning ( f 'All children failed: { self . commandKey } : { self . children } ' ) return False return True def setFailure ( self , results : Any = None , ** kwargs ) -> Any : \"\"\" The method is run if a failure was detected somewhere in the process. This process also kicks off the custom onFailure method. - :param results: results of the command or failure - :return: results of custom failure method or an exception \"\"\" try : log . warning ( f \"A failure occurred for Command: { str ( self . commandKey ) } \" ) log . debug ( f \"The raw failure results are: { results } \" ) return self . _onFailure ( results , this = self , ** kwargs ) except Exception as e : log . warning ( f 'Exception when setting failure for command: { str ( self . commandKey ) } ' ) log . debug ( f 'The raw failure results are: { results } ' ) return SetFailureException ( e , baseException = e ) finally : if not self . complete : self . forceComplete () self . failure = True def _parseResults ( self ) -> Any : \"\"\" This method is designed to do the reverse of the _createTags from CommandData except to the results of the command itself. It also calls the custom parser. - :return: the value of 'self.results' or Exception \"\"\" try : if self . parsed : return self . lastResults or self . results results = self . lastResults if not self . noParsing and not self . children : results = CommandContainer . _singleCommandParser ( results ) if not self . rawResults : self . rawResults = results if not self . customPostParser : return results if type ( self . _postparser ) is list : for pparser in self . _postparser : results = pparser ( results , this = self ) return results return self . _postparser ( results , this = self ) except Exception as e : log . error ( f 'Postparser exception: { self . commandKey } : { str ( self . _postparser ) } ' ) log . debug ( f 'Stack Trace: \\n { traceback . format_exc () } ' ) return PostParserException ( e , baseException = e ) finally : self . parsed = True def performComplete ( self ) -> Any : \"\"\" This is called by the __exit__ function and attempts to run a custom onComplete function. - :return: bool, results, or raises an exception on error \"\"\" try : if self . _completionEvent . is_set () or not self . customPostParser : return self . lastResults or self . results return self . _onComplete ( self . lastResults , this = self ) except Exception as e : log . error ( f 'Completion task exception: { self . commandKey } : { str ( self . _onComplete ) } ' ) log . debug ( f 'Stack Trace: \\n { traceback . format_exc () } ' ) return CompletionTaskException ( e , baseException = e ) def finalizeExecution ( self ) -> CommandContainer : \"\"\" This is the final wrap up step for the execution process and occurs only after the current object is done Moves lastResults to results and sets the event for the current object. Current event may be a shared multievent shared across parents and children. lastResults is then cleared. \"\"\" try : if self . _stopOnFailure : if not self . failure : if self . setLastResults ( self . _parseResults (), phase = 'finalizeOnFailure' ): self . performComplete () else : self . setLastResults ( self . _parseResults (), phase = 'finalize' ) self . performComplete () except Exception as e : self . setLastResults ( self . _processException ( e ), phase = 'finalizeOnException' ) finally : self . results = self . lastResults self . lastResults = None return self def _processException ( self , e : Exception ) -> Exception : \"\"\" General exception processor for errors during execution \"\"\" def _disconnectHelper (): try : log . debug ( \"Disconnecting SSH connection due to a failure\" ) if self . tki and not self . EnvironmentObject : self . tki . disconnect () if self . EnvironmentObject : self . EnvironmentObject . disconnectEnvironment () except Exception as secondaryException : log . debug ( f \"An unknown error occurred while attempting to disconnect: \" f \" { self . commandKey } . \\n Error: { secondaryException } \\n { traceback . format_exc () } \\n \" ) return secondaryException if not isinstance ( e , Exception ): return DataFormatException ( f \"The object provided is not an exception: { str ( e ) } \" ) objectType = type ( e ) if objectType == SSHExceptionConn : log . error ( f 'CONNECTION ERROR: { e } \\n { traceback . format_exc () } ' ) log . debug ( 'This usually occurs when the SSH connection is prematurely severed.' ) log . debug ( f 'The preRunner failed for CommandObject with preparser and requirements: ' f ' { self . commandKey } : { str ( self . _preparser ) } : { str ( self . requirements ) } ' ) e = _disconnectHelper () elif objectType == TimeToFirstBitException or objectType == BetweenBitException : log . error ( f \"Error receiving data from buffer after command was sent. \" f \" \\n Error: { e } \\n { traceback . format_exc () } \\n \" ) log . debug ( f 'The preRunner failed for CommandObject with preparser and requirements: ' f ' { self . commandKey } : { str ( self . _preparser ) } : { str ( self . requirements ) } ' ) e = _disconnectHelper () elif objectType == RuntimeError : log . error ( f 'A runtime error occurred when attempting to gain the lock on an object \\n ' f 'The commandKey is: { self . commandKey } \\n The preparser is: { str ( self . _preparser ) } ' f ' \\n The requirements are: { str ( self . requirements ) } ' ) log . debug ( f \"An error occurred trying to gain the lock of the Object: \" f \" { self . commandKey } . \\n Error: { e } \\n { traceback . format_exc () } \\n \" ) else : log . error ( f 'Error occurred: { objectType } \\n The commandKey is: { self . commandKey } \\n ' f 'The preparser is: { str ( self . _preparser ) } \\n The requirements are: { str ( self . requirements ) } ' ) log . debug ( f \"Error occurred: { self . commandKey } . \\n Error: { e } \\n { traceback . format_exc () } \\n \" ) return e @property def executionLength ( self ): try : if self . startTime and self . endTime : return round ( self . endTime - self . startTime , 10 ) except Exception : return 0.0 Variables endSubRe log matchRe startSubRe unParseCmd Classes CommandContainer class CommandContainer ( * args , ** kwargs ) This is most of the logic/work is done. Note that this object is automatically created as an inherited class via CommandContainer below. Type checks are also automatically performed during execution that require this structure. This may be cleaned up at some point but there are no issues due to it so it is low priority. Just remember to use CommandContainer if manually creating CommandObjects. Ancestors (in MRO) CommandContainers.CommandSetup CommandContainers.CommandRequirements CommandContainers.CommandParsers CommandContainers.CommandData Class variables EnvironmentObject args children complete customPostParser endTime events failure kwargs noParsing parent parsed rawResults requirementFailureVar requirementIncompleteVar requirementTasks requirements root running startTime timeout tki Instance variables command commandKey commandUnparsed executionLength lastResults requirementResults Wraps requirementResults with a lock. results Methods addEvent def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event ) checkResults def checkResults ( self , cmdData : 'Any' = None ) -> 'bool' Check the cmdData (results) at any time to see if they are an exception. :param cmdData: the results of the command at any point in the process View Source def checkResults ( self , cmdData : Any = None ) -> bool : \"\"\" Check the cmdData (results) at any time to see if they are an exception. - :param cmdData: the results of the command at any point in the process \"\"\" if ( self . _stopOnFailure or not self . children ) and isinstance ( cmdData , Exception ) : return False if self . children and not [ c for c in self . children if not c . failure ] : log . warning ( f 'All children failed: {self.commandKey} : {self.children}' ) return False return True executor def executor ( self , ** kwargs ) -> 'CommandContainer' This is the main function run in order to execute command(s). It requires that the EnvironmentObject and/or the tki variable be set. This is normally run after _setup() and is called from within _exeThread(). Steps: 1. Ensure the CommandObject is executable. 2. Requirements run and return None or an exception. 2. Preparser runs and returns whatever. 4. Execution of the command structure occurs and commands are executed and results returned. 5. Postparser runs using lastResults and returns the updated results. 6. Completion task runs using lastResults and returns nothing but can run setFailure() for stopOnFailure. 7. Finalization occurs moving lastResults to results and setting all remaining events. :return: a copy of this container View Source def executor ( self , ** kwargs ) -> CommandContainer : \"\"\" This is the main function run in order to execute command(s). It requires that the EnvironmentObject and/or the tki variable be set. This is normally run after _setup() and is called from within _exeThread(). Steps: 1. Ensure the CommandObject is executable. 2. Requirements run and return None or an exception. 2. Preparser runs and returns whatever. 4. Execution of the command structure occurs and commands are executed and results returned. 5. Postparser runs using lastResults and returns the updated results. 6. Completion task runs using lastResults and returns nothing but can run setFailure() for stopOnFailure. 7. Finalization occurs moving lastResults to results and setting all remaining events. - :return: a copy of this container \"\"\" try : log . debug ( f \" ===== CommandObject executor running with command and children: \" f \"{self.commandKey} : {self.command} : {[c.commandKey for c in self.children]} ===== \" ) # Run requirements and preparser and abort if an exception is found self . startTime = time . time () if self . setLastResults ( self . runCommandSetup ( ** kwargs )): if self . setLastResults ( self . runRequirements (), phase = 'requirements' ): if self . setLastResults ( self . _preparserRunner (), phase = 'preparser' ): # Decision tree for which mode to execute in. Threaded/UnThreaded or unknown if self . EnvironmentObject is not None or self . children : self . setLastResults ( self . _executorThreadHelper (), phase = 'execution' ) elif self . EnvironmentObject is None : self . setLastResults ( self . _executorUnThreadedHelper (), phase = 'execution' ) else : # Y U NO SSH or whatever thing of error self . setLastResults ( self . _executorFailure ()) except Exception as e : # any unexpected exceptions could be anywhere in the process self . setLastResults ( self . _processException ( e )) finally : self . endTime = time . time () return self . finalizeExecution () finalizeExecution def finalizeExecution ( self ) -> 'CommandContainer' This is the final wrap up step for the execution process and occurs only after the current object is done Moves lastResults to results and sets the event for the current object. Current event may be a shared multievent shared across parents and children. lastResults is then cleared. View Source def finalizeExecution ( self ) -> CommandContainer : \"\"\" This is the final wrap up step for the execution process and occurs only after the current object is done Moves lastResults to results and sets the event for the current object. Current event may be a shared multievent shared across parents and children. lastResults is then cleared. \"\"\" try : if self . _stopOnFailure : if not self . failure : if self . setLastResults ( self . _parseResults (), phase = 'finalizeOnFailure' ) : self . performComplete () else : self . setLastResults ( self . _parseResults (), phase = 'finalize' ) self . performComplete () except Exception as e : self . setLastResults ( self . _processException ( e ), phase = 'finalizeOnException' ) finally : self . results = self . lastResults self . lastResults = None return self forceComplete def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) handleChildren def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) hasEvent def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False performComplete def performComplete ( self ) -> 'Any' This is called by the exit function and attempts to run a custom onComplete function. :return: bool, results, or raises an exception on error View Source def performComplete ( self ) -> Any : \"\"\" This is called by the __exit__ function and attempts to run a custom onComplete function. - :return: bool, results, or raises an exception on error \"\"\" try : if self . _completionEvent . is_set () or not self . customPostParser : return self . lastResults or self . results return self . _onComplete ( self . lastResults , this = self ) except Exception as e : log . error ( f 'Completion task exception: {self.commandKey} : {str(self._onComplete)}' ) log . debug ( f 'Stack Trace:\\n {traceback.format_exc()}' ) return CompletionTaskException ( e , baseException = e ) resetContainers def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass runCommandSetup def runCommandSetup ( self , ** kwargs ) -> 'Optional[Exception]' Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface View Source def runCommandSetup ( self , ** kwargs ) -> Optional [ Exception ] : \"\"\" Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface \"\"\" if ( self . EnvironmentObject is None and 'EnvironmentObject' not in kwargs ) and self . tki is None : log . error ( \"ERROR: ToolKitInterface and EnvironmentObject not found\" ) return ExecutionException ( 'ToolKitInterface and EnvironmentObject not found' ) self . _setup ( ** kwargs ) runRequirements def runRequirements ( self ) -> 'Optional[Exception]' This is the only public method. It is called when the CommandContainer is being executed. Returns: Type Description None The output of _detectRequirementFailure which is either an exception or None View Source def runRequirements ( self ) -> Optional [ Exception ] : \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks ) setFailure def setFailure ( self , results : 'Any' = None , ** kwargs ) -> 'Any' The method is run if a failure was detected somewhere in the process. This process also kicks off the custom onFailure method. :param results: results of the command or failure :return: results of custom failure method or an exception View Source def setFailure(self, results: Any = None, **kwargs) -> Any: \"\"\" The method is run if a failure was detected somewhere in the process. This process also kicks off the custom onFailure method. - :param results: results of the command or failure - :return: results of custom failure method or an exception \"\"\" try: log.warning(f\"A failure occurred for Command: {str(self.commandKey)}\") log.debug(f\"The raw failure results are: {results}\") return self._onFailure(results, this=self, **kwargs) except Exception as e: log.warning(f'Exception when setting failure for command: {str(self.commandKey)}') log.debug(f'The raw failure results are: {results}') return SetFailureException(e, baseException=e) finally: if not self.complete: self.forceComplete() self.failure = True setLastResults def setLastResults ( self , results : 'Optional[Any]' = None , resultsOrigin : 'Optional[str]' = None , phase : 'Any' = None , ** kwargs ) -> 'bool' This sets lastResults on the current object and tells the parent to do the same if a parent exists. :param results: value used to set lastResults :param resultsOrigin: name of the child command container if called by a child :param phase: :return: boolean value: True for success and False for failure found in the results View Source def setLastResults ( self , results : Optional [ Any ] = None , resultsOrigin : Optional [ str ] = None , phase : Any = None , ** kwargs ) -> bool : \"\"\" This sets lastResults on the current object and tells the parent to do the same if a parent exists. - :param results: value used to set lastResults - :param resultsOrigin: name of the child command container if called by a child - :param phase: - :return: boolean value: True for success and False for failure found in the results \"\"\" if not self . checkResults ( results ) : results = self . setFailure ( results , ** kwargs ) if resultsOrigin : try : self . lastResults . update ( { resultsOrigin : results } ) except : self . lastResults = { resultsOrigin : results } else : self . lastResults = results if self . parent : self . parent . setLastResults ( results , self . commandKey ) if phase and self . startTime is not None and time . time () > self . startTime + self . timeout : log . debug ( f 'CommandObject timed out during phase: {self.commandKey} : {phase}' ) raise TimeoutException ( f \"CommandObject timed out during phase: {self.commandKey} : {phase}\" ) if self . failure : return False return True setRequirementsFailureCondition def setRequirementsFailureCondition ( self , requirementsFailureCondition : 'Any' ) -> 'None' This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. :param requirementsFailureCondition: :return: None View Source def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition waitForResults def waitForResults ( self , wait : 'Optional[Union[float, int]]' = None ) -> 'Union[str, dict, Exception]' This is designed to wait until the command object is finished executing the command and parsing the results. :param wait: use when the command object has children, defaults to the timeout attribute of the container View Source def waitForResults ( self , wait : Optional [ Union [ float , int ]] = None ) -> Union [ str , dict , Exception ] : \"\"\" This is designed to wait until the command object is finished executing the command and parsing the results. - :param wait: use when the command object has children, defaults to the timeout attribute of the container \"\"\" if wait is None : wait = self . kwargs . get ( 'wait' , self . timeout ) or self . timeout if wait is True : wait = self . timeout if self . children : if self . _event . wait ( wait ) and self . _completionEvent . wait ( wait ) : return self . results elif self . _event . wait ( wait ) : return self . results if self . _timeoutExceptions : return TimeoutException ( f 'Command timed out waiting for results: {self.commandKey}' ) CommandData class CommandData ( timeout : 'Union[int, float]' = 300 , root : 'bool' = None , event : 'Optional[MultiEvent]' = None , noParsing : 'Optional[bool]' = None , stopOnFailure : 'Optional[bool]' = None , timeoutExceptions : 'Optional[Exception]' = None , * args , ** kwargs ) This is where all the data associated with the Command is located. Descendants CommandContainers.CommandParsers Class variables EnvironmentObject args children complete events failure kwargs noParsing parent parsed rawResults root running timeout tki Instance variables lastResults results Methods addEvent def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event ) forceComplete def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) handleChildren def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) hasEvent def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False resetContainers def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass CommandParsers class CommandParsers ( command : 'Any' , commandKey : 'Union[None, str]' , ** kwargs ) This is where all standard and custom parsing goes. Ancestors (in MRO) CommandContainers.CommandData Descendants CommandContainers.CommandRequirements Class variables EnvironmentObject args children complete customPostParser events failure kwargs noParsing parent parsed rawResults root running timeout tki Instance variables command commandKey commandUnparsed lastResults results Methods addEvent def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event ) forceComplete def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) handleChildren def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) hasEvent def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False resetContainers def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass CommandRequirements class CommandRequirements ( command : 'Any' , commandKey : 'Optional[str]' , requirements : 'Optional[Any]' = None , ** kwargs ) This class handles the Requirements for a Command. It parses the provided requirements and the runRequirements method it has is called when the Requirement phase starts. Which is at the start of the execution. Requirements can either be a list, dict, or callable object. Ancestors (in MRO) CommandContainers.CommandParsers CommandContainers.CommandData Descendants CommandContainers.CommandSetup Class variables EnvironmentObject args children complete customPostParser events failure kwargs noParsing parent parsed rawResults requirementFailureVar requirementIncompleteVar requirementTasks requirements root running timeout tki Instance variables command commandKey commandUnparsed lastResults requirementResults Wraps requirementResults with a lock. results Methods addEvent def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event ) forceComplete def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) handleChildren def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) hasEvent def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False resetContainers def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass runRequirements def runRequirements ( self ) -> 'Optional[Exception]' This is the only public method. It is called when the CommandContainer is being executed. Returns: Type Description None The output of _detectRequirementFailure which is either an exception or None View Source def runRequirements ( self ) -> Optional [ Exception ] : \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks ) setRequirementsFailureCondition def setRequirementsFailureCondition ( self , requirementsFailureCondition : 'Any' ) -> 'None' This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. :param requirementsFailureCondition: :return: None View Source def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition CommandSetup class CommandSetup ( command : 'Any' , commandKey : 'Optional[str]' , preparser : 'Optional[Callable]' = None , postparser : 'Optional[Callable]' = None , onFail : 'Optional[Callable]' = None , completiontask : 'Optional[Callable]' = None , ** kwargs ) This is where the setup before running the command occurs. Requirements and the preparser are executed here. This also does the preliminary checking to ensure commands can be run. Ancestors (in MRO) CommandContainers.CommandRequirements CommandContainers.CommandParsers CommandContainers.CommandData Descendants CommandContainers.CommandContainer Class variables EnvironmentObject args children complete customPostParser events failure kwargs noParsing parent parsed rawResults requirementFailureVar requirementIncompleteVar requirementTasks requirements root running timeout tki Instance variables command commandKey commandUnparsed lastResults requirementResults Wraps requirementResults with a lock. results Methods addEvent def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event ) forceComplete def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) handleChildren def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) hasEvent def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False resetContainers def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass runCommandSetup def runCommandSetup ( self , ** kwargs ) -> 'Optional[Exception]' Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface View Source def runCommandSetup ( self , ** kwargs ) -> Optional [ Exception ] : \"\"\" Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface \"\"\" if ( self . EnvironmentObject is None and 'EnvironmentObject' not in kwargs ) and self . tki is None : log . error ( \"ERROR: ToolKitInterface and EnvironmentObject not found\" ) return ExecutionException ( 'ToolKitInterface and EnvironmentObject not found' ) self . _setup ( ** kwargs ) runRequirements def runRequirements ( self ) -> 'Optional[Exception]' This is the only public method. It is called when the CommandContainer is being executed. Returns: Type Description None The output of _detectRequirementFailure which is either an exception or None View Source def runRequirements ( self ) -> Optional [ Exception ] : \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks ) setRequirementsFailureCondition def setRequirementsFailureCondition ( self , requirementsFailureCondition : 'Any' ) -> 'None' This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. :param requirementsFailureCondition: :return: None View Source def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition","title":"Commandcontainers"},{"location":"reference/CommandContainers/#module-commandcontainers","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Ryan Henrichson, Timothy Nodine # Version: 1.1.0 # Description: This is an object that contains/wraps a single command or other CommandContainers too support multiple # commands. It is designed to be thread safe and has many helper functions designed to assist in working with commands # in a threaded/network environment. It is highly customizable allowing for both a simple single command or to be part # of a batch or queue. It also provides the ability for custom pre/post tasks which are functions to run specifically # when failures are detected and tasks to run when commands complete. # For more information review the README file found in the same directory as this. from __future__ import annotations import logging import re import traceback import time import uuid from collections import OrderedDict from threading import RLock , Event from functools import partial from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import SSHExceptionConn , RequirementsException , PreparserException , \\ ExecutionException , PostParserException , SetFailureException , CompletionTaskException , TimeoutException , \\ DataFormatException , ForceCompleteException , BetweenBitException , TimeToFirstBitException from PyMultiTasking import safe_acquire , safe_release , method_wait , MultiEvent , PriorityTaskQueue , Task from PyMultiTasking.ThreadingUtils import ThreadPool as Pool from LinuxModules import genericCmdModule from typing import Any , Optional , Union , Hashable , Iterable , List , Callable # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.INFO) log = logging . getLogger ( 'CommandContainers' ) # Regex's used to pull command tags. # ensure that data was returned matchRe = re . compile ( r '(?<=^CMDSTART).+' , flags = re . MULTILINE | re . DOTALL ) # clean up any errors or other data that may appear before the start tag startSubRe = re . compile ( r '.*?(?=^CMDSTART)' , flags = re . MULTILINE | re . DOTALL ) # clean up all data after the end tag endSubRe = re . compile ( r 'CMDEND.*' , flags = re . MULTILINE | re . DOTALL ) #Unparse the command string unParseCmd = re . compile ( r 'echo CMDSTART &&(.*)&& echo CMDEND' ) class CommandData ( object ): \"\"\" This is where all the data associated with the Command is located. \"\"\" _results : Any = None _lastResults : Any = None failure = None complete : bool = False running : bool = False parsed : bool = False noParsing : Union [ None , bool ] = None children : Any = None parent : Any = None events : list = None timeout : Union [ int , float ] = None __PRIORITY__ : int = 10 __OBJECTLOCK__ : RLock = None kwargs : dict = {} args : tuple = () EnvironmentObject : Optional [ EnvironmentControls ] = None _EnvironmentObjectBackup : Optional [ EnvironmentControls ] = None root : bool = None tki = None _tkiBackup = None _event : MultiEvent = None _completionEvent : Event = None _stopOnFailure : bool = None _timeoutExceptions : bool = None rawResults : str = None def __init__ ( self , timeout : Union [ int , float ] = 300 , root : bool = None , event : Optional [ MultiEvent ] = None , noParsing : Optional [ bool ] = None , stopOnFailure : Optional [ bool ] = None , timeoutExceptions : Optional [ Exception ] = None , * args , ** kwargs ): \"\"\" The bottom level parent. All other classes inherit this class down the chain. - :param timeout: This is the global timeout for encompassing all actions taken on or in this CommandObject. - :param root: This determines if root is required to run this command. - :param event: This provides a pre-existing event that will be set once the CommandObject is complete. - :param noParsing: do not parse results using the default methods - :param stopOnFailure: stop queue or unthreaded execution, or prevent completion tasks if an error occurs - :param timeoutExceptions: return an exception instead of None if something times out - :return: \"\"\" self . timeout = timeout or kwargs . get ( 'runTimeout' ) or kwargs . get ( 'wait' ) or 300 if type ( self . timeout ) not in ( int , float ): self . timeout = 300 self . __OBJECTLOCK__ = RLock () self . __LASTRESULTSLOCK__ = RLock () self . args = args self . kwargs = kwargs self . noParsing = noParsing is True self . _stopOnFailure = stopOnFailure is True self . _timeoutExceptions = timeoutExceptions is True if not self . tki : self . tki = self . _tkiBackup = kwargs . get ( 'tki' , {}) if root is None : root = getattr ( getattr ( self . tki , 'arguments' , None ), 'root' , False ) self . root = root self . children = [] self . parent = None if 'runTimeout' not in self . kwargs : self . kwargs [ 'runTimeout' ] = self . timeout self . _event = MultiEvent () self . _completionEvent = Event () self . _completionEvent . set () if event is None : event = Event () if self . events is None : self . events = [] self . addEvent ( event ) def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ): raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ): self . events . append ( event ) def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: { self } ' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: { self } : { child } ' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results ) # noinspection PyUnresolvedReferences def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: { self } ' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: { self } : { child } ' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki ) def _setEvents ( self ) -> None : \"\"\" This transverses the list of events known to this object and sets them. \"\"\" for item in self . events : item . set () @staticmethod def _isKwargs ( item : dict ) -> bool : \"\"\" This is a helper function for _parseCommand. It checks to see if the dictionary type object is a command or multiple commands. \"\"\" return 'command' in item @staticmethod def _hasKwargs ( item : dict ) -> list : \"\"\" This is a helper function for _parseCommand. It checks to see if the parent dictionary type object has custom functions. \"\"\" return [ c for c in [ 'requirements' , 'preparser' , 'postparser' , 'completiontask' ] if c in item ] @staticmethod def _needsKwargs ( item : dict ) -> bool : \"\"\" This is a helper function for _parseCommand. It checks to see if the parent dictionary type object needs updating to be suitable for use as kwargs. \"\"\" return CommandData . _hasKwargs ( item ) or ( not CommandData . _isKwargs ( item ) and len ( item ) - len ( CommandData . _hasKwargs ( item )) == 1 ) @staticmethod def _injectCommandKey ( item : dict , key : Hashable ) -> dict : \"\"\" This is a helper function for _processMultiItemIterable. It makes sure that commandKey is in kwargs because it is a requirement when creating a CommandObject. \"\"\" if 'commandKey' not in item : item [ 'commandKey' ] = key return item @staticmethod def _isQue ( item : Iterable ) -> bool : \"\"\" This is a helper function for _parseCommand. Determines if the iterable datatype is a queue or a batch. - :return: bool: True if queue, False if batch \"\"\" return isinstance ( item , ( OrderedDict , list , tuple )) @staticmethod def _createTags ( command : Optional [ Any ] = None , noParsing : bool = False , ignoreAlias : bool = False ) \\ -> Union [ DataFormatException , Union [ dict , str ]]: \"\"\" This is designed to add command tags to the beginning and end of a command. These tags help determine success and failure and also helps parse the output. The noParsing flag can stop this from being added. The idea here is that not all commands will run on bash. \"\"\" if noParsing : if type ( command ) is dict and len ( command ) > 0 : command = command . values () . pop () if isinstance ( command , str ): return command return DataFormatException ( f \"The command is not formatted correctly: { command } \" ) if isinstance ( command , dict ): for key , value in command . items (): if not re . search ( 'echo CMDSTART.*echo CMDEND' , value , flags = re . DOTALL | re . MULTILINE ): if ignoreAlias : value = \"command \" + value command [ key ] = re . sub ( r '(.+)' , r 'COLUMNS=200; export COLUMNS; echo CMDSTART && \\1 && echo CMDEND' , value , flags = re . DOTALL | re . MULTILINE ) if len ( command ) == 1 : return list ( command . values ()) . pop () return command if not isinstance ( command , str ): return '' if not re . search ( 'echo CMDSTART.*echo CMDEND' , command , flags = re . DOTALL | re . MULTILINE ): if ignoreAlias : command = \"command \" + command return re . sub ( r '(.+)' , r 'COLUMNS=200; export COLUMNS; echo CMDSTART && \\1 && echo CMDEND' , command , flags = re . DOTALL | re . MULTILINE ) return command @property def results ( self ): try : with self . __OBJECTLOCK__ : return self . _results except RuntimeError as e : log . error ( f 'ERROR: for results property: { e } ' ) log . debug ( f '[DEBUG] for results property: { traceback . format_exc () } ' ) @results . setter def results ( self , value ): try : with self . __OBJECTLOCK__ : self . _results = value self . _event . set () self . _setEvents () except RuntimeError as e : log . error ( f 'ERROR: for results.setter property: { e } ' ) log . debug ( f '[DEBUG] for results.setter property: { traceback . format_exc () } ' ) @results . deleter def results ( self ): try : with self . __OBJECTLOCK__ : self . _results = None except RuntimeError as e : log . error ( f 'ERROR: for results.deleter property: { e } ' ) log . debug ( f '[DEBUG] for results.deleter property: { traceback . format_exc () } ' ) @property def lastResults ( self ): try : with self . __LASTRESULTSLOCK__ : return self . _lastResults except RuntimeError as e : log . error ( f 'ERROR: for lastResults property: { e } ' ) log . debug ( f '[DEBUG] for lastResults property: { traceback . format_exc () } ' ) @lastResults . setter def lastResults ( self , value ): try : with self . __LASTRESULTSLOCK__ : self . _lastResults = value except RuntimeError as e : log . error ( f 'ERROR: for lastResults.sette property: { e } ' ) log . debug ( f '[DEBUG] for lastResults.sette property: { traceback . format_exc () } ' ) @lastResults . deleter def lastResults ( self ): try : with self . __LASTRESULTSLOCK__ : self . _lastResults = None except RuntimeError as e : log . error ( f 'ERROR: for lastResults.deleter property: { e } ' ) log . debug ( f '[DEBUG] for lastResults.deleter property: { traceback . format_exc () } ' ) class CommandParsers ( CommandData ): \"\"\" This is where all standard and custom parsing goes. \"\"\" _command : Any = None _commandKey : str = None customPostParser : bool = False def __init__ ( self , command : Any , commandKey : Union [ None , str ], ** kwargs ): \"\"\" Parse the command and the commandKey that identifies the container. - :param command: The datatype of command depends on the behavior of the CommandObject. If it is a string or a single length iterable, then the command becomes a string. - :param commandKey: The name of the command object. This object might be bound to a class if created through the 'simpleExecute' method. In that case, this is also the variable name that gets bound. This also helps determine its __hash__ and __str__. \"\"\" super ( CommandParsers , self ) . __init__ ( ** kwargs ) if isinstance ( command , dict ) and CommandData . _needsKwargs ( command ) and not commandKey : commandKey , command = self . _findCmdAndKey ( command ) self . commandKey = ( command , commandKey ) # print(f'command/type = {command} / {type(command)}') self . commandRaw = self . command = command @staticmethod def _findCmdAndKey ( command : dict ) -> tuple : for cmdKey , cmd in command . items (): if cmdKey not in [ 'requirements' , 'preparser' , 'postparser' , 'completiontask' , 'onFail' ]: return cmdKey , cmd @staticmethod def _parseCommandInput ( command : Optional [ Union [ str , dict ]] = None , commandKey : Optional [ str ] = None ) -> str : \"\"\" Used by simpleExecute. Use it to retrieve a command object by name after using simpleExecute. - :param command: This can either be a str or a single item dict - :param commandKey: - :return: A tuple. First item is the key and the second item is the value \"\"\" if not command and not commandKey : return CommandParsers . _parseCmdObjKey ( str ( uuid . uuid1 ())) if isinstance ( commandKey , str ) or isinstance ( command , str ): return CommandParsers . _parseCmdObjKey ( command , commandKey ) try : if commandKey is None : return CommandParsers . _parseCmdObjKey ( '' . join ( command )) except : pass return CommandParsers . _parseCmdObjKey ( str ( uuid . uuid1 ())) @staticmethod def _parseCmdObjKey ( cmd : Optional [ str ] = None , cmdKey : Optional [ str ] = None ) -> str : \"\"\" This static method is designed to parse the command key. The command key may be used as the name of this object if it is bound to another object. Namespaces have restrictions and cannot have certain characters. This static removes invalid characters. This is static so that it can be accessed outside of the class object allowing a programmer to use this anytime and ensure that the name is always the same. - :param cmd: The command variable from init - :param cmdKey: The commandkey variable from init - :return: str \"\"\" def _replaceStringHelper ( tmpStr ): return tmpStr . replace ( '/' , '' ) . replace ( '-' , '' ) . replace ( '.' , '' ) . replace ( ',' , '' ) . replace ( ';' , '' ) . \\ replace ( \"'\" , '' ) . replace ( '\"' , '' ) . replace ( ' ' , '' ) if not cmd and not cmdKey : return '' if not cmdKey : cmdKey = cmd elif ' %s ' in cmdKey and isinstance ( cmd , str ): return cmdKey % _replaceStringHelper ( cmd ) return _replaceStringHelper ( cmdKey ) @staticmethod def _parseCommand ( command : Any , noParsing : bool = False , ignoreAlias : bool = False ) -> Any : \"\"\" This is an designed to parse the command variable from init. It determines if the command is a single command or a queue or batch of commands. This is based on the command datatype and structure. \"\"\" # print(f'command/type: {command} / {type(command)}') if isinstance ( command , str ): return CommandData . _createTags ( command , noParsing , ignoreAlias ) if len ( command ) == 1 : return CommandParsers . _processSingleItemIterable ( command , noParsing , ignoreAlias ) if isinstance ( command , Iterable ): if CommandData . _isQue ( command ): return CommandParsers . _processMultiItemIterable ( command ) return set ( CommandParsers . _processMultiItemIterable ( command )) @staticmethod def _processSingleItemIterable ( command : Iterable , noParsing : bool , ignoreAlias : bool ) -> str : \"\"\" This is a helper function for '_parseCommand'. This is designed to handle an iterable that only has one command to run. The command is then run in this Object. \"\"\" if isinstance ( command , set ) or isinstance ( command , list ): command = command . pop () elif isinstance ( command , dict ): command = list ( command . values ()) . pop () elif isinstance ( command , tuple ): command = command [ 0 ] return CommandData . _createTags ( command , noParsing , ignoreAlias ) @staticmethod def _processMultiItemIterable ( command : Iterable ) -> Any : \"\"\" This is a helper function for '_parseCommand'. This is designed to handle an iterable that has multiple commands to run. It creates new CommandContainers for each 'command' that it iterates through. \"\"\" children = [] if isinstance ( command , dict ): for key , item in command . items (): if CommandData . _isKwargs ( item ): item = CommandData . _injectCommandKey ( item , key ) children . append ( CommandContainer ( ** item )) else : children . append ( CommandContainer ( item , key )) else : for item in command : if isinstance ( item , dict ) and CommandData . _isKwargs ( item ): children . append ( CommandContainer ( ** item )) else : children . append ( CommandContainer ( item , None )) return children @staticmethod def _singleCommandParser ( cmdResults : Union [ Any , str ]) -> str : \"\"\" This is used specifically by _parseResults but also in all simple parsing functions. Parses only the output of a single command from a string. \"\"\" if not isinstance ( cmdResults , str ): return cmdResults # compile these up front one time for better performance on repeated calls # all this parsing helps us handle custom prompts and other weirdness better # The 'replace' method is to solve oddiets with Ubuntu subsell returning '\\r\\n\\r' which breaks regex cmdOutputRe = matchRe . search ( startSubRe . sub ( '' , cmdResults . replace ( ' \\r\\n\\r ' , ' \\r\\n ' ), count = 1 )) if cmdOutputRe : output = endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ) . strip () if not output : return '' return output return '' @property def command ( self ): try : with self . __OBJECTLOCK__ : return self . _command except RuntimeError as e : log . error ( f 'ERROR: for command property: { e } ' ) log . debug ( f '[DEBUG] for command property: { traceback . format_exc () } ' ) @command . setter def command ( self , value ): \"\"\" This makes sure that command is parsed and calls _handleChildren() to take care of any children. \"\"\" try : with self . __OBJECTLOCK__ : output = self . _parseCommand ( value , self . noParsing , self . kwargs . get ( 'ignoreAlias' , False )) if type ( output ) is list or type ( output ) is set : self . _command = None self . children = output self . handleChildren ( tki = self . tki ) elif isinstance ( output , str ): self . _command = output except RuntimeError as e : log . error ( f 'ERROR: for command.setter property: { e } ' ) log . debug ( f '[DEBUG] for command.setter property: { traceback . format_exc () } ' ) @command . deleter def command ( self ): try : with self . __OBJECTLOCK__ : self . _command = None except RuntimeError as e : log . error ( f 'ERROR: for command.deleter property: { e } ' ) log . debug ( f '[DEBUG] for command.deleter property: { traceback . format_exc () } ' ) @property def commandUnparsed ( self ): command = self . command if '&&' in command and 'CMDSTART' in command : for cmd in unParseCmd . findall ( command ): return cmd return command @property def commandKey ( self ): return self . _commandKey @commandKey . setter def commandKey ( self , value ): \"\"\" This passes the value through _parseCommandInput() before applying the command key value. It requires that value be a tuple. :value: tuple \"\"\" self . _commandKey = self . _parseCommandInput ( * value ) class CommandRequirements ( CommandParsers ): \"\"\" This class handles the Requirements for a Command. It parses the provided requirements and the runRequirements method it has is called when the Requirement phase starts. Which is at the start of the execution. Requirements can either be a list, dict, or callable object. \"\"\" requirements : Any = None requirementTasks : list = None requirementFailureVar : dict = None requirementIncompleteVar : dict = None _requirementKeys : set = None _requirementResults : OrderedDict = None __REQUIREMENT_LOCK__ : RLock = None def __init__ ( self , command : Any , commandKey : Optional [ str ], requirements : Optional [ Any ] = None , ** kwargs ): \"\"\" This init's job is too setup the requirements and make sure that they are correctly formatted. :param command: passing thru to the next container :param commandKey: passing thru to the next container :param requirements: takes this which can either be list, dict, or callable :param kwargs: passed thru to the next container \"\"\" self . __REQUIREMENT_LOCK__ = RLock () super ( CommandRequirements , self ) . __init__ ( command , commandKey , ** kwargs ) if 'requirementsCondition' in kwargs : self . setRequirementsFailureCondition ( kwargs . pop ( 'requirementsCondition' )) self . requirementFailureVar = {} self . requirementIncompleteVar = {} self . _requirementKeys = set () if requirements is not None : self . requirements = requirements if self . requirements : self . _parseRequirements () def runRequirements ( self ) -> Optional [ Exception ]: \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks ) def _parseRequirements ( self ) -> Optional [ Exception ]: \"\"\" This is called by __init__ and its job is to setup the requirements and make it ready for execution. - :return: None. An exception is raised if there is an error. \"\"\" try : if not self . requirements : return None requirements = self . _parseRequirementsHelper ( self . requirements ) if type ( requirements ) is not list : requirements = [ requirements ] self . requirementTasks = requirements if len ( self . requirementTasks ) != len ( self . _requirementKeys ): raise RequirementsException ( f \"The func keys for requirements does not match the number of \" f \"requirementTasks \\n requirementKeys: \" f \" { self . _requirementKeys } \\n requirementTasks: { self . requirementTasks } \" ) self . requirementResults = OrderedDict ([]) except Exception as e : log . error ( f \"ERROR: Requirements setup failed: \\n { e } \\n \" ) log . debug ( f \"[DEBUG] for _parseRequirements: { traceback . format_exc () } \" ) raise e def _parseRequirementsHelper ( self , rawRequirements : Any ) -> Union [ List [ partial ], partial , Exception ]: \"\"\" This is the work horse of the __init__/_parseRequirements methods. This is a recursive method that attempts to parse requirements and turn them into callable partials for the _requirementRunner method to be used by the Pool. - :param rawRequirements: can either be a list, dict, or callable. - :return: This is either a partial a list of partials or an Exception \"\"\" if type ( rawRequirements ) is list : return [ self . _parseRequirementsHelper ( item ) for item in rawRequirements ] if callable ( rawRequirements ): self . _requirementKeys . add ( str ( rawRequirements )) if hasattr ( self , 'requirementsFailureCondition' ): self . requirementFailureVar . update ({ str ( rawRequirements ): self . requirementsFailureCondition }) return partial ( self . _requirementRunner , str ( rawRequirements ), rawRequirements , 0.1 , None , False ) if 'failureVar' in rawRequirements : self . requirementFailureVar . update ({ rawRequirements [ 'funcKey' ]: rawRequirements [ 'failureVar' ]}) elif hasattr ( self , 'requirementsFailureCondition' ): try : # dict of any length self . requirementFailureVar . update ( { rawRequirements . get ( 'funcKey' , rawRequirements . keys ()[ 0 ]): self . requirementsFailureCondition }) except : # callable object self . requirementFailureVar . update ({ str ( rawRequirements ): self . requirementsFailureCondition }) if isinstance ( rawRequirements , dict ): if len ( rawRequirements ) == 1 : funcKey = list ( rawRequirements . keys ())[ 0 ] self . _requirementKeys . add ( funcKey ) return partial ( self . _requirementRunner , funcKey , rawRequirements [ funcKey ], 0.1 , None , False ) if len ( rawRequirements ) > 1 : if 'funcKey' not in rawRequirements or 'func' not in rawRequirements : raise RequirementsException ( \"Invalid requirements format\" ) self . requirementIncompleteVar . update ( { rawRequirements [ 'funcKey' ]: rawRequirements . get ( 'incompleteVar' , None )}) self . _requirementKeys . add ( rawRequirements [ 'funcKey' ]) return partial ( self . _requirementRunner , ** rawRequirements ) raise RequirementsException ( \"Invalid requirements format\" ) def _requirementRunner ( self , funcKey : str , func : Callable , delay : float = 0.1 , incompleteVar : Any = None , raiseExc : bool = False , * args , ** kwargs ) -> None : \"\"\" Created by the _parseRequirementsHelper method and passed to the Pool for threading. This takes the results of methodWait from Pool and stores the output in requirementResults. - :param funcKey: This is used as the key associated with the output for requirementResults. - :param func: The callable that will be passed to methodWait. - :param delay: How long in between runs - :param incompleteVar: The variable used to determine if the 'func' being called has finished - :param raiseExc: Tells methodWait whether or not to raise or return an exception if an exception occurs - :param args: passed to methodWait and then to the 'func' - :param kwargs: passed to methodWait and then to the 'func'. However it may container failureVar which is pulled from kwargs and used as a control for methodWait. - :return: None \"\"\" kwargs . update ({ 'this' : self }) self . requirementResults . update ({ funcKey : method_wait ( func , timeout = self . timeout , delay = delay , incompleteVar = incompleteVar , raiseExc = raiseExc , * args , ** kwargs )}) def _detectRequirementFailure ( self , requirements : Any ) -> Optional [ Exception ]: \"\"\" This attempts to detect if there was a failure in the requirements. Checks to see if requirementResults exists. Then checks requirementResults for length against the original requirements. This can be different if an exception occurred and _requirementRunner did not update requirementResults. Lastly it checks all the results as follows: Results are an exception. Results are equal to incompleteVar (did not finish). Was failureVar provided and if do are results equal to it. All failures are collected into a single RequirementsException. - :param requirements: This is the requirementTasks which is a list of callables. - :return: None or Exception \"\"\" if not self . requirementResults : log . error ( \"ERROR: Requirements results are empty\" ) return RequirementsException ( \"Requirements results are empty\" ) if isinstance ( self . requirementResults , Exception ): log . error ( f \"An Exception occurred within the requirements: { self . requirementResults } \" ) return RequirementsException ( self . requirementResults ) if not isinstance ( self . requirementResults , dict ): log . error ( self . requirementResults ) return DataFormatException ( f \"The requirementsResults should be a dict but instead are \" f \" { type ( self . requirementResults ) } \" ) if self . requirementResults and len ( requirements ) != len ( self . requirementResults ): missingReq = set . difference ( self . _requirementKeys , set ( self . requirementResults . keys ())) log . error ( f \"ERROR: Missing requirements results after execution: { missingReq } \" ) return RequirementsException ( f \"Requirements did not complete: { missingReq } \" ) if self . requirementResults : failedReqs = [] for funcKey , results in self . requirementResults . items (): failureVar = self . requirementFailureVar . get ( funcKey , None ) incompleteVar = self . requirementIncompleteVar . get ( funcKey , None ) if isinstance ( results , Exception ) or \\ results is incompleteVar or \\ funcKey in self . requirementFailureVar and results is failureVar : failedReqs . append ( funcKey ) if failedReqs : return RequirementsException ( f \"Requirements failed: { ', ' . join ( failedReqs ) } \" ) def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition @property def requirementResults ( self ): \"\"\" Wraps requirementResults with a lock. \"\"\" try : with self . __REQUIREMENT_LOCK__ : return self . _requirementResults except RuntimeError as e : log . error ( f 'ERROR: for requirementResults property: { e } ' ) log . debug ( f '[DEBUG] for requirementResults property: { traceback . format_exc () } ' ) @requirementResults . setter def requirementResults ( self , value ): try : with self . __REQUIREMENT_LOCK__ : self . _requirementResults = value except RuntimeError as e : log . error ( f 'ERROR: for requirementResults.setter property: { e } ' ) log . debug ( f '[DEBUG] for requirementResults.setter property: { traceback . format_exc () } ' ) @requirementResults . deleter def requirementResults ( self ): try : with self . __REQUIREMENT_LOCK__ : self . _requirementResults = OrderedDict () except RuntimeError as e : log . error ( f 'ERROR: for requirementResults.deleter property: { e } ' ) log . debug ( f '[DEBUG] for requirementResults.deleter property: { traceback . format_exc () } ' ) # noinspection PyMethodMayBeStatic,PyUnusedLocal class CommandSetup ( CommandRequirements ): \"\"\" This is where the setup before running the command occurs. Requirements and the preparser are executed here. This also does the preliminary checking to ensure commands can be run. \"\"\" def __init__ ( self , command : Any , commandKey : Optional [ str ], preparser : Optional [ Callable ] = None , postparser : Optional [ Callable ] = None , onFail : Optional [ Callable ] = None , completiontask : Optional [ Callable ] = None , ** kwargs ): super ( CommandSetup , self ) . __init__ ( command , commandKey , ** kwargs ) if preparser is not None : self . _preparser = preparser if postparser is not None : self . _postparser = postparser self . customPostParser = True if onFail is not None : self . _onFailure = onFail if completiontask is not None : self . _completionEvent . clear () self . _onComplete = completiontask self . customPostParser = True def _preparser ( self , * args , ** kwargs ) -> Any : \"\"\" Placeholder for custom command preparser. All parsers MUST accept *args and **kwargs. Must return bool value or None (None means Failure). \"\"\" return True def _postparser ( self , results : Optional [ str ] = None , this : Optional [ Any ] = None , ** kwargs ) -> Any : \"\"\" Placeholder for custom command parser. All parsers MUST accept **kwargs. May be a single function or method or a list thereof. Must return results or None (None means Failure). \"\"\" return results def _onFailure ( self , results : Optional [ str ] = None , this : Optional [ Any ] = None , ** kwargs ) -> Any : \"\"\" Standard on fail method and a placeholder for a custom on fail method \"\"\" return results def _onComplete ( self , results : Optional [ str ] = None , this : Optional [ Any ] = None , ** kwargs ) -> Any : \"\"\" Placeholder for custom onComplete function. This is called by performComplete which is called by the exit magic function. :return: bool: True or False \"\"\" return results def runCommandSetup ( self , ** kwargs ) -> Optional [ Exception ]: \"\"\" Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface \"\"\" if ( self . EnvironmentObject is None and 'EnvironmentObject' not in kwargs ) and self . tki is None : log . error ( \"ERROR: ToolKitInterface and EnvironmentObject not found\" ) return ExecutionException ( 'ToolKitInterface and EnvironmentObject not found' ) self . _setup ( ** kwargs ) def _setup ( self , ** kwargs ) -> None : \"\"\" This checks to see if there are any requirements before this command can be executed. If there are, the requirements are executed in a batch using _requirementsRunner. \"\"\" self . EnvironmentObject = self . _EnvironmentObjectBackup = kwargs . get ( 'EnvironmentObject' ) if self . EnvironmentObject : self . EnvironmentObject . commandObject = self if self . root : self . EnvironmentObject . becomeRoot () if 'tki' in kwargs : self . tki = self . _tkiBackup = kwargs . get ( 'tki' ) self . handleChildren ( tki = self . tki ) def _preparserRunner ( self ): try : if type ( self . _preparser ) is list : preparResults = None for prepar in self . _preparser : preparResults = prepar ( this = self ) if self . failure or self . complete : break return preparResults return self . _preparser ( this = self ) except Exception as e : log . error ( f \"ERROR in _preparserRunner: { e } \" ) log . debug ( f \"[DEBUG] for _preparserRunner: { traceback . format_exc () } \" ) return PreparserException ( e , baseException = e ) class CommandContainer ( CommandSetup ): \"\"\" This is most of the logic/work is done. Note that this object is automatically created as an inherited class via CommandContainer below. Type checks are also automatically performed during execution that require this structure. This may be cleaned up at some point but there are no issues due to it so it is low priority. Just remember to use CommandContainer if manually creating CommandObjects. \"\"\" startTime : float = None endTime : float = None def __init__ ( self , * args , ** kwargs ): \"\"\" This class has nothing to do here. It is the work horse not the _setup(). Main user functions (aside from context manager): executor() waitForResults() forceComplete() resetContainers() Other public functions usually not directly accessed by a user: setLastResults() checkResults() (used by setLastResults()) setFailure() (called from setLastResults()) performComplete() finalizeExecution() Note that methods are clustered closest to other dependent methods to promote better reading flow. Statics and privates are mixed in with publics, but properties are always at the bottom and magics on top. \"\"\" log . info ( \"Setting up CommandContainer\" ) super ( CommandContainer , self ) . __init__ ( * args , ** kwargs ) self . startTime = None self . endTime = None def __hash__ ( self ): return hash ( self . commandKey ) def __enter__ ( self ): if safe_acquire ( self . __OBJECTLOCK__ , self . timeout ): self . _event . clear () self . running = True return self else : log . error ( f \"ERROR: CommandObject waitLock failed with timeout: { self . commandKey } : { self . timeout } \" ) log . debug ( f \"[DEBUG] for CommandOBject waitLock: { traceback . format_exc () } \" ) raise RuntimeError ( f \"CommandObject failed to obtain lock within the timeframe: \" f \" { self . commandKey } : { self . timeout } \" ) def __exit__ ( self , exc_type , exc_val , exc_tb ): safe_release ( self . __OBJECTLOCK__ ) self . _completionEvent . set () self . complete = True self . running = False log . debug ( f 'CommandObject completed: { self . commandKey } : { self . _command } ' ) def __str__ ( self ): return str ( self . commandKey ) def executor ( self , ** kwargs ) -> CommandContainer : \"\"\" This is the main function run in order to execute command(s). It requires that the EnvironmentObject and/or the tki variable be set. This is normally run after _setup() and is called from within _exeThread(). Steps: 1. Ensure the CommandObject is executable. 2. Requirements run and return None or an exception. 2. Preparser runs and returns whatever. 4. Execution of the command structure occurs and commands are executed and results returned. 5. Postparser runs using lastResults and returns the updated results. 6. Completion task runs using lastResults and returns nothing but can run setFailure() for stopOnFailure. 7. Finalization occurs moving lastResults to results and setting all remaining events. - :return: a copy of this container \"\"\" try : log . debug ( f \" ===== CommandObject executor running with command and children: \" f \" { self . commandKey } : { self . command } : { [ c . commandKey for c in self . children ] } ===== \" ) # Run requirements and preparser and abort if an exception is found self . startTime = time . time () if self . setLastResults ( self . runCommandSetup ( ** kwargs )): if self . setLastResults ( self . runRequirements (), phase = 'requirements' ): if self . setLastResults ( self . _preparserRunner (), phase = 'preparser' ): # Decision tree for which mode to execute in. Threaded/UnThreaded or unknown if self . EnvironmentObject is not None or self . children : self . setLastResults ( self . _executorThreadHelper (), phase = 'execution' ) elif self . EnvironmentObject is None : self . setLastResults ( self . _executorUnThreadedHelper (), phase = 'execution' ) else : # Y U NO SSH or whatever thing of error self . setLastResults ( self . _executorFailure ()) except Exception as e : # any unexpected exceptions could be anywhere in the process self . setLastResults ( self . _processException ( e )) finally : self . endTime = time . time () return self . finalizeExecution () def _executorThreadHelper ( self ) -> Union [ str , dict , Exception ]: \"\"\" Attempts to execute threaded commands in a batch or a queue, or a single threaded command. - :return: string for single command, dict for multiple commands, exception on error \"\"\" if self . command is not None : log . info ( f \"CommandObject has one threaded command: { self . commandKey } with kwargs: { self . kwargs } \" ) return self . EnvironmentObject . executeOnEnvironment ( cmd = self . command , ** self . kwargs ) if len ( self . children ) > 0 : log . info ( f \"CommandObject has threaded children: { self . commandKey } : { self . children } \" ) if type ( self . children ) is set : log . debug ( f 'CommandObject running batched children: { self . commandKey } : { self . children } ' ) return self . _executorHelper () if type ( self . children ) is list : log . debug ( f 'CommandObject running queued children: { self . commandKey } : { self . children } ' ) return self . _executorHelper ( _queue = True ) log . error ( f \"ERROR: CommandObject format of child data is invalid: { self . commandKey } : { self . children } \" ) return DataFormatException ( f 'CommandObject format of child data is invalid: ' f ' { self . commandKey } : { self . children } ' ) return self . _executorFailure () def _executorUnThreadedHelper ( self ) -> Union [ str , dict , Exception ]: \"\"\" Attempts to execute on the main ssh channel one command at a time. - :return: string for single command, dict for multiple commands, exception on error \"\"\" if self . command is not None : log . info ( f \"CommandObject has one unthreaded command: { self . commandKey } \" ) with self . tki . sshCon . mainEnvironment as env : return self . tki . sshCon . executeOnEnvironment ( env , self . command , ** self . kwargs ) if len ( self . children ) > 0 : log . info ( f \"CommandObject has unthreaded children: { self . commandKey } : { self . children } \" ) return self . _executorHelper ( threading = False ) return self . _executorFailure () def _executorHelper ( self , _queue : Optional [ Iterable ] = None , threading : bool = True ) -> Union [ dict , Exception ]: \"\"\" Designed to be a helper for _executorUnThreadedHelper() and _executorThreadHelper() for multiple commands. It is designed to help execute children. An unthreaded batch (unordered iterable data type only): stopOnFailure has no effect here and will be checked when waiting for results A threaded queue (ordered iterable data type, requires _timeout only): will return an exception if stopOnFailure is set, incomplete children will have required events set on containers to prevent hanging and waiting An unthreaded queue (_executorHelperhreading set to False, no _timeout): will return an exception if stopOnFailure is set, incomplete children will have required events set on containers to prevent hanging and waiting - :return: dict, exception on error if _stopOnFailure or _timeoutExceptions are true \"\"\" log . info ( f 'ExecutorHelper _queue = { _queue } and threading = { threading } ' ) if _queue : exHelperTimeout = sum ([ c . timeout for c in self . children ]) or self . timeout else : exHelperTimeout = max ([ c . timeout for c in self . children ]) or self . timeout _endTime = time . time () + exHelperTimeout log . debug ( f \"Looping through the childern with _endTime = { _endTime } \" ) for child in self . children : log . debug ( f \"Running child: { child . command } \" ) if 0 < _endTime <= time . time (): return TimeoutException ( f 'Batch execution timed out before child command: ' f ' { self . commandKey } : { child . commandKey } ' ) if _queue and ( 'EnvironmentObject' in self . kwargs and 'EnvironmentObject' not in child . kwargs ): child . kwargs [ 'EnvironmentObject' ] = self . kwargs [ 'EnvironmentObject' ] genericCmdModule . GenericCmdModule . simpleExecutor ( self , child , child . commandKey , tki = self . tki , threading = threading , ** child . kwargs ) if _queue or threading is False : # wait for each child in a queue child . waitForResults ( _endTime - time . time ()) # stopOnFailure only matters here if unthreaded or a queue to avoid waiting on each batch item if self . _stopOnFailure and child . failure : log . debug ( f \"Child command failed and stopped queue execution: { self . commandKey } : { child } \" ) return ExecutionException ( f 'Child command failed and stopped queue execution: ' f ' { self . commandKey } : { child } ' ) # wait for the batch to fully complete and always return the results for every scenario if self . children : return self . _waitForChildren ( wait = _endTime - time . time ()) def _executorFailure ( self ) -> Exception : \"\"\" Simply returns an exception when the executor encounters a (usually) internal issue. \"\"\" if self . command is None : log . error ( f \"CommandObject received no command or children: { str ( self ) } \" ) return ExecutionException ( f 'CommandObject received no command or children: { str ( self ) } ' ) log . error ( f \"Failed to determine execution mode for CommandObject: { self . commandKey } \" ) return ExecutionException ( f 'Failed to determine execution mode for CommandObject: { self . commandKey } ' ) def waitForResults ( self , wait : Optional [ Union [ float , int ]] = None ) -> Union [ str , dict , Exception ]: \"\"\" This is designed to wait until the command object is finished executing the command and parsing the results. - :param wait: use when the command object has children, defaults to the timeout attribute of the container \"\"\" if wait is None : wait = self . kwargs . get ( 'wait' , self . timeout ) or self . timeout if wait is True : wait = self . timeout if self . children : if self . _event . wait ( wait ) and self . _completionEvent . wait ( wait ): return self . results elif self . _event . wait ( wait ): return self . results if self . _timeoutExceptions : return TimeoutException ( f 'Command timed out waiting for results: { self . commandKey } ' ) def _waitForChildren ( self , wait : Optional [ Union [ float , int ]] = None ) -> Union [ str , dict , Exception ]: \"\"\" Private method to wait for just the children so the parent knows when to proceed \"\"\" if wait is None : wait = self . kwargs . get ( 'wait' , self . timeout ) or self . timeout if wait is True : wait = self . timeout if self . _event . wait ( wait ): return self . lastResults if self . _timeoutExceptions : return TimeoutException ( f 'Child commands timed out waiting for results: ' f ' { self . commandKey } : { self . children } ' ) def setLastResults ( self , results : Optional [ Any ] = None , resultsOrigin : Optional [ str ] = None , phase : Any = None , ** kwargs ) -> bool : \"\"\" This sets lastResults on the current object and tells the parent to do the same if a parent exists. - :param results: value used to set lastResults - :param resultsOrigin: name of the child command container if called by a child - :param phase: - :return: boolean value: True for success and False for failure found in the results \"\"\" if not self . checkResults ( results ): results = self . setFailure ( results , ** kwargs ) if resultsOrigin : try : self . lastResults . update ({ resultsOrigin : results }) except : self . lastResults = { resultsOrigin : results } else : self . lastResults = results if self . parent : self . parent . setLastResults ( results , self . commandKey ) if phase and self . startTime is not None and time . time () > self . startTime + self . timeout : log . debug ( f 'CommandObject timed out during phase: { self . commandKey } : { phase } ' ) raise TimeoutException ( f \"CommandObject timed out during phase: { self . commandKey } : { phase } \" ) if self . failure : return False return True def checkResults ( self , cmdData : Any = None ) -> bool : \"\"\" Check the cmdData (results) at any time to see if they are an exception. - :param cmdData: the results of the command at any point in the process \"\"\" if ( self . _stopOnFailure or not self . children ) and isinstance ( cmdData , Exception ): return False if self . children and not [ c for c in self . children if not c . failure ]: log . warning ( f 'All children failed: { self . commandKey } : { self . children } ' ) return False return True def setFailure ( self , results : Any = None , ** kwargs ) -> Any : \"\"\" The method is run if a failure was detected somewhere in the process. This process also kicks off the custom onFailure method. - :param results: results of the command or failure - :return: results of custom failure method or an exception \"\"\" try : log . warning ( f \"A failure occurred for Command: { str ( self . commandKey ) } \" ) log . debug ( f \"The raw failure results are: { results } \" ) return self . _onFailure ( results , this = self , ** kwargs ) except Exception as e : log . warning ( f 'Exception when setting failure for command: { str ( self . commandKey ) } ' ) log . debug ( f 'The raw failure results are: { results } ' ) return SetFailureException ( e , baseException = e ) finally : if not self . complete : self . forceComplete () self . failure = True def _parseResults ( self ) -> Any : \"\"\" This method is designed to do the reverse of the _createTags from CommandData except to the results of the command itself. It also calls the custom parser. - :return: the value of 'self.results' or Exception \"\"\" try : if self . parsed : return self . lastResults or self . results results = self . lastResults if not self . noParsing and not self . children : results = CommandContainer . _singleCommandParser ( results ) if not self . rawResults : self . rawResults = results if not self . customPostParser : return results if type ( self . _postparser ) is list : for pparser in self . _postparser : results = pparser ( results , this = self ) return results return self . _postparser ( results , this = self ) except Exception as e : log . error ( f 'Postparser exception: { self . commandKey } : { str ( self . _postparser ) } ' ) log . debug ( f 'Stack Trace: \\n { traceback . format_exc () } ' ) return PostParserException ( e , baseException = e ) finally : self . parsed = True def performComplete ( self ) -> Any : \"\"\" This is called by the __exit__ function and attempts to run a custom onComplete function. - :return: bool, results, or raises an exception on error \"\"\" try : if self . _completionEvent . is_set () or not self . customPostParser : return self . lastResults or self . results return self . _onComplete ( self . lastResults , this = self ) except Exception as e : log . error ( f 'Completion task exception: { self . commandKey } : { str ( self . _onComplete ) } ' ) log . debug ( f 'Stack Trace: \\n { traceback . format_exc () } ' ) return CompletionTaskException ( e , baseException = e ) def finalizeExecution ( self ) -> CommandContainer : \"\"\" This is the final wrap up step for the execution process and occurs only after the current object is done Moves lastResults to results and sets the event for the current object. Current event may be a shared multievent shared across parents and children. lastResults is then cleared. \"\"\" try : if self . _stopOnFailure : if not self . failure : if self . setLastResults ( self . _parseResults (), phase = 'finalizeOnFailure' ): self . performComplete () else : self . setLastResults ( self . _parseResults (), phase = 'finalize' ) self . performComplete () except Exception as e : self . setLastResults ( self . _processException ( e ), phase = 'finalizeOnException' ) finally : self . results = self . lastResults self . lastResults = None return self def _processException ( self , e : Exception ) -> Exception : \"\"\" General exception processor for errors during execution \"\"\" def _disconnectHelper (): try : log . debug ( \"Disconnecting SSH connection due to a failure\" ) if self . tki and not self . EnvironmentObject : self . tki . disconnect () if self . EnvironmentObject : self . EnvironmentObject . disconnectEnvironment () except Exception as secondaryException : log . debug ( f \"An unknown error occurred while attempting to disconnect: \" f \" { self . commandKey } . \\n Error: { secondaryException } \\n { traceback . format_exc () } \\n \" ) return secondaryException if not isinstance ( e , Exception ): return DataFormatException ( f \"The object provided is not an exception: { str ( e ) } \" ) objectType = type ( e ) if objectType == SSHExceptionConn : log . error ( f 'CONNECTION ERROR: { e } \\n { traceback . format_exc () } ' ) log . debug ( 'This usually occurs when the SSH connection is prematurely severed.' ) log . debug ( f 'The preRunner failed for CommandObject with preparser and requirements: ' f ' { self . commandKey } : { str ( self . _preparser ) } : { str ( self . requirements ) } ' ) e = _disconnectHelper () elif objectType == TimeToFirstBitException or objectType == BetweenBitException : log . error ( f \"Error receiving data from buffer after command was sent. \" f \" \\n Error: { e } \\n { traceback . format_exc () } \\n \" ) log . debug ( f 'The preRunner failed for CommandObject with preparser and requirements: ' f ' { self . commandKey } : { str ( self . _preparser ) } : { str ( self . requirements ) } ' ) e = _disconnectHelper () elif objectType == RuntimeError : log . error ( f 'A runtime error occurred when attempting to gain the lock on an object \\n ' f 'The commandKey is: { self . commandKey } \\n The preparser is: { str ( self . _preparser ) } ' f ' \\n The requirements are: { str ( self . requirements ) } ' ) log . debug ( f \"An error occurred trying to gain the lock of the Object: \" f \" { self . commandKey } . \\n Error: { e } \\n { traceback . format_exc () } \\n \" ) else : log . error ( f 'Error occurred: { objectType } \\n The commandKey is: { self . commandKey } \\n ' f 'The preparser is: { str ( self . _preparser ) } \\n The requirements are: { str ( self . requirements ) } ' ) log . debug ( f \"Error occurred: { self . commandKey } . \\n Error: { e } \\n { traceback . format_exc () } \\n \" ) return e @property def executionLength ( self ): try : if self . startTime and self . endTime : return round ( self . endTime - self . startTime , 10 ) except Exception : return 0.0","title":"Module CommandContainers"},{"location":"reference/CommandContainers/#variables","text":"endSubRe log matchRe startSubRe unParseCmd","title":"Variables"},{"location":"reference/CommandContainers/#classes","text":"","title":"Classes"},{"location":"reference/CommandContainers/#commandcontainer","text":"class CommandContainer ( * args , ** kwargs ) This is most of the logic/work is done. Note that this object is automatically created as an inherited class via CommandContainer below. Type checks are also automatically performed during execution that require this structure. This may be cleaned up at some point but there are no issues due to it so it is low priority. Just remember to use CommandContainer if manually creating CommandObjects.","title":"CommandContainer"},{"location":"reference/CommandContainers/#ancestors-in-mro","text":"CommandContainers.CommandSetup CommandContainers.CommandRequirements CommandContainers.CommandParsers CommandContainers.CommandData","title":"Ancestors (in MRO)"},{"location":"reference/CommandContainers/#class-variables","text":"EnvironmentObject args children complete customPostParser endTime events failure kwargs noParsing parent parsed rawResults requirementFailureVar requirementIncompleteVar requirementTasks requirements root running startTime timeout tki","title":"Class variables"},{"location":"reference/CommandContainers/#instance-variables","text":"command commandKey commandUnparsed executionLength lastResults requirementResults Wraps requirementResults with a lock. results","title":"Instance variables"},{"location":"reference/CommandContainers/#methods","text":"","title":"Methods"},{"location":"reference/CommandContainers/#addevent","text":"def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event )","title":"addEvent"},{"location":"reference/CommandContainers/#checkresults","text":"def checkResults ( self , cmdData : 'Any' = None ) -> 'bool' Check the cmdData (results) at any time to see if they are an exception. :param cmdData: the results of the command at any point in the process View Source def checkResults ( self , cmdData : Any = None ) -> bool : \"\"\" Check the cmdData (results) at any time to see if they are an exception. - :param cmdData: the results of the command at any point in the process \"\"\" if ( self . _stopOnFailure or not self . children ) and isinstance ( cmdData , Exception ) : return False if self . children and not [ c for c in self . children if not c . failure ] : log . warning ( f 'All children failed: {self.commandKey} : {self.children}' ) return False return True","title":"checkResults"},{"location":"reference/CommandContainers/#executor","text":"def executor ( self , ** kwargs ) -> 'CommandContainer' This is the main function run in order to execute command(s). It requires that the EnvironmentObject and/or the tki variable be set. This is normally run after _setup() and is called from within _exeThread(). Steps: 1. Ensure the CommandObject is executable. 2. Requirements run and return None or an exception. 2. Preparser runs and returns whatever. 4. Execution of the command structure occurs and commands are executed and results returned. 5. Postparser runs using lastResults and returns the updated results. 6. Completion task runs using lastResults and returns nothing but can run setFailure() for stopOnFailure. 7. Finalization occurs moving lastResults to results and setting all remaining events. :return: a copy of this container View Source def executor ( self , ** kwargs ) -> CommandContainer : \"\"\" This is the main function run in order to execute command(s). It requires that the EnvironmentObject and/or the tki variable be set. This is normally run after _setup() and is called from within _exeThread(). Steps: 1. Ensure the CommandObject is executable. 2. Requirements run and return None or an exception. 2. Preparser runs and returns whatever. 4. Execution of the command structure occurs and commands are executed and results returned. 5. Postparser runs using lastResults and returns the updated results. 6. Completion task runs using lastResults and returns nothing but can run setFailure() for stopOnFailure. 7. Finalization occurs moving lastResults to results and setting all remaining events. - :return: a copy of this container \"\"\" try : log . debug ( f \" ===== CommandObject executor running with command and children: \" f \"{self.commandKey} : {self.command} : {[c.commandKey for c in self.children]} ===== \" ) # Run requirements and preparser and abort if an exception is found self . startTime = time . time () if self . setLastResults ( self . runCommandSetup ( ** kwargs )): if self . setLastResults ( self . runRequirements (), phase = 'requirements' ): if self . setLastResults ( self . _preparserRunner (), phase = 'preparser' ): # Decision tree for which mode to execute in. Threaded/UnThreaded or unknown if self . EnvironmentObject is not None or self . children : self . setLastResults ( self . _executorThreadHelper (), phase = 'execution' ) elif self . EnvironmentObject is None : self . setLastResults ( self . _executorUnThreadedHelper (), phase = 'execution' ) else : # Y U NO SSH or whatever thing of error self . setLastResults ( self . _executorFailure ()) except Exception as e : # any unexpected exceptions could be anywhere in the process self . setLastResults ( self . _processException ( e )) finally : self . endTime = time . time () return self . finalizeExecution ()","title":"executor"},{"location":"reference/CommandContainers/#finalizeexecution","text":"def finalizeExecution ( self ) -> 'CommandContainer' This is the final wrap up step for the execution process and occurs only after the current object is done Moves lastResults to results and sets the event for the current object. Current event may be a shared multievent shared across parents and children. lastResults is then cleared. View Source def finalizeExecution ( self ) -> CommandContainer : \"\"\" This is the final wrap up step for the execution process and occurs only after the current object is done Moves lastResults to results and sets the event for the current object. Current event may be a shared multievent shared across parents and children. lastResults is then cleared. \"\"\" try : if self . _stopOnFailure : if not self . failure : if self . setLastResults ( self . _parseResults (), phase = 'finalizeOnFailure' ) : self . performComplete () else : self . setLastResults ( self . _parseResults (), phase = 'finalize' ) self . performComplete () except Exception as e : self . setLastResults ( self . _processException ( e ), phase = 'finalizeOnException' ) finally : self . results = self . lastResults self . lastResults = None return self","title":"finalizeExecution"},{"location":"reference/CommandContainers/#forcecomplete","text":"def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results )","title":"forceComplete"},{"location":"reference/CommandContainers/#handlechildren","text":"def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki )","title":"handleChildren"},{"location":"reference/CommandContainers/#hasevent","text":"def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False","title":"hasEvent"},{"location":"reference/CommandContainers/#performcomplete","text":"def performComplete ( self ) -> 'Any' This is called by the exit function and attempts to run a custom onComplete function. :return: bool, results, or raises an exception on error View Source def performComplete ( self ) -> Any : \"\"\" This is called by the __exit__ function and attempts to run a custom onComplete function. - :return: bool, results, or raises an exception on error \"\"\" try : if self . _completionEvent . is_set () or not self . customPostParser : return self . lastResults or self . results return self . _onComplete ( self . lastResults , this = self ) except Exception as e : log . error ( f 'Completion task exception: {self.commandKey} : {str(self._onComplete)}' ) log . debug ( f 'Stack Trace:\\n {traceback.format_exc()}' ) return CompletionTaskException ( e , baseException = e )","title":"performComplete"},{"location":"reference/CommandContainers/#resetcontainers","text":"def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass","title":"resetContainers"},{"location":"reference/CommandContainers/#runcommandsetup","text":"def runCommandSetup ( self , ** kwargs ) -> 'Optional[Exception]' Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface View Source def runCommandSetup ( self , ** kwargs ) -> Optional [ Exception ] : \"\"\" Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface \"\"\" if ( self . EnvironmentObject is None and 'EnvironmentObject' not in kwargs ) and self . tki is None : log . error ( \"ERROR: ToolKitInterface and EnvironmentObject not found\" ) return ExecutionException ( 'ToolKitInterface and EnvironmentObject not found' ) self . _setup ( ** kwargs )","title":"runCommandSetup"},{"location":"reference/CommandContainers/#runrequirements","text":"def runRequirements ( self ) -> 'Optional[Exception]' This is the only public method. It is called when the CommandContainer is being executed. Returns: Type Description None The output of _detectRequirementFailure which is either an exception or None View Source def runRequirements ( self ) -> Optional [ Exception ] : \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks )","title":"runRequirements"},{"location":"reference/CommandContainers/#setfailure","text":"def setFailure ( self , results : 'Any' = None , ** kwargs ) -> 'Any' The method is run if a failure was detected somewhere in the process. This process also kicks off the custom onFailure method. :param results: results of the command or failure :return: results of custom failure method or an exception View Source def setFailure(self, results: Any = None, **kwargs) -> Any: \"\"\" The method is run if a failure was detected somewhere in the process. This process also kicks off the custom onFailure method. - :param results: results of the command or failure - :return: results of custom failure method or an exception \"\"\" try: log.warning(f\"A failure occurred for Command: {str(self.commandKey)}\") log.debug(f\"The raw failure results are: {results}\") return self._onFailure(results, this=self, **kwargs) except Exception as e: log.warning(f'Exception when setting failure for command: {str(self.commandKey)}') log.debug(f'The raw failure results are: {results}') return SetFailureException(e, baseException=e) finally: if not self.complete: self.forceComplete() self.failure = True","title":"setFailure"},{"location":"reference/CommandContainers/#setlastresults","text":"def setLastResults ( self , results : 'Optional[Any]' = None , resultsOrigin : 'Optional[str]' = None , phase : 'Any' = None , ** kwargs ) -> 'bool' This sets lastResults on the current object and tells the parent to do the same if a parent exists. :param results: value used to set lastResults :param resultsOrigin: name of the child command container if called by a child :param phase: :return: boolean value: True for success and False for failure found in the results View Source def setLastResults ( self , results : Optional [ Any ] = None , resultsOrigin : Optional [ str ] = None , phase : Any = None , ** kwargs ) -> bool : \"\"\" This sets lastResults on the current object and tells the parent to do the same if a parent exists. - :param results: value used to set lastResults - :param resultsOrigin: name of the child command container if called by a child - :param phase: - :return: boolean value: True for success and False for failure found in the results \"\"\" if not self . checkResults ( results ) : results = self . setFailure ( results , ** kwargs ) if resultsOrigin : try : self . lastResults . update ( { resultsOrigin : results } ) except : self . lastResults = { resultsOrigin : results } else : self . lastResults = results if self . parent : self . parent . setLastResults ( results , self . commandKey ) if phase and self . startTime is not None and time . time () > self . startTime + self . timeout : log . debug ( f 'CommandObject timed out during phase: {self.commandKey} : {phase}' ) raise TimeoutException ( f \"CommandObject timed out during phase: {self.commandKey} : {phase}\" ) if self . failure : return False return True","title":"setLastResults"},{"location":"reference/CommandContainers/#setrequirementsfailurecondition","text":"def setRequirementsFailureCondition ( self , requirementsFailureCondition : 'Any' ) -> 'None' This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. :param requirementsFailureCondition: :return: None View Source def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition","title":"setRequirementsFailureCondition"},{"location":"reference/CommandContainers/#waitforresults","text":"def waitForResults ( self , wait : 'Optional[Union[float, int]]' = None ) -> 'Union[str, dict, Exception]' This is designed to wait until the command object is finished executing the command and parsing the results. :param wait: use when the command object has children, defaults to the timeout attribute of the container View Source def waitForResults ( self , wait : Optional [ Union [ float , int ]] = None ) -> Union [ str , dict , Exception ] : \"\"\" This is designed to wait until the command object is finished executing the command and parsing the results. - :param wait: use when the command object has children, defaults to the timeout attribute of the container \"\"\" if wait is None : wait = self . kwargs . get ( 'wait' , self . timeout ) or self . timeout if wait is True : wait = self . timeout if self . children : if self . _event . wait ( wait ) and self . _completionEvent . wait ( wait ) : return self . results elif self . _event . wait ( wait ) : return self . results if self . _timeoutExceptions : return TimeoutException ( f 'Command timed out waiting for results: {self.commandKey}' )","title":"waitForResults"},{"location":"reference/CommandContainers/#commanddata","text":"class CommandData ( timeout : 'Union[int, float]' = 300 , root : 'bool' = None , event : 'Optional[MultiEvent]' = None , noParsing : 'Optional[bool]' = None , stopOnFailure : 'Optional[bool]' = None , timeoutExceptions : 'Optional[Exception]' = None , * args , ** kwargs ) This is where all the data associated with the Command is located.","title":"CommandData"},{"location":"reference/CommandContainers/#descendants","text":"CommandContainers.CommandParsers","title":"Descendants"},{"location":"reference/CommandContainers/#class-variables_1","text":"EnvironmentObject args children complete events failure kwargs noParsing parent parsed rawResults root running timeout tki","title":"Class variables"},{"location":"reference/CommandContainers/#instance-variables_1","text":"lastResults results","title":"Instance variables"},{"location":"reference/CommandContainers/#methods_1","text":"","title":"Methods"},{"location":"reference/CommandContainers/#addevent_1","text":"def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event )","title":"addEvent"},{"location":"reference/CommandContainers/#forcecomplete_1","text":"def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results )","title":"forceComplete"},{"location":"reference/CommandContainers/#handlechildren_1","text":"def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki )","title":"handleChildren"},{"location":"reference/CommandContainers/#hasevent_1","text":"def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False","title":"hasEvent"},{"location":"reference/CommandContainers/#resetcontainers_1","text":"def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass","title":"resetContainers"},{"location":"reference/CommandContainers/#commandparsers","text":"class CommandParsers ( command : 'Any' , commandKey : 'Union[None, str]' , ** kwargs ) This is where all standard and custom parsing goes.","title":"CommandParsers"},{"location":"reference/CommandContainers/#ancestors-in-mro_1","text":"CommandContainers.CommandData","title":"Ancestors (in MRO)"},{"location":"reference/CommandContainers/#descendants_1","text":"CommandContainers.CommandRequirements","title":"Descendants"},{"location":"reference/CommandContainers/#class-variables_2","text":"EnvironmentObject args children complete customPostParser events failure kwargs noParsing parent parsed rawResults root running timeout tki","title":"Class variables"},{"location":"reference/CommandContainers/#instance-variables_2","text":"command commandKey commandUnparsed lastResults results","title":"Instance variables"},{"location":"reference/CommandContainers/#methods_2","text":"","title":"Methods"},{"location":"reference/CommandContainers/#addevent_2","text":"def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event )","title":"addEvent"},{"location":"reference/CommandContainers/#forcecomplete_2","text":"def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results )","title":"forceComplete"},{"location":"reference/CommandContainers/#handlechildren_2","text":"def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki )","title":"handleChildren"},{"location":"reference/CommandContainers/#hasevent_2","text":"def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False","title":"hasEvent"},{"location":"reference/CommandContainers/#resetcontainers_2","text":"def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass","title":"resetContainers"},{"location":"reference/CommandContainers/#commandrequirements","text":"class CommandRequirements ( command : 'Any' , commandKey : 'Optional[str]' , requirements : 'Optional[Any]' = None , ** kwargs ) This class handles the Requirements for a Command. It parses the provided requirements and the runRequirements method it has is called when the Requirement phase starts. Which is at the start of the execution. Requirements can either be a list, dict, or callable object.","title":"CommandRequirements"},{"location":"reference/CommandContainers/#ancestors-in-mro_2","text":"CommandContainers.CommandParsers CommandContainers.CommandData","title":"Ancestors (in MRO)"},{"location":"reference/CommandContainers/#descendants_2","text":"CommandContainers.CommandSetup","title":"Descendants"},{"location":"reference/CommandContainers/#class-variables_3","text":"EnvironmentObject args children complete customPostParser events failure kwargs noParsing parent parsed rawResults requirementFailureVar requirementIncompleteVar requirementTasks requirements root running timeout tki","title":"Class variables"},{"location":"reference/CommandContainers/#instance-variables_3","text":"command commandKey commandUnparsed lastResults requirementResults Wraps requirementResults with a lock. results","title":"Instance variables"},{"location":"reference/CommandContainers/#methods_3","text":"","title":"Methods"},{"location":"reference/CommandContainers/#addevent_3","text":"def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event )","title":"addEvent"},{"location":"reference/CommandContainers/#forcecomplete_3","text":"def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results )","title":"forceComplete"},{"location":"reference/CommandContainers/#handlechildren_3","text":"def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki )","title":"handleChildren"},{"location":"reference/CommandContainers/#hasevent_3","text":"def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False","title":"hasEvent"},{"location":"reference/CommandContainers/#resetcontainers_3","text":"def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass","title":"resetContainers"},{"location":"reference/CommandContainers/#runrequirements_1","text":"def runRequirements ( self ) -> 'Optional[Exception]' This is the only public method. It is called when the CommandContainer is being executed. Returns: Type Description None The output of _detectRequirementFailure which is either an exception or None View Source def runRequirements ( self ) -> Optional [ Exception ] : \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks )","title":"runRequirements"},{"location":"reference/CommandContainers/#setrequirementsfailurecondition_1","text":"def setRequirementsFailureCondition ( self , requirementsFailureCondition : 'Any' ) -> 'None' This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. :param requirementsFailureCondition: :return: None View Source def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition","title":"setRequirementsFailureCondition"},{"location":"reference/CommandContainers/#commandsetup","text":"class CommandSetup ( command : 'Any' , commandKey : 'Optional[str]' , preparser : 'Optional[Callable]' = None , postparser : 'Optional[Callable]' = None , onFail : 'Optional[Callable]' = None , completiontask : 'Optional[Callable]' = None , ** kwargs ) This is where the setup before running the command occurs. Requirements and the preparser are executed here. This also does the preliminary checking to ensure commands can be run.","title":"CommandSetup"},{"location":"reference/CommandContainers/#ancestors-in-mro_3","text":"CommandContainers.CommandRequirements CommandContainers.CommandParsers CommandContainers.CommandData","title":"Ancestors (in MRO)"},{"location":"reference/CommandContainers/#descendants_3","text":"CommandContainers.CommandContainer","title":"Descendants"},{"location":"reference/CommandContainers/#class-variables_4","text":"EnvironmentObject args children complete customPostParser events failure kwargs noParsing parent parsed rawResults requirementFailureVar requirementIncompleteVar requirementTasks requirements root running timeout tki","title":"Class variables"},{"location":"reference/CommandContainers/#instance-variables_4","text":"command commandKey commandUnparsed lastResults requirementResults Wraps requirementResults with a lock. results","title":"Instance variables"},{"location":"reference/CommandContainers/#methods_4","text":"","title":"Methods"},{"location":"reference/CommandContainers/#addevent_4","text":"def addEvent ( self , event : 'MultiEvent' ) -> 'None' This will add a new event if it does not already have it. :param event: (MultiEvent) View Source def addEvent ( self , event : MultiEvent ) -> None : \"\"\" This will add a new event if it does not already have it. - :param event: (MultiEvent) \"\"\" if not isinstance ( event , Event ) : raise TypeError ( 'event parement is not an Event' ) if not self . hasEvent ( event ) : self . events . append ( event )","title":"addEvent"},{"location":"reference/CommandContainers/#forcecomplete_4","text":"def forceComplete ( self , results : 'Optional[Any]' = None ) -> 'ForceCompleteException' Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. View Source def forceComplete ( self , results : Optional [ Any ] = None ) -> ForceCompleteException : \"\"\" Force completion for the parent container and all children without changing the results. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Forcing completion for command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent forcing completion of child: {self} : {child}' ) child . forceComplete ( results ) self . _completionEvent . set () self . _event . set () self . _setEvents () self . failure = True self . parsed = True self . running = False self . complete = True self . _tkiBackup = self . tki self . tki = None self . _EnvironmentObjectBackup = self . EnvironmentObject self . EnvironmentObject = None return ForceCompleteException ( results , baseException = results )","title":"forceComplete"},{"location":"reference/CommandContainers/#handlechildren_4","text":"def handleChildren ( self , tki : 'Optional[Any]' = None ) -> 'None' This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. View Source def handleChildren ( self , tki : Optional [ Any ] = None ) -> None : \"\"\" This function is called once the CommandObject is done setting up children if it has any. It makes sure the children are aware of it as the parent and of tki of the parent. \"\"\" if not self . children : return self . _event = MultiEvent ( len ( self . children )) for child in self . children : child . addEvent ( self . _event ) child . parent = self if tki : child . tki = tki child . handleChildren ( tki = tki or self . tki )","title":"handleChildren"},{"location":"reference/CommandContainers/#hasevent_4","text":"def hasEvent ( self , event : 'MultiEvent' ) -> 'bool' This checks to see if the specified event exists or not. This is mainly used by 'addEvent' method. :param event: :return: bool View Source def hasEvent ( self , event : MultiEvent ) -> bool : \"\"\" This checks to see if the specified event exists or not. This is mainly used by ' addEvent ' method. - :param event: - :return: bool \"\"\" if self . events and event in self . events : return True return False","title":"hasEvent"},{"location":"reference/CommandContainers/#resetcontainers_4","text":"def resetContainers ( self ) -> 'None' Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. View Source def resetContainers ( self ) -> None : \"\"\" Reset the command containers to a usable state wth all previous settings. Utility method to be used on a fully initialized command container. \"\"\" log . info ( f 'Resetting command object: {self}' ) if self . children : for child in self . children : log . info ( f 'Parent resetting child: {self} : {child}' ) child . resetContainers () self . _completionEvent . clear () self . _event . clear () self . results = None self . failure = None self . parsed = False self . running = False self . complete = False self . tki = self . _tkiBackup self . EnvironmentObject = self . _EnvironmentObjectBackup try : self . setRequirementsFailureCondition ( self . requirementsFailureCondition ) except : pass","title":"resetContainers"},{"location":"reference/CommandContainers/#runcommandsetup_1","text":"def runCommandSetup ( self , ** kwargs ) -> 'Optional[Exception]' Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface View Source def runCommandSetup ( self , ** kwargs ) -> Optional [ Exception ] : \"\"\" Checks to make sure it is possible to run a command either via a EnvironmentObject or the ToolKitInterface \"\"\" if ( self . EnvironmentObject is None and 'EnvironmentObject' not in kwargs ) and self . tki is None : log . error ( \"ERROR: ToolKitInterface and EnvironmentObject not found\" ) return ExecutionException ( 'ToolKitInterface and EnvironmentObject not found' ) self . _setup ( ** kwargs )","title":"runCommandSetup"},{"location":"reference/CommandContainers/#runrequirements_2","text":"def runRequirements ( self ) -> 'Optional[Exception]' This is the only public method. It is called when the CommandContainer is being executed. Returns: Type Description None The output of _detectRequirementFailure which is either an exception or None View Source def runRequirements ( self ) -> Optional [ Exception ] : \"\"\" This is the only public method. It is called when the CommandContainer is being executed. :return: The output of _detectRequirementFailure which is either an exception or None \"\"\" if self . requirements : reqTasks = PriorityTaskQueue () for req in self . requirementTasks : reqTasks . put ( Task ( req )) Pool ( tasks = reqTasks , daemon = False , timeout = self . timeout ) return self . _detectRequirementFailure ( self . requirementTasks )","title":"runRequirements"},{"location":"reference/CommandContainers/#setrequirementsfailurecondition_2","text":"def setRequirementsFailureCondition ( self , requirementsFailureCondition : 'Any' ) -> 'None' This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. :param requirementsFailureCondition: :return: None View Source def setRequirementsFailureCondition ( self , requirementsFailureCondition : Any ) -> None : \"\"\" This will be checked against the results of the requirements to determine if a failure occurred. This MUST be set before running the command and executing the command object. To allow a default failure condition in addition to an exception to define requirements success or failure and allow None to be a valid success criteria, the attribute requirementsFailureCondition will not exist and the absence of the attribute will prevent anything other than an exception from being used. However, the current default value is None to allow for backward compatibility. - :param requirementsFailureCondition: - :return: None \"\"\" self . requirementsFailureCondition = requirementsFailureCondition","title":"setRequirementsFailureCondition"},{"location":"reference/SCPChannel/","text":"Module SCPChannel View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson # Version: 0.2 # Date: 10/05/17 # Description: This uses the LDTKscp.py third party module in combination with our Paramiko implementation to # preform scp style file uploads. import logging from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import exceptionDecorator as expDec from sshConnector.sshLibs.LDTKscp import SCPClient from paramiko import SSHClient from typing import Any , Optional , AnyStr # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.DEBUG) log = logging . getLogger ( 'SCP Client' ) def put ( ssh , files : Any , remotepath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'put' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: { files } - to the remote path of: [ { remotepath } ]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . put ( files , remotepath , recursive , preserve_times ) def get ( ssh , remotefile : AnyStr , localpath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'get' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to get the following file: { remotefile } - and saving it to: [ { localpath } ]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . get ( remotefile , localpath , recursive , preserve_times ) class SCPChannel ( object ): \"\"\" This is a wrapper for the two methods in the SCPClient class from the LDTKscp.py package. It is designed to be LDTK aware and to handle getting the correct SSH channel. While the package functions 'put' and 'get' wrap the third party SCPClient package. \"\"\" ldtk = None ssh : SSHClient = None scp : SCPClient = None def __init__ ( self , ldtk ): \"\"\" This requires the LDTK and uses it to get the main SSH channel by default. Or it uses a provided SSHChannel. - :param ldtk: A ToolKitInterface object. Used by the 'property' sshCon to pull the main SSH channel. \"\"\" self . ldtk = ldtk self . ssh = ldtk . sshCon . ssh def __enter__ ( self ): self . openSCP () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . closeSCP () def openSCP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SCPClient : if self . scp is not None and not reopen : return self . scp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . scp = SCPClient ( self . ssh . get_transport ()) return self . scp def closeSCP ( self ) -> None : if self . scp : self . scp . close () del self . scp @expDec ( returnOnExcept = False ) def put ( self , files : Any , remotepath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Take a local file or multiple files and upload it to a remote location. If files parameter is an IO object the remotepath must be a full name and not a directory. - :param files: single or list of files to upload - :param remotepath: a full path to a remote directory or filename. (If files is IO then this MUST be fullpath filename.) - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ) . put ( files , remotepath ) @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localpath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefile: A full path to a file located on a remote machine - :param localpath: A full path to a local directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ) . get ( remotefile , localpath ) Variables log Functions get def get ( ssh , remotefile : ~ AnyStr , localpath : ~ AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None This uses the 'get' method within the SCPClient class found in the LDTKscp.py package. :param ssh: (Paramiko ssh object) :param remotefile: (AnyStr) :param localpath: (AnyStr) :param recursive: transfer files and directories recursively :param preserve_times: preserve mtime and atime of transferred files and directories :return: None View Source def get ( ssh , remotefile : AnyStr , localpath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'get' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to get the following file: {remotefile} - and saving it to: [{localpath}]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . get ( remotefile , localpath , recursive , preserve_times ) put def put ( ssh , files : Any , remotepath : ~ AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None This uses the 'put' method within the SCPClient class found in the LDTKscp.py package. :param ssh: (Paramiko ssh object) :param files: (AnyStr/File/IO Object) :param remotepath: (AnyStr) :param recursive: transfer files and directories recursively :param preserve_times: preserve mtime and atime of transferred files and directories :return: None View Source def put ( ssh , files : Any , remotepath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'put' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: {files} - to the remote path of: [{remotepath}]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . put ( files , remotepath , recursive , preserve_times ) Classes SCPChannel class SCPChannel ( ldtk ) This is a wrapper for the two methods in the SCPClient class from the LDTKscp.py package. It is designed to be LDTK aware and to handle getting the correct SSH channel. While the package functions 'put' and 'get' wrap the third party SCPClient package. Class variables ldtk scp ssh Methods closeSCP def closeSCP ( self ) -> None View Source def closeSCP ( self ) -> None : if self . scp : self . scp . close () del self . scp get def get ( self , remotefile : ~ AnyStr , localpath : ~ AnyStr , autoLogin : bool = None ) -> bool Takes a file from a remote server and place it directly on the local machine. :param remotefile: A full path to a file located on a remote machine :param localpath: A full path to a local directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (True) View Source @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localpath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefile: A full path to a file located on a remote machine - :param localpath: A full path to a local directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ). get ( remotefile , localpath ) openSCP def openSCP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> sshConnector . sshLibs . LDTKscp . SCPClient View Source def openSCP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SCPClient : if self . scp is not None and not reopen : return self . scp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . scp = SCPClient ( self . ssh . get_transport ()) return self . scp put def put ( self , files : Any , remotepath : ~ AnyStr , autoLogin : bool = None ) -> bool Take a local file or multiple files and upload it to a remote location. If files parameter is an IO object the remotepath must be a full name and not a directory. :param files: single or list of files to upload :param remotepath: a full path to a remote directory or filename. (If files is IO then this MUST be fullpath filename.) :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (True) View Source @ expDec ( returnOnExcept = False ) def put ( self , files : Any , remotepath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Take a local file or multiple files and upload it to a remote location. If files parameter is an IO object the remotepath must be a full name and not a directory. - :param files: single or list of files to upload - :param remotepath: a full path to a remote directory or filename. (If files is IO then this MUST be fullpath filename.) - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ) . put ( files , remotepath )","title":"Scpchannel"},{"location":"reference/SCPChannel/#module-scpchannel","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson # Version: 0.2 # Date: 10/05/17 # Description: This uses the LDTKscp.py third party module in combination with our Paramiko implementation to # preform scp style file uploads. import logging from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import exceptionDecorator as expDec from sshConnector.sshLibs.LDTKscp import SCPClient from paramiko import SSHClient from typing import Any , Optional , AnyStr # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.DEBUG) log = logging . getLogger ( 'SCP Client' ) def put ( ssh , files : Any , remotepath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'put' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: { files } - to the remote path of: [ { remotepath } ]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . put ( files , remotepath , recursive , preserve_times ) def get ( ssh , remotefile : AnyStr , localpath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'get' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to get the following file: { remotefile } - and saving it to: [ { localpath } ]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . get ( remotefile , localpath , recursive , preserve_times ) class SCPChannel ( object ): \"\"\" This is a wrapper for the two methods in the SCPClient class from the LDTKscp.py package. It is designed to be LDTK aware and to handle getting the correct SSH channel. While the package functions 'put' and 'get' wrap the third party SCPClient package. \"\"\" ldtk = None ssh : SSHClient = None scp : SCPClient = None def __init__ ( self , ldtk ): \"\"\" This requires the LDTK and uses it to get the main SSH channel by default. Or it uses a provided SSHChannel. - :param ldtk: A ToolKitInterface object. Used by the 'property' sshCon to pull the main SSH channel. \"\"\" self . ldtk = ldtk self . ssh = ldtk . sshCon . ssh def __enter__ ( self ): self . openSCP () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . closeSCP () def openSCP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SCPClient : if self . scp is not None and not reopen : return self . scp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . scp = SCPClient ( self . ssh . get_transport ()) return self . scp def closeSCP ( self ) -> None : if self . scp : self . scp . close () del self . scp @expDec ( returnOnExcept = False ) def put ( self , files : Any , remotepath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Take a local file or multiple files and upload it to a remote location. If files parameter is an IO object the remotepath must be a full name and not a directory. - :param files: single or list of files to upload - :param remotepath: a full path to a remote directory or filename. (If files is IO then this MUST be fullpath filename.) - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ) . put ( files , remotepath ) @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localpath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefile: A full path to a file located on a remote machine - :param localpath: A full path to a local directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ) . get ( remotefile , localpath )","title":"Module SCPChannel"},{"location":"reference/SCPChannel/#variables","text":"log","title":"Variables"},{"location":"reference/SCPChannel/#functions","text":"","title":"Functions"},{"location":"reference/SCPChannel/#get","text":"def get ( ssh , remotefile : ~ AnyStr , localpath : ~ AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None This uses the 'get' method within the SCPClient class found in the LDTKscp.py package. :param ssh: (Paramiko ssh object) :param remotefile: (AnyStr) :param localpath: (AnyStr) :param recursive: transfer files and directories recursively :param preserve_times: preserve mtime and atime of transferred files and directories :return: None View Source def get ( ssh , remotefile : AnyStr , localpath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'get' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to get the following file: {remotefile} - and saving it to: [{localpath}]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . get ( remotefile , localpath , recursive , preserve_times )","title":"get"},{"location":"reference/SCPChannel/#put","text":"def put ( ssh , files : Any , remotepath : ~ AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None This uses the 'put' method within the SCPClient class found in the LDTKscp.py package. :param ssh: (Paramiko ssh object) :param files: (AnyStr/File/IO Object) :param remotepath: (AnyStr) :param recursive: transfer files and directories recursively :param preserve_times: preserve mtime and atime of transferred files and directories :return: None View Source def put ( ssh , files : Any , remotepath : AnyStr , recursive : Optional [ bool ] = False , preserve_times : Optional [ bool ] = False ) -> None : \"\"\" This uses the 'put' method within the SCPClient class found in the LDTKscp.py package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :param recursive: transfer files and directories recursively - :param preserve_times: preserve mtime and atime of transferred files and directories - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: {files} - to the remote path of: [{remotepath}]' ) with SCPClient ( ssh . get_transport ()) as scpChannel : scpChannel . put ( files , remotepath , recursive , preserve_times )","title":"put"},{"location":"reference/SCPChannel/#classes","text":"","title":"Classes"},{"location":"reference/SCPChannel/#scpchannel","text":"class SCPChannel ( ldtk ) This is a wrapper for the two methods in the SCPClient class from the LDTKscp.py package. It is designed to be LDTK aware and to handle getting the correct SSH channel. While the package functions 'put' and 'get' wrap the third party SCPClient package.","title":"SCPChannel"},{"location":"reference/SCPChannel/#class-variables","text":"ldtk scp ssh","title":"Class variables"},{"location":"reference/SCPChannel/#methods","text":"","title":"Methods"},{"location":"reference/SCPChannel/#closescp","text":"def closeSCP ( self ) -> None View Source def closeSCP ( self ) -> None : if self . scp : self . scp . close () del self . scp","title":"closeSCP"},{"location":"reference/SCPChannel/#get_1","text":"def get ( self , remotefile : ~ AnyStr , localpath : ~ AnyStr , autoLogin : bool = None ) -> bool Takes a file from a remote server and place it directly on the local machine. :param remotefile: A full path to a file located on a remote machine :param localpath: A full path to a local directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (True) View Source @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localpath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefile: A full path to a file located on a remote machine - :param localpath: A full path to a local directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ). get ( remotefile , localpath )","title":"get"},{"location":"reference/SCPChannel/#openscp","text":"def openSCP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> sshConnector . sshLibs . LDTKscp . SCPClient View Source def openSCP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SCPClient : if self . scp is not None and not reopen : return self . scp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . scp = SCPClient ( self . ssh . get_transport ()) return self . scp","title":"openSCP"},{"location":"reference/SCPChannel/#put_1","text":"def put ( self , files : Any , remotepath : ~ AnyStr , autoLogin : bool = None ) -> bool Take a local file or multiple files and upload it to a remote location. If files parameter is an IO object the remotepath must be a full name and not a directory. :param files: single or list of files to upload :param remotepath: a full path to a remote directory or filename. (If files is IO then this MUST be fullpath filename.) :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (True) View Source @ expDec ( returnOnExcept = False ) def put ( self , files : Any , remotepath : AnyStr , autoLogin : bool = None ) -> bool : \"\"\" Take a local file or multiple files and upload it to a remote location. If files parameter is an IO object the remotepath must be a full name and not a directory. - :param files: single or list of files to upload - :param remotepath: a full path to a remote directory or filename. (If files is IO then this MUST be fullpath filename.) - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (True) \"\"\" return self . openSCP ( autoLogin ) . put ( files , remotepath )","title":"put"},{"location":"reference/SFTPChannel/","text":"Module SFTPChannel View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson # Version: 0.1 # Date: 9/23/20 # Description: This uses the Paramiko's implementation of SFTP too preform put and get actions on a remote machine in # the FTP style. import logging from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import exceptionDecorator as expDec from paramiko.sftp_client import SFTPClient from paramiko.sftp_attr import SFTPAttributes from paramiko import SSHClient from typing import Union , AnyStr , IO , Optional , Any , List , Type # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.DEBUG) log = logging . getLogger ( 'SFTP Client' ) def put ( ssh , files : IO [ bytes ], remotepath : AnyStr ) -> None : \"\"\" This uses the 'putfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: { files } - to the remote path of: [ { remotepath } ]' ) with ssh . get_transport () . open_sftp_client () as sftp : sftp . putfo ( files , remotepath ) def get ( ssh , remotefile : AnyStr , localpath : IO [ bytes ]) -> None : \"\"\" This uses the 'getfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr/File/IO Object) - :return: None \"\"\" log . debug ( f 'About to get the following file: { remotefile } - and saving it to: [ { localpath } ]' ) with ssh . get_transport () . open_sftp_client () as sftp : sftp . getfo ( remotefile , localpath ) class SFTPChannel ( object ): \"\"\" This is a wrapper for the two functions inside this package. The 'put' and 'get' functions. It is designed to be LDTK aware and to handle getting the correct SSH channel. \"\"\" ldtk = None ssh : SSHClient = None sftp : SFTPClient = None def __init__ ( self , ldtk ): \"\"\" This requires the LDTK and uses it to get the main SSH channel by default. Or it uses a provided SSHChannel. - :param ldtk: A ToolKitInterface object. Used by the 'property' sshCon to pull the main SSH channel. \"\"\" self . ldtk = ldtk self . ssh = ldtk . sshCon . ssh def __enter__ ( self ): self . openSFTP () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . closeSFTP () def openSFTP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SFTPClient : \"\"\" Returns the current sftp or creates an sftp client. :param autoLogin: (bool) - This will attempt to have the LTDK create a Paramiko connection if it isn't connected :param reopen: (bool) :return: (SFTPClient) \"\"\" if self . sftp is not None and not reopen : return self . sftp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . sftp = self . ssh . get_transport () . open_sftp_client () return self . sftp def closeSFTP ( self ) -> None : \"\"\" This closes the SFTP connection and removes the 'sftp' class variable. - :return: None \"\"\" if self . sftp : self . sftp . close () del self . sftp @expDec ( returnOnExcept = False ) def put ( self , localfile : Union [ AnyStr , IO [ bytes ]], remotefile : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" Take a local file or multiple files and upload it to a remote location. - :param localFile: A full or relative path a file for upload or a file like object - :param remotepath: a full path to a remote directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ): return self . openSFTP ( autoLogin ) . put ( localfile , remotefile ) return self . openSFTP ( autoLogin ) . putfo ( localfile , remotefile ) @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localfile : Union [ AnyStr , IO [ bytes ]], autoLogin : bool = None ) -> Any : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefiles: A full path to a file or files located on a remote machine - :param localpath: A full path to a local directory or file like object - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ): return self . openSFTP ( autoLogin ) . get ( remotefile , localfile ) return self . openSFTP ( autoLogin ) . getfo ( remotefile , localfile ) @expDec ( returnOnExcept = False ) def chdir ( self , path : AnyStr , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'chdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 new current working directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . chdir ( path ) @expDec ( returnOnExcept = False ) def chmod ( self , path : AnyStr , mode : int , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'chmod' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param mode: (int) - new permissions - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . chmod ( path , mode ) @expDec ( returnOnExcept = False ) def chown ( self , path : AnyStr , uid : int , gid : int , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'chown' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param uid: (int) - new owner\u2019s uid - :param gid: (int) \u2013 new group id - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . chown ( path , uid , gid ) @expDec ( returnOnExcept = \"\" ) def getcwd ( self ) -> AnyStr : \"\"\" This uses the 'getcwd' method from the SFTPClient class in the Paramiko package. - :return: (str) current working directory \"\"\" return self . openSFTP ( False ) . getcwd () @expDec ( returnOnExcept = []) def listdir ( self , path : AnyStr = '.' , autoLogin : bool = None ) -> List : \"\"\" This uses the 'listdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) Default '.' \u2013 path of the target directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (List) \"\"\" return self . openSFTP ( autoLogin ) . listdir ( path ) @expDec ( returnOnExcept = False ) def lstat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ]: \"\"\" This uses the 'lstat' method from the SFTPClient class in the Paramiko package. This differs from stat by not following symbolic links. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ) . lstat ( path ) @expDec ( returnOnExcept = False ) def stat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ]: \"\"\" This uses the 'stat' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ) . stat ( path ) @expDec ( returnOnExcept = False ) def mkdir ( self , path : AnyStr , mode : int = 511 , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'mkdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder to create - :param mode: (int) Default 511 \u2013 permissions (posix-style) for the newly-created folder - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . mkdir ( path , mode ) @expDec ( returnOnExcept = \"\" ) def readlink ( self , path : AnyStr , autoLogin : bool = None ) -> AnyStr : \"\"\" This uses the 'readlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the symbolic link file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (str) \"\"\" return self . openSFTP ( autoLogin ) . readlink ( path ) @expDec ( returnOnExcept = False ) def remove ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'remove' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . remove ( path ) @expDec ( returnOnExcept = False ) def rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rename' method from the SFTPClient class in the Paramiko package. This method implements \u2018standard\u2019 SFTP RENAME behavior; those seeking the OpenSSH \u201cPOSIX rename\u201d extension behavior should use posix_rename. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, must not exist already - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . rename ( oldpath , newpath ) @expDec ( returnOnExcept = False ) def posix_rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'posix_rename' method from the SFTPClient class in the Paramiko package. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, will be overwritten if it already exists - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . posix_rename ( oldpath , newpath ) @expDec ( returnOnExcept = False ) def rmdir ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rmdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder/directory to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . rmdir ( path ) @expDec ( returnOnExcept = False ) def symlink ( self , source : AnyStr , dest : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'symlink' method from the SFTPClient class in the Paramiko package. - :param source: (str) \u2013 path of the original file - :param dest: (str) \u2013 path of the newly created symlink - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . symlink ( source , dest ) @expDec ( returnOnExcept = False ) def truncate ( self , path : AnyStr , size : int , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'truncate' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the file to modify - :param size: (int) \u2013 the new size of the file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . truncate ( path , size ) @expDec ( returnOnExcept = False ) def unlink ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'unlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . unlink ( path ) Variables log Functions get def get ( ssh , remotefile : ~ AnyStr , localpath : IO [ bytes ] ) -> None This uses the 'getfo' method from SFTPClient in the Paramiko package. :param ssh: (Paramiko ssh object) :param remotefile: (AnyStr) :param localpath: (AnyStr/File/IO Object) :return: None View Source def get ( ssh , remotefile : AnyStr , localpath : IO [ bytes ] ) -> None : \"\"\" This uses the 'getfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr/File/IO Object) - :return: None \"\"\" log . debug ( f 'About to get the following file: {remotefile} - and saving it to: [{localpath}]' ) with ssh . get_transport (). open_sftp_client () as sftp : sftp . getfo ( remotefile , localpath ) put def put ( ssh , files : IO [ bytes ], remotepath : ~ AnyStr ) -> None This uses the 'putfo' method from SFTPClient in the Paramiko package. :param ssh: (Paramiko ssh object) :param files: (AnyStr/File/IO Object) :param remotepath: (AnyStr) :return: None View Source def put ( ssh , files : IO [ bytes ] , remotepath : AnyStr ) -> None : \"\"\" This uses the 'putfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: {files} - to the remote path of: [{remotepath}]' ) with ssh . get_transport (). open_sftp_client () as sftp : sftp . putfo ( files , remotepath ) Classes SFTPChannel class SFTPChannel ( ldtk ) This is a wrapper for the two functions inside this package. The 'put' and 'get' functions. It is designed to be LDTK aware and to handle getting the correct SSH channel. Class variables ldtk sftp ssh Methods chdir def chdir ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'chdir' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 new current working directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def chdir ( self , path : AnyStr , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'chdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 new current working directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). chdir ( path ) chmod def chmod ( self , path : ~ AnyStr , mode : int , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'chmod' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the target file or directory :param mode: (int) - new permissions :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def chmod ( self , path : AnyStr , mode : int , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'chmod' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param mode: (int) - new permissions - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). chmod ( path , mode ) chown def chown ( self , path : ~ AnyStr , uid : int , gid : int , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'chown' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the target file or directory :param uid: (int) - new owner\u2019s uid :param gid: (int) \u2013 new group id :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def chown ( self , path : AnyStr , uid : int , gid : int , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'chown' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param uid: (int) - new owner\u2019s uid - :param gid: (int) \u2013 new group id - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). chown ( path , uid , gid ) closeSFTP def closeSFTP ( self ) -> None This closes the SFTP connection and removes the 'sftp' class variable. :return: None View Source def closeSFTP ( self ) -> None : \"\"\" This closes the SFTP connection and removes the 'sftp' class variable. - :return: None \"\"\" if self . sftp : self . sftp . close () del self . sftp get def get ( self , remotefile : ~ AnyStr , localfile : Union [ ~ AnyStr , IO [ bytes ]], autoLogin : bool = None ) -> Any Takes a file from a remote server and place it directly on the local machine. :param remotefiles: A full path to a file or files located on a remote machine :param localpath: A full path to a local directory or file like object :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: None View Source @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localfile : Union [ AnyStr, IO[bytes ] ] , autoLogin : bool = None ) -> Any : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefiles: A full path to a file or files located on a remote machine - :param localpath: A full path to a local directory or file like object - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ) : return self . openSFTP ( autoLogin ). get ( remotefile , localfile ) return self . openSFTP ( autoLogin ). getfo ( remotefile , localfile ) getcwd def getcwd ( self ) -> ~ AnyStr This uses the 'getcwd' method from the SFTPClient class in the Paramiko package. :return: (str) current working directory View Source @ expDec ( returnOnExcept = \"\" ) def getcwd ( self ) -> AnyStr : \"\"\" This uses the 'getcwd' method from the SFTPClient class in the Paramiko package. - :return: (str) current working directory \"\"\" return self . openSFTP ( False ). getcwd () listdir def listdir ( self , path : ~ AnyStr = '.' , autoLogin : bool = None ) -> List This uses the 'listdir' method from the SFTPClient class in the Paramiko package. :param path: (str) Default '.' \u2013 path of the target directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (List) View Source @ expDec ( returnOnExcept =[]) def listdir ( self , path : AnyStr = '.' , autoLogin : bool = None ) -> List : \"\"\" This uses the 'listdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) Default '.' \u2013 path of the target directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (List) \"\"\" return self . openSFTP ( autoLogin ). listdir ( path ) lstat def lstat ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Type [ paramiko . sftp_attr . SFTPAttributes ] This uses the 'lstat' method from the SFTPClient class in the Paramiko package. This differs from stat by not following symbolic links. :param path: (str) \u2013 path of the target file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (SFTPAttributes object) View Source @expDec ( returnOnExcept = False ) def lstat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ] : \"\"\" This uses the 'lstat' method from the SFTPClient class in the Paramiko package. This differs from stat by not following symbolic links. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ). lstat ( path ) mkdir def mkdir ( self , path : ~ AnyStr , mode : int = 511 , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'mkdir' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 name of the folder to create :param mode: (int) Default 511 \u2013 permissions (posix-style) for the newly-created folder :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def mkdir ( self , path : AnyStr , mode : int = 511 , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'mkdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder to create - :param mode: (int) Default 511 \u2013 permissions (posix-style) for the newly-created folder - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). mkdir ( path , mode ) openSFTP def openSFTP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> paramiko . sftp_client . SFTPClient Returns the current sftp or creates an sftp client. Parameters: Name Type Description Default autoLogin None (bool) - This will attempt to have the LTDK create a Paramiko connection if it isn't connected None reopen None (bool) None Returns: Type Description None (SFTPClient) View Source def openSFTP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SFTPClient : \"\"\" Returns the current sftp or creates an sftp client. :param autoLogin: (bool) - This will attempt to have the LTDK create a Paramiko connection if it isn't connected :param reopen: (bool) :return: (SFTPClient) \"\"\" if self . sftp is not None and not reopen : return self . sftp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . sftp = self . ssh . get_transport (). open_sftp_client () return self . sftp posix_rename def posix_rename ( self , oldpath : ~ AnyStr , newpath : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'posix_rename' method from the SFTPClient class in the Paramiko package. :param oldpath: (str) \u2013 existing name of the file or folder :param newpath: (str) \u2013 new name for the file or folder, will be overwritten if it already exists :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def posix_rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'posix_rename' method from the SFTPClient class in the Paramiko package. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, will be overwritten if it already exists - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). posix_rename ( oldpath , newpath ) put def put ( self , localfile : Union [ ~ AnyStr , IO [ bytes ]], remotefile : ~ AnyStr , autoLogin : bool = None ) -> Any Take a local file or multiple files and upload it to a remote location. :param localFile: A full or relative path a file for upload or a file like object :param remotepath: a full path to a remote directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: None View Source @expDec ( returnOnExcept = False ) def put ( self , localfile : Union [ AnyStr, IO[bytes ] ] , remotefile : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" Take a local file or multiple files and upload it to a remote location. - :param localFile: A full or relative path a file for upload or a file like object - :param remotepath: a full path to a remote directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ) : return self . openSFTP ( autoLogin ). put ( localfile , remotefile ) return self . openSFTP ( autoLogin ). putfo ( localfile , remotefile ) readlink def readlink ( self , path : ~ AnyStr , autoLogin : bool = None ) -> ~ AnyStr This uses the 'readlink' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the symbolic link file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (str) View Source @ expDec ( returnOnExcept = \"\" ) def readlink ( self , path : AnyStr , autoLogin : bool = None ) -> AnyStr : \"\"\" This uses the 'readlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the symbolic link file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (str) \"\"\" return self . openSFTP ( autoLogin ). readlink ( path ) remove def remove ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'remove' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path (absolute or relative) of the file to remove :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @ expDec ( returnOnExcept = False ) def remove ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'remove' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). remove ( path ) rename def rename ( self , oldpath : ~ AnyStr , newpath : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'rename' method from the SFTPClient class in the Paramiko package. This method implements \u2018standard\u2019 SFTP RENAME behavior; those seeking the OpenSSH \u201cPOSIX rename\u201d extension behavior should use posix_rename. :param oldpath: (str) \u2013 existing name of the file or folder :param newpath: (str) \u2013 new name for the file or folder, must not exist already :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rename' method from the SFTPClient class in the Paramiko package. This method implements \u2018standard\u2019 SFTP RENAME behavior; those seeking the OpenSSH \u201cPOSIX rename\u201d extension behavior should use posix_rename. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, must not exist already - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). rename ( oldpath , newpath ) rmdir def rmdir ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'rmdir' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 name of the folder/directory to remove :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def rmdir ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rmdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder/directory to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). rmdir ( path ) stat def stat ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Type [ paramiko . sftp_attr . SFTPAttributes ] This uses the 'stat' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the target file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (SFTPAttributes object) View Source @expDec ( returnOnExcept = False ) def stat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ] : \"\"\" This uses the 'stat' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ). stat ( path ) symlink def symlink ( self , source : ~ AnyStr , dest : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'symlink' method from the SFTPClient class in the Paramiko package. :param source: (str) \u2013 path of the original file :param dest: (str) \u2013 path of the newly created symlink :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def symlink ( self , source : AnyStr , dest : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'symlink' method from the SFTPClient class in the Paramiko package. - :param source: (str) \u2013 path of the original file - :param dest: (str) \u2013 path of the newly created symlink - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). symlink ( source , dest ) truncate def truncate ( self , path : ~ AnyStr , size : int , autoLogin : bool = None ) -> Any This uses the 'truncate' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the file to modify :param size: (int) \u2013 the new size of the file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def truncate ( self , path : AnyStr , size : int , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'truncate' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the file to modify - :param size: (int) \u2013 the new size of the file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). truncate ( path , size ) unlink def unlink ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'unlink' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path (absolute or relative) of the file to remove :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def unlink ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'unlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). unlink ( path )","title":"Sftpchannel"},{"location":"reference/SFTPChannel/#module-sftpchannel","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson # Version: 0.1 # Date: 9/23/20 # Description: This uses the Paramiko's implementation of SFTP too preform put and get actions on a remote machine in # the FTP style. import logging from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import exceptionDecorator as expDec from paramiko.sftp_client import SFTPClient from paramiko.sftp_attr import SFTPAttributes from paramiko import SSHClient from typing import Union , AnyStr , IO , Optional , Any , List , Type # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.DEBUG) log = logging . getLogger ( 'SFTP Client' ) def put ( ssh , files : IO [ bytes ], remotepath : AnyStr ) -> None : \"\"\" This uses the 'putfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: { files } - to the remote path of: [ { remotepath } ]' ) with ssh . get_transport () . open_sftp_client () as sftp : sftp . putfo ( files , remotepath ) def get ( ssh , remotefile : AnyStr , localpath : IO [ bytes ]) -> None : \"\"\" This uses the 'getfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr/File/IO Object) - :return: None \"\"\" log . debug ( f 'About to get the following file: { remotefile } - and saving it to: [ { localpath } ]' ) with ssh . get_transport () . open_sftp_client () as sftp : sftp . getfo ( remotefile , localpath ) class SFTPChannel ( object ): \"\"\" This is a wrapper for the two functions inside this package. The 'put' and 'get' functions. It is designed to be LDTK aware and to handle getting the correct SSH channel. \"\"\" ldtk = None ssh : SSHClient = None sftp : SFTPClient = None def __init__ ( self , ldtk ): \"\"\" This requires the LDTK and uses it to get the main SSH channel by default. Or it uses a provided SSHChannel. - :param ldtk: A ToolKitInterface object. Used by the 'property' sshCon to pull the main SSH channel. \"\"\" self . ldtk = ldtk self . ssh = ldtk . sshCon . ssh def __enter__ ( self ): self . openSFTP () return self def __exit__ ( self , exc_type , exc_val , exc_tb ): self . closeSFTP () def openSFTP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SFTPClient : \"\"\" Returns the current sftp or creates an sftp client. :param autoLogin: (bool) - This will attempt to have the LTDK create a Paramiko connection if it isn't connected :param reopen: (bool) :return: (SFTPClient) \"\"\" if self . sftp is not None and not reopen : return self . sftp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . sftp = self . ssh . get_transport () . open_sftp_client () return self . sftp def closeSFTP ( self ) -> None : \"\"\" This closes the SFTP connection and removes the 'sftp' class variable. - :return: None \"\"\" if self . sftp : self . sftp . close () del self . sftp @expDec ( returnOnExcept = False ) def put ( self , localfile : Union [ AnyStr , IO [ bytes ]], remotefile : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" Take a local file or multiple files and upload it to a remote location. - :param localFile: A full or relative path a file for upload or a file like object - :param remotepath: a full path to a remote directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ): return self . openSFTP ( autoLogin ) . put ( localfile , remotefile ) return self . openSFTP ( autoLogin ) . putfo ( localfile , remotefile ) @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localfile : Union [ AnyStr , IO [ bytes ]], autoLogin : bool = None ) -> Any : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefiles: A full path to a file or files located on a remote machine - :param localpath: A full path to a local directory or file like object - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ): return self . openSFTP ( autoLogin ) . get ( remotefile , localfile ) return self . openSFTP ( autoLogin ) . getfo ( remotefile , localfile ) @expDec ( returnOnExcept = False ) def chdir ( self , path : AnyStr , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'chdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 new current working directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . chdir ( path ) @expDec ( returnOnExcept = False ) def chmod ( self , path : AnyStr , mode : int , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'chmod' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param mode: (int) - new permissions - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . chmod ( path , mode ) @expDec ( returnOnExcept = False ) def chown ( self , path : AnyStr , uid : int , gid : int , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'chown' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param uid: (int) - new owner\u2019s uid - :param gid: (int) \u2013 new group id - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . chown ( path , uid , gid ) @expDec ( returnOnExcept = \"\" ) def getcwd ( self ) -> AnyStr : \"\"\" This uses the 'getcwd' method from the SFTPClient class in the Paramiko package. - :return: (str) current working directory \"\"\" return self . openSFTP ( False ) . getcwd () @expDec ( returnOnExcept = []) def listdir ( self , path : AnyStr = '.' , autoLogin : bool = None ) -> List : \"\"\" This uses the 'listdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) Default '.' \u2013 path of the target directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (List) \"\"\" return self . openSFTP ( autoLogin ) . listdir ( path ) @expDec ( returnOnExcept = False ) def lstat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ]: \"\"\" This uses the 'lstat' method from the SFTPClient class in the Paramiko package. This differs from stat by not following symbolic links. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ) . lstat ( path ) @expDec ( returnOnExcept = False ) def stat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ]: \"\"\" This uses the 'stat' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ) . stat ( path ) @expDec ( returnOnExcept = False ) def mkdir ( self , path : AnyStr , mode : int = 511 , autoLogin : bool = None ) -> Optional [ bool ]: \"\"\" This uses the 'mkdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder to create - :param mode: (int) Default 511 \u2013 permissions (posix-style) for the newly-created folder - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . mkdir ( path , mode ) @expDec ( returnOnExcept = \"\" ) def readlink ( self , path : AnyStr , autoLogin : bool = None ) -> AnyStr : \"\"\" This uses the 'readlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the symbolic link file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (str) \"\"\" return self . openSFTP ( autoLogin ) . readlink ( path ) @expDec ( returnOnExcept = False ) def remove ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'remove' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ) . remove ( path ) @expDec ( returnOnExcept = False ) def rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rename' method from the SFTPClient class in the Paramiko package. This method implements \u2018standard\u2019 SFTP RENAME behavior; those seeking the OpenSSH \u201cPOSIX rename\u201d extension behavior should use posix_rename. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, must not exist already - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . rename ( oldpath , newpath ) @expDec ( returnOnExcept = False ) def posix_rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'posix_rename' method from the SFTPClient class in the Paramiko package. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, will be overwritten if it already exists - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . posix_rename ( oldpath , newpath ) @expDec ( returnOnExcept = False ) def rmdir ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rmdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder/directory to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . rmdir ( path ) @expDec ( returnOnExcept = False ) def symlink ( self , source : AnyStr , dest : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'symlink' method from the SFTPClient class in the Paramiko package. - :param source: (str) \u2013 path of the original file - :param dest: (str) \u2013 path of the newly created symlink - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . symlink ( source , dest ) @expDec ( returnOnExcept = False ) def truncate ( self , path : AnyStr , size : int , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'truncate' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the file to modify - :param size: (int) \u2013 the new size of the file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . truncate ( path , size ) @expDec ( returnOnExcept = False ) def unlink ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'unlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ) . unlink ( path )","title":"Module SFTPChannel"},{"location":"reference/SFTPChannel/#variables","text":"log","title":"Variables"},{"location":"reference/SFTPChannel/#functions","text":"","title":"Functions"},{"location":"reference/SFTPChannel/#get","text":"def get ( ssh , remotefile : ~ AnyStr , localpath : IO [ bytes ] ) -> None This uses the 'getfo' method from SFTPClient in the Paramiko package. :param ssh: (Paramiko ssh object) :param remotefile: (AnyStr) :param localpath: (AnyStr/File/IO Object) :return: None View Source def get ( ssh , remotefile : AnyStr , localpath : IO [ bytes ] ) -> None : \"\"\" This uses the 'getfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param remotefile: (AnyStr) - :param localpath: (AnyStr/File/IO Object) - :return: None \"\"\" log . debug ( f 'About to get the following file: {remotefile} - and saving it to: [{localpath}]' ) with ssh . get_transport (). open_sftp_client () as sftp : sftp . getfo ( remotefile , localpath )","title":"get"},{"location":"reference/SFTPChannel/#put","text":"def put ( ssh , files : IO [ bytes ], remotepath : ~ AnyStr ) -> None This uses the 'putfo' method from SFTPClient in the Paramiko package. :param ssh: (Paramiko ssh object) :param files: (AnyStr/File/IO Object) :param remotepath: (AnyStr) :return: None View Source def put ( ssh , files : IO [ bytes ] , remotepath : AnyStr ) -> None : \"\"\" This uses the 'putfo' method from SFTPClient in the Paramiko package. - :param ssh: (Paramiko ssh object) - :param files: (AnyStr/File/IO Object) - :param remotepath: (AnyStr) - :return: None \"\"\" log . debug ( f 'About to pass the following file[s]: {files} - to the remote path of: [{remotepath}]' ) with ssh . get_transport (). open_sftp_client () as sftp : sftp . putfo ( files , remotepath )","title":"put"},{"location":"reference/SFTPChannel/#classes","text":"","title":"Classes"},{"location":"reference/SFTPChannel/#sftpchannel","text":"class SFTPChannel ( ldtk ) This is a wrapper for the two functions inside this package. The 'put' and 'get' functions. It is designed to be LDTK aware and to handle getting the correct SSH channel.","title":"SFTPChannel"},{"location":"reference/SFTPChannel/#class-variables","text":"ldtk sftp ssh","title":"Class variables"},{"location":"reference/SFTPChannel/#methods","text":"","title":"Methods"},{"location":"reference/SFTPChannel/#chdir","text":"def chdir ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'chdir' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 new current working directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def chdir ( self , path : AnyStr , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'chdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 new current working directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). chdir ( path )","title":"chdir"},{"location":"reference/SFTPChannel/#chmod","text":"def chmod ( self , path : ~ AnyStr , mode : int , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'chmod' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the target file or directory :param mode: (int) - new permissions :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def chmod ( self , path : AnyStr , mode : int , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'chmod' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param mode: (int) - new permissions - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). chmod ( path , mode )","title":"chmod"},{"location":"reference/SFTPChannel/#chown","text":"def chown ( self , path : ~ AnyStr , uid : int , gid : int , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'chown' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the target file or directory :param uid: (int) - new owner\u2019s uid :param gid: (int) \u2013 new group id :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def chown ( self , path : AnyStr , uid : int , gid : int , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'chown' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file or directory - :param uid: (int) - new owner\u2019s uid - :param gid: (int) \u2013 new group id - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). chown ( path , uid , gid )","title":"chown"},{"location":"reference/SFTPChannel/#closesftp","text":"def closeSFTP ( self ) -> None This closes the SFTP connection and removes the 'sftp' class variable. :return: None View Source def closeSFTP ( self ) -> None : \"\"\" This closes the SFTP connection and removes the 'sftp' class variable. - :return: None \"\"\" if self . sftp : self . sftp . close () del self . sftp","title":"closeSFTP"},{"location":"reference/SFTPChannel/#get_1","text":"def get ( self , remotefile : ~ AnyStr , localfile : Union [ ~ AnyStr , IO [ bytes ]], autoLogin : bool = None ) -> Any Takes a file from a remote server and place it directly on the local machine. :param remotefiles: A full path to a file or files located on a remote machine :param localpath: A full path to a local directory or file like object :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: None View Source @expDec ( returnOnExcept = False ) def get ( self , remotefile : AnyStr , localfile : Union [ AnyStr, IO[bytes ] ] , autoLogin : bool = None ) -> Any : \"\"\" Takes a file from a remote server and place it directly on the local machine. - :param remotefiles: A full path to a file or files located on a remote machine - :param localpath: A full path to a local directory or file like object - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ) : return self . openSFTP ( autoLogin ). get ( remotefile , localfile ) return self . openSFTP ( autoLogin ). getfo ( remotefile , localfile )","title":"get"},{"location":"reference/SFTPChannel/#getcwd","text":"def getcwd ( self ) -> ~ AnyStr This uses the 'getcwd' method from the SFTPClient class in the Paramiko package. :return: (str) current working directory View Source @ expDec ( returnOnExcept = \"\" ) def getcwd ( self ) -> AnyStr : \"\"\" This uses the 'getcwd' method from the SFTPClient class in the Paramiko package. - :return: (str) current working directory \"\"\" return self . openSFTP ( False ). getcwd ()","title":"getcwd"},{"location":"reference/SFTPChannel/#listdir","text":"def listdir ( self , path : ~ AnyStr = '.' , autoLogin : bool = None ) -> List This uses the 'listdir' method from the SFTPClient class in the Paramiko package. :param path: (str) Default '.' \u2013 path of the target directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (List) View Source @ expDec ( returnOnExcept =[]) def listdir ( self , path : AnyStr = '.' , autoLogin : bool = None ) -> List : \"\"\" This uses the 'listdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) Default '.' \u2013 path of the target directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (List) \"\"\" return self . openSFTP ( autoLogin ). listdir ( path )","title":"listdir"},{"location":"reference/SFTPChannel/#lstat","text":"def lstat ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Type [ paramiko . sftp_attr . SFTPAttributes ] This uses the 'lstat' method from the SFTPClient class in the Paramiko package. This differs from stat by not following symbolic links. :param path: (str) \u2013 path of the target file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (SFTPAttributes object) View Source @expDec ( returnOnExcept = False ) def lstat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ] : \"\"\" This uses the 'lstat' method from the SFTPClient class in the Paramiko package. This differs from stat by not following symbolic links. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ). lstat ( path )","title":"lstat"},{"location":"reference/SFTPChannel/#mkdir","text":"def mkdir ( self , path : ~ AnyStr , mode : int = 511 , autoLogin : bool = None ) -> Optional [ bool ] This uses the 'mkdir' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 name of the folder to create :param mode: (int) Default 511 \u2013 permissions (posix-style) for the newly-created folder :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @expDec ( returnOnExcept = False ) def mkdir ( self , path : AnyStr , mode : int = 511 , autoLogin : bool = None ) -> Optional [ bool ] : \"\"\" This uses the 'mkdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder to create - :param mode: (int) Default 511 \u2013 permissions (posix-style) for the newly-created folder - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). mkdir ( path , mode )","title":"mkdir"},{"location":"reference/SFTPChannel/#opensftp","text":"def openSFTP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> paramiko . sftp_client . SFTPClient Returns the current sftp or creates an sftp client. Parameters: Name Type Description Default autoLogin None (bool) - This will attempt to have the LTDK create a Paramiko connection if it isn't connected None reopen None (bool) None Returns: Type Description None (SFTPClient) View Source def openSFTP ( self , autoLogin : bool = None , reopen : Optional [ bool ] = False ) -> SFTPClient : \"\"\" Returns the current sftp or creates an sftp client. :param autoLogin: (bool) - This will attempt to have the LTDK create a Paramiko connection if it isn't connected :param reopen: (bool) :return: (SFTPClient) \"\"\" if self . sftp is not None and not reopen : return self . sftp if autoLogin is None : autoLogin = self . ldtk . auto_login if self . ldtk . checkConnection () is False and autoLogin : self . ldtk . createConnection () self . ssh = self . ldtk . sshCon . ssh self . sftp = self . ssh . get_transport (). open_sftp_client () return self . sftp","title":"openSFTP"},{"location":"reference/SFTPChannel/#posix_rename","text":"def posix_rename ( self , oldpath : ~ AnyStr , newpath : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'posix_rename' method from the SFTPClient class in the Paramiko package. :param oldpath: (str) \u2013 existing name of the file or folder :param newpath: (str) \u2013 new name for the file or folder, will be overwritten if it already exists :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def posix_rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'posix_rename' method from the SFTPClient class in the Paramiko package. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, will be overwritten if it already exists - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). posix_rename ( oldpath , newpath )","title":"posix_rename"},{"location":"reference/SFTPChannel/#put_1","text":"def put ( self , localfile : Union [ ~ AnyStr , IO [ bytes ]], remotefile : ~ AnyStr , autoLogin : bool = None ) -> Any Take a local file or multiple files and upload it to a remote location. :param localFile: A full or relative path a file for upload or a file like object :param remotepath: a full path to a remote directory :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: None View Source @expDec ( returnOnExcept = False ) def put ( self , localfile : Union [ AnyStr, IO[bytes ] ] , remotefile : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" Take a local file or multiple files and upload it to a remote location. - :param localFile: A full or relative path a file for upload or a file like object - :param remotepath: a full path to a remote directory - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: None \"\"\" if isinstance ( localfile , str ) : return self . openSFTP ( autoLogin ). put ( localfile , remotefile ) return self . openSFTP ( autoLogin ). putfo ( localfile , remotefile )","title":"put"},{"location":"reference/SFTPChannel/#readlink","text":"def readlink ( self , path : ~ AnyStr , autoLogin : bool = None ) -> ~ AnyStr This uses the 'readlink' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the symbolic link file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (str) View Source @ expDec ( returnOnExcept = \"\" ) def readlink ( self , path : AnyStr , autoLogin : bool = None ) -> AnyStr : \"\"\" This uses the 'readlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the symbolic link file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (str) \"\"\" return self . openSFTP ( autoLogin ). readlink ( path )","title":"readlink"},{"location":"reference/SFTPChannel/#remove","text":"def remove ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'remove' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path (absolute or relative) of the file to remove :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (bool) View Source @ expDec ( returnOnExcept = False ) def remove ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'remove' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (bool) \"\"\" return self . openSFTP ( autoLogin ). remove ( path )","title":"remove"},{"location":"reference/SFTPChannel/#rename","text":"def rename ( self , oldpath : ~ AnyStr , newpath : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'rename' method from the SFTPClient class in the Paramiko package. This method implements \u2018standard\u2019 SFTP RENAME behavior; those seeking the OpenSSH \u201cPOSIX rename\u201d extension behavior should use posix_rename. :param oldpath: (str) \u2013 existing name of the file or folder :param newpath: (str) \u2013 new name for the file or folder, must not exist already :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def rename ( self , oldpath : AnyStr , newpath : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rename' method from the SFTPClient class in the Paramiko package. This method implements \u2018standard\u2019 SFTP RENAME behavior; those seeking the OpenSSH \u201cPOSIX rename\u201d extension behavior should use posix_rename. - :param oldpath: (str) \u2013 existing name of the file or folder - :param newpath: (str) \u2013 new name for the file or folder, must not exist already - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). rename ( oldpath , newpath )","title":"rename"},{"location":"reference/SFTPChannel/#rmdir","text":"def rmdir ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'rmdir' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 name of the folder/directory to remove :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def rmdir ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'rmdir' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 name of the folder/directory to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). rmdir ( path )","title":"rmdir"},{"location":"reference/SFTPChannel/#stat","text":"def stat ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Type [ paramiko . sftp_attr . SFTPAttributes ] This uses the 'stat' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the target file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: (SFTPAttributes object) View Source @expDec ( returnOnExcept = False ) def stat ( self , path : AnyStr , autoLogin : bool = None ) -> Type [ SFTPAttributes ] : \"\"\" This uses the 'stat' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the target file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: (SFTPAttributes object) \"\"\" return self . openSFTP ( autoLogin ). stat ( path )","title":"stat"},{"location":"reference/SFTPChannel/#symlink","text":"def symlink ( self , source : ~ AnyStr , dest : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'symlink' method from the SFTPClient class in the Paramiko package. :param source: (str) \u2013 path of the original file :param dest: (str) \u2013 path of the newly created symlink :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def symlink ( self , source : AnyStr , dest : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'symlink' method from the SFTPClient class in the Paramiko package. - :param source: (str) \u2013 path of the original file - :param dest: (str) \u2013 path of the newly created symlink - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). symlink ( source , dest )","title":"symlink"},{"location":"reference/SFTPChannel/#truncate","text":"def truncate ( self , path : ~ AnyStr , size : int , autoLogin : bool = None ) -> Any This uses the 'truncate' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path of the file to modify :param size: (int) \u2013 the new size of the file :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def truncate ( self , path : AnyStr , size : int , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'truncate' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path of the file to modify - :param size: (int) \u2013 the new size of the file - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). truncate ( path , size )","title":"truncate"},{"location":"reference/SFTPChannel/#unlink","text":"def unlink ( self , path : ~ AnyStr , autoLogin : bool = None ) -> Any This uses the 'unlink' method from the SFTPClient class in the Paramiko package. :param path: (str) \u2013 path (absolute or relative) of the file to remove :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. :return: View Source @ expDec ( returnOnExcept = False ) def unlink ( self , path : AnyStr , autoLogin : bool = None ) -> Any : \"\"\" This uses the 'unlink' method from the SFTPClient class in the Paramiko package. - :param path: (str) \u2013 path (absolute or relative) of the file to remove - :param autoLogin: (bool) - Controls if this will attempt a connection if one isn't present. - :return: \"\"\" return self . openSFTP ( autoLogin ). unlink ( path )","title":"unlink"},{"location":"reference/genericCmdModule/","text":"Module genericCmdModule View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Ryan Henrichson, Timothy Nodine # Version: 2.0 # Date: 06/17/17 # Description: This is the foundation for all Command Modules. It is a set of classes that are inherited by all # CommandModules import logging from functools import partial from copy import copy , deepcopy from LinuxModules import CommandContainers from libs import dummy_func from typing import Any , Optional , Union , Hashable , Callable log = logging . getLogger ( 'GenericCommandModule' ) def executionDecorator ( func ): def runResultsValue ( bindingObject , * args , ** kwargs ): exeResults = func ( bindingObject , * args , ** kwargs ) if exeResults and getattr ( bindingObject , 'returnValueType' , None ): return bindingObject . returnValueType ( exeResults ) return exeResults return runResultsValue # noinspection PyBroadException class CommandModuleSettings : \"\"\" A list of variables that represent the settings of a Command Module and their default values. Also a collection of properties used for accessing and manipulating those settings. \"\"\" __useDefaultParsing = None __returnValueType = None __ignoreAlias = None __requireFlags = None defaultCmd : str = \"\" defaultKey : str = \"\" defaultFlags : str = \"\" defaultKwargs : dict = {} defaultWait : int = 120 def __init__ ( self , * args , ** kwargs ): try : super ( CommandModuleSettings , self ) . __init__ ( * args , ** kwargs ) except Exception : super ( CommandModuleSettings , self ) . __init__ () @property def useDefaultParsing ( self ) -> Optional [ bool ]: return self . __useDefaultParsing @useDefaultParsing . setter def useDefaultParsing ( self , value ): if value not in ( True , False , None ): raise AttributeError ( 'Default parsing must have a boolean value or None' ) self . __useDefaultParsing = value @useDefaultParsing . deleter def useDefaultParsing ( self ): self . __useDefaultParsing = self . useDefaultParsing = None @property def returnValueType ( self ) -> Optional [ bool ]: return self . __returnValueType @returnValueType . setter def returnValueType ( self , value ): if value not in ( str , None ): raise AttributeError ( ' %s is not a supported return value type' % value ) self . __returnValueType = self . returnValueType = value @returnValueType . deleter def returnValueType ( self ): self . __returnValueType = None @property def ignoreAlias ( self ) -> Optional [ bool ]: return self . __ignoreAlias @ignoreAlias . setter def ignoreAlias ( self , value ): if value not in ( True , False , None ): raise AttributeError ( 'Alias selection must have a boolean value or None' ) self . __ignoreAlias = value @ignoreAlias . deleter def ignoreAlias ( self ): self . __ignoreAlias = None @property def requireFlags ( self ) -> Optional [ bool ]: return self . __requireFlags @requireFlags . setter def requireFlags ( self , value ): if value not in ( True , False , None ): raise AttributeError ( 'Requiring flags must have a boolean value or None' ) self . __requireFlags = value @requireFlags . deleter def requireFlags ( self ): self . __requireFlags = None # noinspection PyProtectedMember,PyUnusedLocal,PyBroadException class GenericCmdModule ( CommandModuleSettings ): \"\"\" This class is inherited by all Command Modules. This is has a collection of helper functions including 'simpleExecute'. 'simpleExecute' is the most important method in this class as it how most commands get executed. It handles creating and binding CommandContainer objects as well as caching commands. It is always where certain parameters like 'rerun' are used. \"\"\" def __init__ ( self , tki , * args , ** kwargs ): super ( GenericCmdModule , self ) . __init__ ( * args , ** kwargs ) self . tki = tki self . _useDefaultParsing = self . useDefaultParsing self . _returnValueType = self . returnValueType def __call__ ( self , * args , ** kwargs ) -> Any : if kwargs . get ( 'wait' ) is not False : kwargs . update ({ 'wait' : kwargs . pop ( 'wait' , self . defaultWait ) or self . defaultWait }) return self . run ( * args , ** kwargs ) def run ( self , flags : Any = None , * args , ** kwargs ) -> Any : \"\"\" This method is often overridden by different command modules to follow particular behavior. This is the default behavior that expected. It attempts to use the 'defaultCmd', 'defaultKey' and 'defaultFlags' to create the command and run it. For example with the 'cat' module one could simply run cat.run('/etc/hosts') or because of the '__call__' magic method: cat('/etc/hosts'). - :param flags: Usually a dictionary or a string. This is suppose to follow the 'defaultCmd'. - :param args: (Passed to simpleExecute and possibly too CommandContainer) - :param kwargs: (Passed to simpleExecute and possibly too CommandContainer) - :return: This could be a CommandContainer or the results of the command depending on if the command has has finished. \"\"\" if isinstance ( flags , dict ): return self . simpleExecute ( command = flags , ** kwargs ) if flags is None and self . requireFlags : raise Exception ( \"The parameter 'flags' is required.\" ) if flags is None : newCmd = self . defaultCmd + self . defaultFlags elif ' %s ' in self . defaultFlags : newCmd = self . defaultCmd + self . defaultFlags % flags else : newCmd = self . defaultCmd + flags newKey = self . defaultKey if ' %s ' in newKey : newKey %= flags if not newKey : newKey = flags if 'postparser' in self . defaultFlags : if kwargs . get ( 'useDefaultParsing' ) or ( self . useDefaultParsing and 'useDefaultParsing' not in kwargs ): kwargs . update ( self . updatekwargs ( 'postparser' , self . defaultKwargs . get ( 'postparser' ), ** kwargs )) return self . simpleExecute ( command = { newKey : newCmd }, ** self . mergeKwargs ( kwargs , self . defaultKwargs )) def doesCommandExistPreParser ( self , * args , ** kwargs ) -> Optional [ bool ]: \"\"\" This uses a control flag PreParserStopOnFailure to stop the continued execution of the command. It assumes PreParserStopOnFailure is True. Set to false if you wish the command to continue. \"\"\" this = kwargs . get ( 'this' ) cmdExists = getattr ( getattr ( getattr ( getattr ( self , 'tki' , None ), 'modules' , None ), 'which' , None ), 'doesCommandExist' , dummy_func )( kwargs . get ( 'executable' , getattr ( this , 'commandUnparsed' , '' ) . strip () . split ()[ 0 ])) if kwargs . get ( 'PreParserStopOnFailure' , True ) and cmdExists is False : this . setFailure ( cmdExists ) return cmdExists def doesFileExistRequirement ( self , filename , * args , ** kwargs ) -> bool : return getattr ( getattr ( getattr ( getattr ( self , 'tki' , None ), 'modules' , None ), 'll' , None ), 'fileExist' , dummy_func )( filename , rerun = True , wait = True ) def verifyNeedForRun ( self , ** kwargs ) -> None : \"\"\" This is a helper method that can be used to see if the CommandModule needs to be ran again. It checks with a 'if not self' first which is useful if the CommandModule has inherited the BashParser class. It then checks to see if the 'rerun' parameter was passed True. If it determines that it needs to run again then it runs 'self(**kwargs)'. - :param kwargs: Passed to the '__call__' magic method if the CommandModule needs to be ran again. - :return: None \"\"\" if not self or kwargs . get ( 'rerun' , False ): self ( ** kwargs ) def simpleExecute ( self , command : Union [ str , dict ], * args , ** kwargs ) -> Any : \"\"\" This is a wrapper for the simpleExecutor static method. This method simply injects self as the binding object parameter for simpleExecutor. NOTE: If you execute a command with the flag 'threading=True' and then execute the command with the flag 'threading=False' the results will come back as 'None' unless you place a wait in it. - :param command: String or dictionary that is passed to simpleExecutor. \"\"\" if not self . tki : return False kwargs = GenericCmdModule . mergeKwargs ( kwargs , { 'ignoreAlias' : self . ignoreAlias , 'tki' : self . tki }) return GenericCmdModule . simpleExecutor ( self , command , * args , ** kwargs ) @staticmethod @executionDecorator def simpleExecutor ( bindingObject : Any , command : Union [ str , dict ], commandKey : Optional [ str ] = None , rerun : bool = False , wait = 0 , ** kwargs ) -> Any : \"\"\" Run a single command and create the command container object \"\"\" log . info ( f 'Using simpleExecutor for command: { command } , ' f 'commandKey = { commandKey } , rerun = { rerun } , wait = { wait } ' ) tki = kwargs . get ( 'tki' ) if bindingObject is None or not tki : return False wait = GenericCmdModule . _waitCheck ( wait ) commandKey = GenericCmdModule . cmdObjBinder ( command , commandKey , bindingObject , rerun , ** kwargs ) if type ( commandKey ) is not str : tki . execute ( commandKey , ** kwargs ) return GenericCmdModule . _waitHelper ( commandKey , wait ) event = kwargs . get ( 'event' , None ) or None if getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . complete : if event and not getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . hasEvent ( event ): event . set () if wait is False : return getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) return getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . results if event and hasattr ( bindingObject , commandKey ): getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . addEvent ( event ) return GenericCmdModule . _waitHelper ( getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ), wait ) @staticmethod def cmdObjBinder ( command , commandKey = None , bindTo = None , rerun = False , ** kwargs ) \\ -> Union [ str , CommandContainers . CommandContainer ]: commandKey = CommandContainers . CommandContainer . _parseCommandInput ( command , commandKey ) if bindTo is not None and ( rerun or not hasattr ( bindTo , commandKey )): if isinstance ( command , CommandContainers . CommandContainer ): setattr ( bindTo , commandKey , command ) else : setattr ( bindTo , commandKey , CommandContainers . CommandContainer ( command = command , commandKey = commandKey , ** kwargs )) return getattr ( bindTo , commandKey ) return commandKey @staticmethod def buildFuncWithArgs ( func : Callable , * args , ** kwargs ) -> partial : \"\"\" build a functool partial object with the func variable as the callable function \"\"\" if args is None : args = () if kwargs is None : kwargs = {} return partial ( func , * args , ** kwargs ) @staticmethod def sanitizeFilename ( filename : str ) -> str : \"\"\" A wrapper for the 'CommandContainers.CommandContainer._parseCommandInput' staticmethod \"\"\" return CommandContainers . CommandContainer . _parseCommandInput ( filename ) # noinspection PyMethodMayBeStatic def _formatOutput ( self , output = None ): \"\"\" This is a stand in method \"\"\" return output # noinspection PyUnusedLocal @staticmethod def _formatExitCode ( results : str , this : CommandContainers . CommandContainer , * args , ** kwargs ) -> bool : \"\"\" Use for simpleExecute or command modules to evaluate the exit status of the command ($command; echo $?)\"\"\" try : if results [ - 1 :] == '0' : return True this . rawResults = results [: - 2 ] # remove the newline too except Exception : this . rawResults = results return False @staticmethod def _formatExitCodeStr ( results : str , this : CommandContainers . CommandContainer , * args , ** kwargs ) -> str : \"\"\" Use for simpleExecute or command modules to return only the exit status of the command (echo $?) \"\"\" if GenericCmdModule . _formatExitCode ( results , this , * args , ** kwargs ): return results [: - 2 ] # remove the newline too return \"\" @staticmethod def _waitHelper ( cmdObj : Optional [ CommandContainers . CommandContainer ] = None , wait : Union [ int , float ] = 0 ) -> Any : \"\"\" Used exclusively by the 'simpleExecutor' staticmethod \"\"\" if wait is False : return cmdObj return cmdObj . waitForResults ( wait = GenericCmdModule . _waitCheck ( wait )) @staticmethod def _waitCheck ( wait : Union [ int , float ] = 0 ) -> Optional [ Union [ int , float ]]: \"\"\" Used exclusively by the 'simpleExecutor' staticmethod \"\"\" if not isinstance ( wait , ( int , float )) or wait < 0 : if wait is True : return None return 0 return wait @staticmethod def mergeKwargs ( parameterKwarg : dict , defaultKwarg : dict ) -> dict : \"\"\" merge kwargs with parameterKwarg taking priority over defaultKwarg \"\"\" return { ** defaultKwarg , ** parameterKwarg } @staticmethod def updatekwargs ( addToArg : Optional [ Hashable ] = None , addThese : Any = None , _forceFirst : bool = False , ** kwargs ) -> dict : \"\"\" This returns a dict that can be used to update kwargs. Only use if the value of the kwarg you want to update is a string, list, or dict. If a dict is passed this will assume that the value of the kwargs to update is also a dict \"\"\" if addToArg not in kwargs : return { addToArg : addThese } # copy to prevent updating pieces of the structure passed in such as lists and dicts try : newKwarg = copy ( kwargs . get ( addToArg )) # regular stuff, classes and instances except Exception : try : newKwarg = deepcopy ( kwargs . get ( addToArg )) # instance methods and such except Exception : newKwarg = kwargs . get ( addToArg ) # copying is not thread safe kwargs . pop ( addToArg ) # remove it if isinstance ( addThese , dict ): for addKey , addValue in addThese . items (): newKwarg [ addKey ] = addValue # maintain the order if required return { addToArg : newKwarg } if type ( addThese ) is not list : addThese = [ addThese ] if type ( newKwarg ) is not list : newKwarg = [ newKwarg ] for addThis in addThese : if _forceFirst : newKwarg . insert ( 0 , addThis ) else : newKwarg . append ( addThis ) return { addToArg : newKwarg } Variables log Functions executionDecorator def executionDecorator ( func ) View Source def executionDecorator(func): def runResultsValue(bindingObject, *args, * *kwargs): exeResults = func(bindingObject, *args, * *kwargs) if exeResults and getattr(bindingObject, 'returnValueType', None): return bindingObject.returnValueType(exeResults) return exeResults return runResultsValue Classes CommandModuleSettings class CommandModuleSettings ( * args , ** kwargs ) A list of variables that represent the settings of a Command Module and their default values. Also a collection of properties used for accessing and manipulating those settings. Descendants genericCmdModule.GenericCmdModule Class variables defaultCmd defaultFlags defaultKey defaultKwargs defaultWait Instance variables ignoreAlias requireFlags returnValueType useDefaultParsing GenericCmdModule class GenericCmdModule ( tki , * args , ** kwargs ) This class is inherited by all Command Modules. This is has a collection of helper functions including 'simpleExecute'. 'simpleExecute' is the most important method in this class as it how most commands get executed. It handles creating and binding CommandContainer objects as well as caching commands. It is always where certain parameters like 'rerun' are used. Ancestors (in MRO) genericCmdModule.CommandModuleSettings Class variables defaultCmd defaultFlags defaultKey defaultKwargs defaultWait Static methods buildFuncWithArgs def buildFuncWithArgs ( func : Callable , * args , ** kwargs ) -> functools . partial build a functool partial object with the func variable as the callable function View Source @ staticmethod def buildFuncWithArgs ( func : Callable , * args , ** kwargs ) -> partial : \"\"\" build a functool partial object with the func variable as the callable function \"\"\" if args is None : args = () if kwargs is None : kwargs = {} return partial ( func , * args , ** kwargs ) cmdObjBinder def cmdObjBinder ( command , commandKey = None , bindTo = None , rerun = False , ** kwargs ) -> Union [ str , LinuxModules . CommandContainers . CommandContainer ] View Source @staticmethod def cmdObjBinder ( command , commandKey = None , bindTo = None , rerun = False , ** kwargs ) \\ -> Union [ str, CommandContainers.CommandContainer ] : commandKey = CommandContainers . CommandContainer . _parseCommandInput ( command , commandKey ) if bindTo is not None and ( rerun or not hasattr ( bindTo , commandKey )) : if isinstance ( command , CommandContainers . CommandContainer ) : setattr ( bindTo , commandKey , command ) else : setattr ( bindTo , commandKey , CommandContainers . CommandContainer ( command = command , commandKey = commandKey , ** kwargs )) return getattr ( bindTo , commandKey ) return commandKey mergeKwargs def mergeKwargs ( parameterKwarg : dict , defaultKwarg : dict ) -> dict merge kwargs with parameterKwarg taking priority over defaultKwarg View Source @staticmethod def mergeKwargs ( parameterKwarg : dict , defaultKwarg : dict ) -> dict : \"\"\" merge kwargs with parameterKwarg taking priority over defaultKwarg \"\"\" return { ** defaultKwarg , ** parameterKwarg } sanitizeFilename def sanitizeFilename ( filename : str ) -> str A wrapper for the 'CommandContainers.CommandContainer._parseCommandInput' staticmethod View Source @staticmethod def sanitizeFilename ( filename : str ) -> str : \"\"\" A wrapper for the 'CommandContainers.CommandContainer._parseCommandInput' staticmethod \"\"\" return CommandContainers . CommandContainer . _parseCommandInput ( filename ) simpleExecutor def simpleExecutor ( bindingObject , * args , ** kwargs ) View Source def runResultsValue(bindingObject, *args, * *kwargs): exeResults = func(bindingObject, *args, * *kwargs) if exeResults and getattr(bindingObject, 'returnValueType', None): return bindingObject.returnValueType(exeResults) return exeResults updatekwargs def updatekwargs ( addToArg : Optional [ Hashable ] = None , addThese : Any = None , _forceFirst : bool = False , ** kwargs ) -> dict This returns a dict that can be used to update kwargs. Only use if the value of the kwarg you want to update is a string, list, or dict. If a dict is passed this will assume that the value of the kwargs to update is also a dict View Source @staticmethod def updatekwargs ( addToArg : Optional [ Hashable ] = None , addThese : Any = None , _forceFirst : bool = False , ** kwargs ) -> dict : \"\"\" This returns a dict that can be used to update kwargs. Only use if the value of the kwarg you want to update is a string, list, or dict. If a dict is passed this will assume that the value of the kwargs to update is also a dict \"\"\" if addToArg not in kwargs : return { addToArg : addThese } # copy to prevent updating pieces of the structure passed in such as lists and dicts try : newKwarg = copy ( kwargs . get ( addToArg )) # regular stuff , classes and instances except Exception : try : newKwarg = deepcopy ( kwargs . get ( addToArg )) # instance methods and such except Exception : newKwarg = kwargs . get ( addToArg ) # copying is not thread safe kwargs . pop ( addToArg ) # remove it if isinstance ( addThese , dict ) : for addKey , addValue in addThese . items () : newKwarg [ addKey ] = addValue # maintain the order if required return { addToArg : newKwarg } if type ( addThese ) is not list : addThese = [ addThese ] if type ( newKwarg ) is not list : newKwarg = [ newKwarg ] for addThis in addThese : if _forceFirst : newKwarg . insert ( 0 , addThis ) else : newKwarg . append ( addThis ) return { addToArg : newKwarg } Instance variables ignoreAlias requireFlags returnValueType useDefaultParsing Methods doesCommandExistPreParser def doesCommandExistPreParser ( self , * args , ** kwargs ) -> Optional [ bool ] This uses a control flag PreParserStopOnFailure to stop the continued execution of the command. It assumes PreParserStopOnFailure is True. Set to false if you wish the command to continue. View Source def doesCommandExistPreParser ( self , * args , ** kwargs ) -> Optional [ bool ] : \"\"\" This uses a control flag PreParserStopOnFailure to stop the continued execution of the command. It assumes PreParserStopOnFailure is True. Set to false if you wish the command to continue. \"\"\" this = kwargs . get ( 'this' ) cmdExists = getattr ( getattr ( getattr ( getattr ( self , 'tki' , None ), 'modules' , None ), 'which' , None ), 'doesCommandExist' , dummy_func )( kwargs . get ( 'executable' , getattr ( this , 'commandUnparsed' , '' ) . strip (). split () [ 0 ] )) if kwargs . get ( 'PreParserStopOnFailure' , True ) and cmdExists is False : this . setFailure ( cmdExists ) return cmdExists doesFileExistRequirement def doesFileExistRequirement ( self , filename , * args , ** kwargs ) -> bool View Source def doesFileExistRequirement(self, filename, *args, * *kwargs) -> bool: return getattr(getattr(getattr(getattr(self, 'tki', None), 'modules', None), 'll', None), 'fileExist', dummy_func)(filename, rerun=True, wait=True) run def run ( self , flags : Any = None , * args , ** kwargs ) -> Any This method is often overridden by different command modules to follow particular behavior. This is the default behavior that expected. It attempts to use the 'defaultCmd', 'defaultKey' and 'defaultFlags' to create the command and run it. For example with the 'cat' module one could simply run cat.run('/etc/hosts') or because of the ' call ' magic method: cat('/etc/hosts'). :param flags: Usually a dictionary or a string. This is suppose to follow the 'defaultCmd'. :param args: (Passed to simpleExecute and possibly too CommandContainer) :param kwargs: (Passed to simpleExecute and possibly too CommandContainer) :return: This could be a CommandContainer or the results of the command depending on if the command has has finished. View Source def run ( self , flags : Any = None , * args , ** kwargs ) -> Any : \"\"\" This method is often overridden by different command modules to follow particular behavior. This is the default behavior that expected. It attempts to use the 'defaultCmd', 'defaultKey' and 'defaultFlags' to create the command and run it. For example with the 'cat' module one could simply run cat.run('/etc/hosts') or because of the '__call__' magic method: cat('/etc/hosts'). - :param flags: Usually a dictionary or a string. This is suppose to follow the 'defaultCmd'. - :param args: (Passed to simpleExecute and possibly too CommandContainer) - :param kwargs: (Passed to simpleExecute and possibly too CommandContainer) - :return: This could be a CommandContainer or the results of the command depending on if the command has has finished. \"\"\" if isinstance ( flags , dict ): return self . simpleExecute ( command = flags , ** kwargs ) if flags is None and self . requireFlags : raise Exception ( \"The parameter 'flags' is required.\" ) if flags is None : newCmd = self . defaultCmd + self . defaultFlags elif ' % s ' in self . defaultFlags : newCmd = self . defaultCmd + self . defaultFlags % flags else : newCmd = self . defaultCmd + flags newKey = self . defaultKey if ' % s ' in newKey : newKey %= flags if not newKey : newKey = flags if ' postparser ' in self . defaultFlags : if kwargs . get ( ' useDefaultParsing ' ) or ( self . useDefaultParsing and ' useDefaultParsing ' not in kwargs ): kwargs . update ( self . updatekwargs ( ' postparser ' , self . defaultKwargs . get ( ' postparser ' ), ** kwargs )) return self . simpleExecute ( command ={ newKey : newCmd }, ** self . mergeKwargs ( kwargs , self . defaultKwargs )) simpleExecute def simpleExecute ( self , command : Union [ str , dict ], * args , ** kwargs ) -> Any This is a wrapper for the simpleExecutor static method. This method simply injects self as the binding object parameter for simpleExecutor. NOTE: If you execute a command with the flag 'threading=True' and then execute the command with the flag 'threading=False' the results will come back as 'None' unless you place a wait in it. :param command: String or dictionary that is passed to simpleExecutor. View Source def simpleExecute ( self , command : Union [ str , dict ], * args , ** kwargs ) -> Any : \"\"\" This is a wrapper for the simpleExecutor static method. This method simply injects self as the binding object parameter for simpleExecutor. NOTE: If you execute a command with the flag 'threading=True' and then execute the command with the flag 'threading=False' the results will come back as 'None' unless you place a wait in it. - :param command: String or dictionary that is passed to simpleExecutor. \"\"\" if not self . tki : return False kwargs = GenericCmdModule . mergeKwargs ( kwargs , { ' ignoreAlias ' : self . ignoreAlias , ' tki ' : self . tki }) return GenericCmdModule . simpleExecutor ( self , command , * args , ** kwargs ) verifyNeedForRun def verifyNeedForRun ( self , ** kwargs ) -> None This is a helper method that can be used to see if the CommandModule needs to be ran again. It checks with a 'if not self' first which is useful if the CommandModule has inherited the BashParser class. It then checks to see if the 'rerun' parameter was passed True. If it determines that it needs to run again then it runs 'self(**kwargs)'. :param kwargs: Passed to the ' call ' magic method if the CommandModule needs to be ran again. :return: None View Source def verifyNeedForRun(self, **kwargs) -> None: \"\"\" This is a helper method that can be used to see if the CommandModule needs to be ran again. It checks with a 'if not self' first which is useful if the CommandModule has inherited the BashParser class. It then checks to see if the 'rerun' parameter was passed True. If it determines that it needs to run again then it runs 'self(**kwargs)'. - :param kwargs: Passed to the '__call__' magic method if the CommandModule needs to be ran again. - :return: None \"\"\" if not self or kwargs.get('rerun', False): self(**kwargs)","title":"Genericcmdmodule"},{"location":"reference/genericCmdModule/#module-genericcmdmodule","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Ryan Henrichson, Timothy Nodine # Version: 2.0 # Date: 06/17/17 # Description: This is the foundation for all Command Modules. It is a set of classes that are inherited by all # CommandModules import logging from functools import partial from copy import copy , deepcopy from LinuxModules import CommandContainers from libs import dummy_func from typing import Any , Optional , Union , Hashable , Callable log = logging . getLogger ( 'GenericCommandModule' ) def executionDecorator ( func ): def runResultsValue ( bindingObject , * args , ** kwargs ): exeResults = func ( bindingObject , * args , ** kwargs ) if exeResults and getattr ( bindingObject , 'returnValueType' , None ): return bindingObject . returnValueType ( exeResults ) return exeResults return runResultsValue # noinspection PyBroadException class CommandModuleSettings : \"\"\" A list of variables that represent the settings of a Command Module and their default values. Also a collection of properties used for accessing and manipulating those settings. \"\"\" __useDefaultParsing = None __returnValueType = None __ignoreAlias = None __requireFlags = None defaultCmd : str = \"\" defaultKey : str = \"\" defaultFlags : str = \"\" defaultKwargs : dict = {} defaultWait : int = 120 def __init__ ( self , * args , ** kwargs ): try : super ( CommandModuleSettings , self ) . __init__ ( * args , ** kwargs ) except Exception : super ( CommandModuleSettings , self ) . __init__ () @property def useDefaultParsing ( self ) -> Optional [ bool ]: return self . __useDefaultParsing @useDefaultParsing . setter def useDefaultParsing ( self , value ): if value not in ( True , False , None ): raise AttributeError ( 'Default parsing must have a boolean value or None' ) self . __useDefaultParsing = value @useDefaultParsing . deleter def useDefaultParsing ( self ): self . __useDefaultParsing = self . useDefaultParsing = None @property def returnValueType ( self ) -> Optional [ bool ]: return self . __returnValueType @returnValueType . setter def returnValueType ( self , value ): if value not in ( str , None ): raise AttributeError ( ' %s is not a supported return value type' % value ) self . __returnValueType = self . returnValueType = value @returnValueType . deleter def returnValueType ( self ): self . __returnValueType = None @property def ignoreAlias ( self ) -> Optional [ bool ]: return self . __ignoreAlias @ignoreAlias . setter def ignoreAlias ( self , value ): if value not in ( True , False , None ): raise AttributeError ( 'Alias selection must have a boolean value or None' ) self . __ignoreAlias = value @ignoreAlias . deleter def ignoreAlias ( self ): self . __ignoreAlias = None @property def requireFlags ( self ) -> Optional [ bool ]: return self . __requireFlags @requireFlags . setter def requireFlags ( self , value ): if value not in ( True , False , None ): raise AttributeError ( 'Requiring flags must have a boolean value or None' ) self . __requireFlags = value @requireFlags . deleter def requireFlags ( self ): self . __requireFlags = None # noinspection PyProtectedMember,PyUnusedLocal,PyBroadException class GenericCmdModule ( CommandModuleSettings ): \"\"\" This class is inherited by all Command Modules. This is has a collection of helper functions including 'simpleExecute'. 'simpleExecute' is the most important method in this class as it how most commands get executed. It handles creating and binding CommandContainer objects as well as caching commands. It is always where certain parameters like 'rerun' are used. \"\"\" def __init__ ( self , tki , * args , ** kwargs ): super ( GenericCmdModule , self ) . __init__ ( * args , ** kwargs ) self . tki = tki self . _useDefaultParsing = self . useDefaultParsing self . _returnValueType = self . returnValueType def __call__ ( self , * args , ** kwargs ) -> Any : if kwargs . get ( 'wait' ) is not False : kwargs . update ({ 'wait' : kwargs . pop ( 'wait' , self . defaultWait ) or self . defaultWait }) return self . run ( * args , ** kwargs ) def run ( self , flags : Any = None , * args , ** kwargs ) -> Any : \"\"\" This method is often overridden by different command modules to follow particular behavior. This is the default behavior that expected. It attempts to use the 'defaultCmd', 'defaultKey' and 'defaultFlags' to create the command and run it. For example with the 'cat' module one could simply run cat.run('/etc/hosts') or because of the '__call__' magic method: cat('/etc/hosts'). - :param flags: Usually a dictionary or a string. This is suppose to follow the 'defaultCmd'. - :param args: (Passed to simpleExecute and possibly too CommandContainer) - :param kwargs: (Passed to simpleExecute and possibly too CommandContainer) - :return: This could be a CommandContainer or the results of the command depending on if the command has has finished. \"\"\" if isinstance ( flags , dict ): return self . simpleExecute ( command = flags , ** kwargs ) if flags is None and self . requireFlags : raise Exception ( \"The parameter 'flags' is required.\" ) if flags is None : newCmd = self . defaultCmd + self . defaultFlags elif ' %s ' in self . defaultFlags : newCmd = self . defaultCmd + self . defaultFlags % flags else : newCmd = self . defaultCmd + flags newKey = self . defaultKey if ' %s ' in newKey : newKey %= flags if not newKey : newKey = flags if 'postparser' in self . defaultFlags : if kwargs . get ( 'useDefaultParsing' ) or ( self . useDefaultParsing and 'useDefaultParsing' not in kwargs ): kwargs . update ( self . updatekwargs ( 'postparser' , self . defaultKwargs . get ( 'postparser' ), ** kwargs )) return self . simpleExecute ( command = { newKey : newCmd }, ** self . mergeKwargs ( kwargs , self . defaultKwargs )) def doesCommandExistPreParser ( self , * args , ** kwargs ) -> Optional [ bool ]: \"\"\" This uses a control flag PreParserStopOnFailure to stop the continued execution of the command. It assumes PreParserStopOnFailure is True. Set to false if you wish the command to continue. \"\"\" this = kwargs . get ( 'this' ) cmdExists = getattr ( getattr ( getattr ( getattr ( self , 'tki' , None ), 'modules' , None ), 'which' , None ), 'doesCommandExist' , dummy_func )( kwargs . get ( 'executable' , getattr ( this , 'commandUnparsed' , '' ) . strip () . split ()[ 0 ])) if kwargs . get ( 'PreParserStopOnFailure' , True ) and cmdExists is False : this . setFailure ( cmdExists ) return cmdExists def doesFileExistRequirement ( self , filename , * args , ** kwargs ) -> bool : return getattr ( getattr ( getattr ( getattr ( self , 'tki' , None ), 'modules' , None ), 'll' , None ), 'fileExist' , dummy_func )( filename , rerun = True , wait = True ) def verifyNeedForRun ( self , ** kwargs ) -> None : \"\"\" This is a helper method that can be used to see if the CommandModule needs to be ran again. It checks with a 'if not self' first which is useful if the CommandModule has inherited the BashParser class. It then checks to see if the 'rerun' parameter was passed True. If it determines that it needs to run again then it runs 'self(**kwargs)'. - :param kwargs: Passed to the '__call__' magic method if the CommandModule needs to be ran again. - :return: None \"\"\" if not self or kwargs . get ( 'rerun' , False ): self ( ** kwargs ) def simpleExecute ( self , command : Union [ str , dict ], * args , ** kwargs ) -> Any : \"\"\" This is a wrapper for the simpleExecutor static method. This method simply injects self as the binding object parameter for simpleExecutor. NOTE: If you execute a command with the flag 'threading=True' and then execute the command with the flag 'threading=False' the results will come back as 'None' unless you place a wait in it. - :param command: String or dictionary that is passed to simpleExecutor. \"\"\" if not self . tki : return False kwargs = GenericCmdModule . mergeKwargs ( kwargs , { 'ignoreAlias' : self . ignoreAlias , 'tki' : self . tki }) return GenericCmdModule . simpleExecutor ( self , command , * args , ** kwargs ) @staticmethod @executionDecorator def simpleExecutor ( bindingObject : Any , command : Union [ str , dict ], commandKey : Optional [ str ] = None , rerun : bool = False , wait = 0 , ** kwargs ) -> Any : \"\"\" Run a single command and create the command container object \"\"\" log . info ( f 'Using simpleExecutor for command: { command } , ' f 'commandKey = { commandKey } , rerun = { rerun } , wait = { wait } ' ) tki = kwargs . get ( 'tki' ) if bindingObject is None or not tki : return False wait = GenericCmdModule . _waitCheck ( wait ) commandKey = GenericCmdModule . cmdObjBinder ( command , commandKey , bindingObject , rerun , ** kwargs ) if type ( commandKey ) is not str : tki . execute ( commandKey , ** kwargs ) return GenericCmdModule . _waitHelper ( commandKey , wait ) event = kwargs . get ( 'event' , None ) or None if getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . complete : if event and not getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . hasEvent ( event ): event . set () if wait is False : return getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) return getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . results if event and hasattr ( bindingObject , commandKey ): getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ) . addEvent ( event ) return GenericCmdModule . _waitHelper ( getattr ( bindingObject , commandKey , CommandContainers . CommandContainer ), wait ) @staticmethod def cmdObjBinder ( command , commandKey = None , bindTo = None , rerun = False , ** kwargs ) \\ -> Union [ str , CommandContainers . CommandContainer ]: commandKey = CommandContainers . CommandContainer . _parseCommandInput ( command , commandKey ) if bindTo is not None and ( rerun or not hasattr ( bindTo , commandKey )): if isinstance ( command , CommandContainers . CommandContainer ): setattr ( bindTo , commandKey , command ) else : setattr ( bindTo , commandKey , CommandContainers . CommandContainer ( command = command , commandKey = commandKey , ** kwargs )) return getattr ( bindTo , commandKey ) return commandKey @staticmethod def buildFuncWithArgs ( func : Callable , * args , ** kwargs ) -> partial : \"\"\" build a functool partial object with the func variable as the callable function \"\"\" if args is None : args = () if kwargs is None : kwargs = {} return partial ( func , * args , ** kwargs ) @staticmethod def sanitizeFilename ( filename : str ) -> str : \"\"\" A wrapper for the 'CommandContainers.CommandContainer._parseCommandInput' staticmethod \"\"\" return CommandContainers . CommandContainer . _parseCommandInput ( filename ) # noinspection PyMethodMayBeStatic def _formatOutput ( self , output = None ): \"\"\" This is a stand in method \"\"\" return output # noinspection PyUnusedLocal @staticmethod def _formatExitCode ( results : str , this : CommandContainers . CommandContainer , * args , ** kwargs ) -> bool : \"\"\" Use for simpleExecute or command modules to evaluate the exit status of the command ($command; echo $?)\"\"\" try : if results [ - 1 :] == '0' : return True this . rawResults = results [: - 2 ] # remove the newline too except Exception : this . rawResults = results return False @staticmethod def _formatExitCodeStr ( results : str , this : CommandContainers . CommandContainer , * args , ** kwargs ) -> str : \"\"\" Use for simpleExecute or command modules to return only the exit status of the command (echo $?) \"\"\" if GenericCmdModule . _formatExitCode ( results , this , * args , ** kwargs ): return results [: - 2 ] # remove the newline too return \"\" @staticmethod def _waitHelper ( cmdObj : Optional [ CommandContainers . CommandContainer ] = None , wait : Union [ int , float ] = 0 ) -> Any : \"\"\" Used exclusively by the 'simpleExecutor' staticmethod \"\"\" if wait is False : return cmdObj return cmdObj . waitForResults ( wait = GenericCmdModule . _waitCheck ( wait )) @staticmethod def _waitCheck ( wait : Union [ int , float ] = 0 ) -> Optional [ Union [ int , float ]]: \"\"\" Used exclusively by the 'simpleExecutor' staticmethod \"\"\" if not isinstance ( wait , ( int , float )) or wait < 0 : if wait is True : return None return 0 return wait @staticmethod def mergeKwargs ( parameterKwarg : dict , defaultKwarg : dict ) -> dict : \"\"\" merge kwargs with parameterKwarg taking priority over defaultKwarg \"\"\" return { ** defaultKwarg , ** parameterKwarg } @staticmethod def updatekwargs ( addToArg : Optional [ Hashable ] = None , addThese : Any = None , _forceFirst : bool = False , ** kwargs ) -> dict : \"\"\" This returns a dict that can be used to update kwargs. Only use if the value of the kwarg you want to update is a string, list, or dict. If a dict is passed this will assume that the value of the kwargs to update is also a dict \"\"\" if addToArg not in kwargs : return { addToArg : addThese } # copy to prevent updating pieces of the structure passed in such as lists and dicts try : newKwarg = copy ( kwargs . get ( addToArg )) # regular stuff, classes and instances except Exception : try : newKwarg = deepcopy ( kwargs . get ( addToArg )) # instance methods and such except Exception : newKwarg = kwargs . get ( addToArg ) # copying is not thread safe kwargs . pop ( addToArg ) # remove it if isinstance ( addThese , dict ): for addKey , addValue in addThese . items (): newKwarg [ addKey ] = addValue # maintain the order if required return { addToArg : newKwarg } if type ( addThese ) is not list : addThese = [ addThese ] if type ( newKwarg ) is not list : newKwarg = [ newKwarg ] for addThis in addThese : if _forceFirst : newKwarg . insert ( 0 , addThis ) else : newKwarg . append ( addThis ) return { addToArg : newKwarg }","title":"Module genericCmdModule"},{"location":"reference/genericCmdModule/#variables","text":"log","title":"Variables"},{"location":"reference/genericCmdModule/#functions","text":"","title":"Functions"},{"location":"reference/genericCmdModule/#executiondecorator","text":"def executionDecorator ( func ) View Source def executionDecorator(func): def runResultsValue(bindingObject, *args, * *kwargs): exeResults = func(bindingObject, *args, * *kwargs) if exeResults and getattr(bindingObject, 'returnValueType', None): return bindingObject.returnValueType(exeResults) return exeResults return runResultsValue","title":"executionDecorator"},{"location":"reference/genericCmdModule/#classes","text":"","title":"Classes"},{"location":"reference/genericCmdModule/#commandmodulesettings","text":"class CommandModuleSettings ( * args , ** kwargs ) A list of variables that represent the settings of a Command Module and their default values. Also a collection of properties used for accessing and manipulating those settings.","title":"CommandModuleSettings"},{"location":"reference/genericCmdModule/#descendants","text":"genericCmdModule.GenericCmdModule","title":"Descendants"},{"location":"reference/genericCmdModule/#class-variables","text":"defaultCmd defaultFlags defaultKey defaultKwargs defaultWait","title":"Class variables"},{"location":"reference/genericCmdModule/#instance-variables","text":"ignoreAlias requireFlags returnValueType useDefaultParsing","title":"Instance variables"},{"location":"reference/genericCmdModule/#genericcmdmodule","text":"class GenericCmdModule ( tki , * args , ** kwargs ) This class is inherited by all Command Modules. This is has a collection of helper functions including 'simpleExecute'. 'simpleExecute' is the most important method in this class as it how most commands get executed. It handles creating and binding CommandContainer objects as well as caching commands. It is always where certain parameters like 'rerun' are used.","title":"GenericCmdModule"},{"location":"reference/genericCmdModule/#ancestors-in-mro","text":"genericCmdModule.CommandModuleSettings","title":"Ancestors (in MRO)"},{"location":"reference/genericCmdModule/#class-variables_1","text":"defaultCmd defaultFlags defaultKey defaultKwargs defaultWait","title":"Class variables"},{"location":"reference/genericCmdModule/#static-methods","text":"","title":"Static methods"},{"location":"reference/genericCmdModule/#buildfuncwithargs","text":"def buildFuncWithArgs ( func : Callable , * args , ** kwargs ) -> functools . partial build a functool partial object with the func variable as the callable function View Source @ staticmethod def buildFuncWithArgs ( func : Callable , * args , ** kwargs ) -> partial : \"\"\" build a functool partial object with the func variable as the callable function \"\"\" if args is None : args = () if kwargs is None : kwargs = {} return partial ( func , * args , ** kwargs )","title":"buildFuncWithArgs"},{"location":"reference/genericCmdModule/#cmdobjbinder","text":"def cmdObjBinder ( command , commandKey = None , bindTo = None , rerun = False , ** kwargs ) -> Union [ str , LinuxModules . CommandContainers . CommandContainer ] View Source @staticmethod def cmdObjBinder ( command , commandKey = None , bindTo = None , rerun = False , ** kwargs ) \\ -> Union [ str, CommandContainers.CommandContainer ] : commandKey = CommandContainers . CommandContainer . _parseCommandInput ( command , commandKey ) if bindTo is not None and ( rerun or not hasattr ( bindTo , commandKey )) : if isinstance ( command , CommandContainers . CommandContainer ) : setattr ( bindTo , commandKey , command ) else : setattr ( bindTo , commandKey , CommandContainers . CommandContainer ( command = command , commandKey = commandKey , ** kwargs )) return getattr ( bindTo , commandKey ) return commandKey","title":"cmdObjBinder"},{"location":"reference/genericCmdModule/#mergekwargs","text":"def mergeKwargs ( parameterKwarg : dict , defaultKwarg : dict ) -> dict merge kwargs with parameterKwarg taking priority over defaultKwarg View Source @staticmethod def mergeKwargs ( parameterKwarg : dict , defaultKwarg : dict ) -> dict : \"\"\" merge kwargs with parameterKwarg taking priority over defaultKwarg \"\"\" return { ** defaultKwarg , ** parameterKwarg }","title":"mergeKwargs"},{"location":"reference/genericCmdModule/#sanitizefilename","text":"def sanitizeFilename ( filename : str ) -> str A wrapper for the 'CommandContainers.CommandContainer._parseCommandInput' staticmethod View Source @staticmethod def sanitizeFilename ( filename : str ) -> str : \"\"\" A wrapper for the 'CommandContainers.CommandContainer._parseCommandInput' staticmethod \"\"\" return CommandContainers . CommandContainer . _parseCommandInput ( filename )","title":"sanitizeFilename"},{"location":"reference/genericCmdModule/#simpleexecutor","text":"def simpleExecutor ( bindingObject , * args , ** kwargs ) View Source def runResultsValue(bindingObject, *args, * *kwargs): exeResults = func(bindingObject, *args, * *kwargs) if exeResults and getattr(bindingObject, 'returnValueType', None): return bindingObject.returnValueType(exeResults) return exeResults","title":"simpleExecutor"},{"location":"reference/genericCmdModule/#updatekwargs","text":"def updatekwargs ( addToArg : Optional [ Hashable ] = None , addThese : Any = None , _forceFirst : bool = False , ** kwargs ) -> dict This returns a dict that can be used to update kwargs. Only use if the value of the kwarg you want to update is a string, list, or dict. If a dict is passed this will assume that the value of the kwargs to update is also a dict View Source @staticmethod def updatekwargs ( addToArg : Optional [ Hashable ] = None , addThese : Any = None , _forceFirst : bool = False , ** kwargs ) -> dict : \"\"\" This returns a dict that can be used to update kwargs. Only use if the value of the kwarg you want to update is a string, list, or dict. If a dict is passed this will assume that the value of the kwargs to update is also a dict \"\"\" if addToArg not in kwargs : return { addToArg : addThese } # copy to prevent updating pieces of the structure passed in such as lists and dicts try : newKwarg = copy ( kwargs . get ( addToArg )) # regular stuff , classes and instances except Exception : try : newKwarg = deepcopy ( kwargs . get ( addToArg )) # instance methods and such except Exception : newKwarg = kwargs . get ( addToArg ) # copying is not thread safe kwargs . pop ( addToArg ) # remove it if isinstance ( addThese , dict ) : for addKey , addValue in addThese . items () : newKwarg [ addKey ] = addValue # maintain the order if required return { addToArg : newKwarg } if type ( addThese ) is not list : addThese = [ addThese ] if type ( newKwarg ) is not list : newKwarg = [ newKwarg ] for addThis in addThese : if _forceFirst : newKwarg . insert ( 0 , addThis ) else : newKwarg . append ( addThis ) return { addToArg : newKwarg }","title":"updatekwargs"},{"location":"reference/genericCmdModule/#instance-variables_1","text":"ignoreAlias requireFlags returnValueType useDefaultParsing","title":"Instance variables"},{"location":"reference/genericCmdModule/#methods","text":"","title":"Methods"},{"location":"reference/genericCmdModule/#doescommandexistpreparser","text":"def doesCommandExistPreParser ( self , * args , ** kwargs ) -> Optional [ bool ] This uses a control flag PreParserStopOnFailure to stop the continued execution of the command. It assumes PreParserStopOnFailure is True. Set to false if you wish the command to continue. View Source def doesCommandExistPreParser ( self , * args , ** kwargs ) -> Optional [ bool ] : \"\"\" This uses a control flag PreParserStopOnFailure to stop the continued execution of the command. It assumes PreParserStopOnFailure is True. Set to false if you wish the command to continue. \"\"\" this = kwargs . get ( 'this' ) cmdExists = getattr ( getattr ( getattr ( getattr ( self , 'tki' , None ), 'modules' , None ), 'which' , None ), 'doesCommandExist' , dummy_func )( kwargs . get ( 'executable' , getattr ( this , 'commandUnparsed' , '' ) . strip (). split () [ 0 ] )) if kwargs . get ( 'PreParserStopOnFailure' , True ) and cmdExists is False : this . setFailure ( cmdExists ) return cmdExists","title":"doesCommandExistPreParser"},{"location":"reference/genericCmdModule/#doesfileexistrequirement","text":"def doesFileExistRequirement ( self , filename , * args , ** kwargs ) -> bool View Source def doesFileExistRequirement(self, filename, *args, * *kwargs) -> bool: return getattr(getattr(getattr(getattr(self, 'tki', None), 'modules', None), 'll', None), 'fileExist', dummy_func)(filename, rerun=True, wait=True)","title":"doesFileExistRequirement"},{"location":"reference/genericCmdModule/#run","text":"def run ( self , flags : Any = None , * args , ** kwargs ) -> Any This method is often overridden by different command modules to follow particular behavior. This is the default behavior that expected. It attempts to use the 'defaultCmd', 'defaultKey' and 'defaultFlags' to create the command and run it. For example with the 'cat' module one could simply run cat.run('/etc/hosts') or because of the ' call ' magic method: cat('/etc/hosts'). :param flags: Usually a dictionary or a string. This is suppose to follow the 'defaultCmd'. :param args: (Passed to simpleExecute and possibly too CommandContainer) :param kwargs: (Passed to simpleExecute and possibly too CommandContainer) :return: This could be a CommandContainer or the results of the command depending on if the command has has finished. View Source def run ( self , flags : Any = None , * args , ** kwargs ) -> Any : \"\"\" This method is often overridden by different command modules to follow particular behavior. This is the default behavior that expected. It attempts to use the 'defaultCmd', 'defaultKey' and 'defaultFlags' to create the command and run it. For example with the 'cat' module one could simply run cat.run('/etc/hosts') or because of the '__call__' magic method: cat('/etc/hosts'). - :param flags: Usually a dictionary or a string. This is suppose to follow the 'defaultCmd'. - :param args: (Passed to simpleExecute and possibly too CommandContainer) - :param kwargs: (Passed to simpleExecute and possibly too CommandContainer) - :return: This could be a CommandContainer or the results of the command depending on if the command has has finished. \"\"\" if isinstance ( flags , dict ): return self . simpleExecute ( command = flags , ** kwargs ) if flags is None and self . requireFlags : raise Exception ( \"The parameter 'flags' is required.\" ) if flags is None : newCmd = self . defaultCmd + self . defaultFlags elif ' % s ' in self . defaultFlags : newCmd = self . defaultCmd + self . defaultFlags % flags else : newCmd = self . defaultCmd + flags newKey = self . defaultKey if ' % s ' in newKey : newKey %= flags if not newKey : newKey = flags if ' postparser ' in self . defaultFlags : if kwargs . get ( ' useDefaultParsing ' ) or ( self . useDefaultParsing and ' useDefaultParsing ' not in kwargs ): kwargs . update ( self . updatekwargs ( ' postparser ' , self . defaultKwargs . get ( ' postparser ' ), ** kwargs )) return self . simpleExecute ( command ={ newKey : newCmd }, ** self . mergeKwargs ( kwargs , self . defaultKwargs ))","title":"run"},{"location":"reference/genericCmdModule/#simpleexecute","text":"def simpleExecute ( self , command : Union [ str , dict ], * args , ** kwargs ) -> Any This is a wrapper for the simpleExecutor static method. This method simply injects self as the binding object parameter for simpleExecutor. NOTE: If you execute a command with the flag 'threading=True' and then execute the command with the flag 'threading=False' the results will come back as 'None' unless you place a wait in it. :param command: String or dictionary that is passed to simpleExecutor. View Source def simpleExecute ( self , command : Union [ str , dict ], * args , ** kwargs ) -> Any : \"\"\" This is a wrapper for the simpleExecutor static method. This method simply injects self as the binding object parameter for simpleExecutor. NOTE: If you execute a command with the flag 'threading=True' and then execute the command with the flag 'threading=False' the results will come back as 'None' unless you place a wait in it. - :param command: String or dictionary that is passed to simpleExecutor. \"\"\" if not self . tki : return False kwargs = GenericCmdModule . mergeKwargs ( kwargs , { ' ignoreAlias ' : self . ignoreAlias , ' tki ' : self . tki }) return GenericCmdModule . simpleExecutor ( self , command , * args , ** kwargs )","title":"simpleExecute"},{"location":"reference/genericCmdModule/#verifyneedforrun","text":"def verifyNeedForRun ( self , ** kwargs ) -> None This is a helper method that can be used to see if the CommandModule needs to be ran again. It checks with a 'if not self' first which is useful if the CommandModule has inherited the BashParser class. It then checks to see if the 'rerun' parameter was passed True. If it determines that it needs to run again then it runs 'self(**kwargs)'. :param kwargs: Passed to the ' call ' magic method if the CommandModule needs to be ran again. :return: None View Source def verifyNeedForRun(self, **kwargs) -> None: \"\"\" This is a helper method that can be used to see if the CommandModule needs to be ran again. It checks with a 'if not self' first which is useful if the CommandModule has inherited the BashParser class. It then checks to see if the 'rerun' parameter was passed True. If it determines that it needs to run again then it runs 'self(**kwargs)'. - :param kwargs: Passed to the '__call__' magic method if the CommandModule needs to be ran again. - :return: None \"\"\" if not self or kwargs.get('rerun', False): self(**kwargs)","title":"verifyNeedForRun"},{"location":"reference/ldtk/","text":"Module ldtk View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson, Timothy Nodine # Version: 1.0 # Date: 02/19/15 # Description: This is designed to be an interface between sshConnector and different Command Modules. The purpose of # this package is to create a sort of one-stop shop for programs to interact with modules and allow modules to easily # interact with each other. Simply passing the ToolKitInterface across to each module allows them to be able to see # each other. import logging import warnings from cryptography.utils import CryptographyDeprecationWarning warnings . filterwarnings ( 'ignore' , category = CryptographyDeprecationWarning ) import traceback from PyLinuxDiagnosticToolKit import find_modules from libs import ArgumentWrapper from libs.ArgumentWrapper import ArgumentParsers from LinuxModules.genericCmdModule import GenericCmdModule from LinuxModules.CommandContainers import CommandContainer from sshConnector.sshThreader import sshThreader as threadedSSH from sshConnector.sshLibs.SCPChannel import SCPChannel from sshConnector.sshLibs.SFTPChannel import SFTPChannel from sshConnector.sshLibs.sshChannelEnvironment import sshEnvironment , EnvironmentControls from typing import Union , List , Any , Optional # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.DEBUG) # _ptlog = logging.getLogger('paramiko.transport') # _ptlog.setLevel(logging.WARNING) # _pclog = logging.getLogger('paramiko.channel') # _pclog.setLevel(logging.WARNING) log = logging . getLogger ( 'ToolKitInterface' ) class _ToolKitModules ( dict ): tki = None def __init__ ( self , tki , * args , ** kwargs ): self . tki = tki super ( _ToolKitModules , self ) . __init__ ( * args , ** kwargs ) def __getattr__ ( self , item ): if not ( item . startswith ( '_' ) or ( item . startswith ( '__' ) and item . endswith ( '__' ))): return self . tki . getModules ( item ) or getattr ( self . tki , item ) class ToolKitInterface : __KNOWNMODULES__ = { 'oracle' : { 'from' : 'Oraclemodule' , 'import' : 'oracleModule' }, 'mysql' : { 'from' : 'mysqlmodule' , 'import' : 'mysqlModule' }} def __init__ ( self , arguments : Optional [ ArgumentParsers ] = None , auto_login : bool = True , * args , ** kwargs ): \"\"\" This acts differently depending on what is passed to it. More explained below. - :param arguments: Args is from argparse and is the main way data is passed between classes - :param autoLogin: Automatically attempt to log into the specified device - :param kwargs: This is an unused placeholder. This class inherits from object and its best practice to have have kwargs. \"\"\" log . debug ( \"Creating a ToolKitInterface module\" ) self . sshCon : Optional [ threadedSSH ] = None self . modules = _ToolKitModules ( self ) if arguments is None : arguments = ArgumentWrapper . arguments () . parse_known_args ()[ 0 ] self . arguments = arguments self . auto_login = auto_login if auto_login : self . createConnection () def createConnection ( self , arguments : Optional [ ArgumentParsers ] = None ) -> threadedSSH : \"\"\" This creates a new SSH connection using the sshConnector tool which wraps Paramiko - :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments - :return: (threadedSSH) \"\"\" if self . sshCon is not None : if self . checkConnection (): return self . sshCon self . disconnect () try : if arguments is None : arguments = self . arguments self . sshCon = threadedSSH ( arguments = arguments , tki = self ) return self . sshCon except Exception as e : log . error ( f 'ERROR: for method createConnection: { e } ' ) log . debug ( f '[DEBUG] for method createConnection: { traceback . format_exc () } ' ) raise e def disconnect ( self ) -> None : \"\"\" This wraps around the 'threadedDisconnect' method of the sshConnector \"\"\" if self . sshCon : self . sshCon . threadedDisconnect () del self . sshCon self . sshCon = None self . modules . clear () def checkConnection ( self , * args , ** kwargs ) -> bool : \"\"\" This wraps around the 'checkConnection' method of the sshConnector \"\"\" if not self . sshCon : return False return self . sshCon . checkConnection ( * args , ** kwargs ) def getAvailableModules ( self , moduleType : str = None ) -> list : \"\"\" This Function returns all modules found under the 'LinuxModules' directory. - :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. \"\"\" return find_modules ( moduleSubDir = moduleType ) def getModules ( self , * args , ** kwargs ) -> Union [ GenericCmdModule , List [ GenericCmdModule ]]: \"\"\" Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. - :param args: str or iterable - :param kwargs: Ignores - :return: CommandModule object as a single item or in a list. \"\"\" def _parseNames ( moduleNames ): if len ( moduleNames ) == 1 : moduleNames = moduleNames [ 0 ] if isinstance ( moduleNames , str ): return [ moduleNames ] return moduleNames or [] def _buildOutputList ( names ): outputModules = [] for name in _parseNames ( names ): if name in self . modules : outputModules . append ( self . modules [ name ]) else : outputModules . append ( self . _importAndInstantiateModule ( name , ** kwargs )) if len ( outputModules ) == 1 : return outputModules . pop () return outputModules if 'modules' in kwargs : args = kwargs . pop ( 'modules' ) elif 'name' in kwargs : args = kwargs . pop ( 'name' ) return _buildOutputList ( args ) def _importAndInstantiateModule ( self , moduleName : str , ** kwargs ) -> GenericCmdModule : \"\"\" This is called directly by the 'getModules' function and should not be directly called. This function uses the '_importAndInstantiateModuleHelper' to do most of the heavy lifting. This functions job is to iterate thru the modulesNames variable and pass it along to the helper class. - :param moduleName: string - :return: GenericCmdModule \"\"\" def _parseName ( name ): if 'Module' not in name : name += \"Module\" return name . lower (), name if moduleName in self . __KNOWNMODULES__ : knowModule = self . __KNOWNMODULES__ [ moduleName ] moduleObj = self . _importAndInstantiateModuleHelper ( knowModule [ 'from' ], knowModule [ 'import' ], ** kwargs ) else : moduleObj = self . _importAndInstantiateModuleHelper ( * _parseName ( moduleName ), ** kwargs ) if moduleObj is not None : self . modules [ moduleName ] = moduleObj if hasattr ( self , moduleName ): # report any naming conflicts log . warning ( 'Overwriting value for module \" %s \": Name already exists with value: %s ' % ( moduleObj , getattr ( self , moduleName ))) setattr ( self , moduleName , moduleObj ) return moduleObj def _importAndInstantiateModuleHelper ( self , moduleFrom : str , moduleImport : str , ** kwargs ) -> GenericCmdModule : \"\"\" Utilized by the '_importAndInstantiateModule' only this function attempts to dynamically import and instantiate an Class and return the object or return None. - :param moduleName: The single module name that it will try to import - :param knownMod: Whether or not the name can be found in the '__KNOWNMODULES__' class variable. - :return: GenericCmdModule \"\"\" def _importHelper ( fromName , importName ): try : return getattr ( __import__ ( fromName ), importName ) except Exception as e : print ( f \"Failed to import module { importName } with error: \\n { e } \" ) print ( f \"StackTrace: { traceback . format_exc () } \" ) log . error ( f \"Failed to import module { importName } with error: \\n { e } \" ) def _instantiateModule ( module ): try : if 'tki' in kwargs : return module ( ** kwargs ) return module ( tki = self , ** kwargs ) except Exception as e : print ( f \"Failed to instantiate module { str ( module ) } with error: \\n { e } \" ) print ( f \"StackTrace: { traceback . format_exc () } \" ) log . error ( \"Failed to instantiate module %s with error: \\n %s \" % ( str ( module ), e )) return _instantiateModule ( _importHelper ( moduleFrom , moduleImport )) def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any : \"\"\" This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. - :param commands: string,dict,CommandContainer/list/tuple/set - :param threading: Bool, default True - :param kwargs: Values passed to the CommandContainer and thus to the sshThreader - :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. \"\"\" log . info ( f 'Executing command/type: { commands } / { type ( commands ) } with threading = { threading } ' ) if not isinstance ( commands , CommandContainer ): kwargs . update ({ 'tki' : kwargs . get ( 'tki' , self )}) kwargs . update ({ 'commandKey' : kwargs . get ( 'commandKey' , None )}) commands = CommandContainer ( commands , ** kwargs ) if not self . checkConnection (): try : self . createConnection () except Exception as e : raise commands . forceComplete ( e ) env_obj = kwargs . get ( 'environment' , None ) if env_obj is not None : commands . root = False threading = commands . kwargs . get ( 'threading' , threading ) or threading if not threading : return self . _executeUnthread ( commands ) self . sshCon . executeOnThread ( commands , EnvObj = env_obj ) return commands def _executeUnthread ( self , commands : Any ) -> Any : \"\"\" This allows unthreaded commands to be mixed with threaded ones. This is called by the execute method. \"\"\" def _exeUnthread ( cmd ): with cmd : cmd . executor ( tki = self ) return cmd . results if type ( commands ) is list : outDict = {} for command in commands : outDict [ command . commandKey ] = _exeUnthread ( command ) return outDict return _exeUnthread ( commands ) def waitForIdle ( self , timeout : Union [ int , float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool : \"\"\" This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting. It is thread safe and does not rely on signals. This will return False if tasks remain but no threads exist unless standbyTasks==True. - :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds - :param delay: (float) Time to wait between checks for all tasks complete - :param block: (bool) Block the task queue so that no new tasks can be added - :return: bool \"\"\" if not self . checkConnection (): return True return self . sshCon . waitForIdle ( timeout = timeout , delay = delay , block = block ) def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps the sshConnector's 'escalate' method \"\"\" return self . sshCon . escalate ( * args , ** kwargs ) def becomeRoot ( self , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps around becomeRoot in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeRoot ( ** kwargs ) def becomeUser ( self , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps around becomeUser in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeUser ( ** kwargs ) def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps sshConnector's 'environmentChange' \"\"\" return self . sshCon . environmentChange ( * args , ** kwargs ) def checkWhoami ( self , environment = None ) -> str : \"\"\" Wraps around the sshConnector's 'checkWhoAmI' method \"\"\" return self . sshCon . checkWhoAmI ( environment = environment ) def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Wraps around the sshConnector's 'getEnvironment' method \"\"\" if not self . checkConnection (): self . createConnection () return self . sshCon . getEnvironment ( * args , ** kwargs ) def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Wraps around the sshConnector's 'createEnvironment' method \"\"\" if not self . checkConnection (): self . createConnection () return self . sshCon . createEnvironment ( ** kwargs ) def getSFTPClient ( self ) -> SFTPChannel : \"\"\" Creates and returns a SFTP Channel object \"\"\" if not self . checkConnection (): self . createConnection () return SFTPChannel ( self ) def getSCPClient ( self ) -> SCPChannel : \"\"\" Creates and returns a SCP Channel object \"\"\" if not self . checkConnection (): self . createConnection () return SCPChannel ( self ) if __name__ == '__main__' : print ( \"This should be called as a module.\" ) Variables log Classes ToolKitInterface class ToolKitInterface ( arguments : Optional [ libs . ArgumentWrapper . ArgumentParsers ] = None , auto_login : bool = True , * args , ** kwargs ) View Source class ToolKitInterface : __KNOWNMODULES__ = { 'oracle' : { 'from' : 'Oraclemodule' , 'import' : 'oracleModule' } , 'mysql' : { 'from' : 'mysqlmodule' , 'import' : 'mysqlModule' }} def __init__ ( self , arguments : Optional [ ArgumentParsers ] = None , auto_login : bool = True , * args , ** kwargs ) : \"\"\" This acts differently depending on what is passed to it. More explained below. - :param arguments: Args is from argparse and is the main way data is passed between classes - :param autoLogin: Automatically attempt to log into the specified device - :param kwargs: This is an unused placeholder. This class inherits from object and its best practice to have have kwargs. \"\"\" log . debug ( \"Creating a ToolKitInterface module\" ) self . sshCon : Optional [ threadedSSH ] = None self . modules = _ToolKitModules ( self ) if arguments is None : arguments = ArgumentWrapper . arguments (). parse_known_args () [ 0 ] self . arguments = arguments self . auto_login = auto_login if auto_login : self . createConnection () def createConnection ( self , arguments : Optional [ ArgumentParsers ] = None ) -> threadedSSH : \"\"\" This creates a new SSH connection using the sshConnector tool which wraps Paramiko - :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments - :return: (threadedSSH) \"\"\" if self . sshCon is not None : if self . checkConnection () : return self . sshCon self . disconnect () try : if arguments is None : arguments = self . arguments self . sshCon = threadedSSH ( arguments = arguments , tki = self ) return self . sshCon except Exception as e : log . error ( f 'ERROR: for method createConnection: {e}' ) log . debug ( f '[DEBUG] for method createConnection: {traceback.format_exc()}' ) raise e def disconnect ( self ) -> None : \"\"\" This wraps around the 'threadedDisconnect' method of the sshConnector \"\"\" if self . sshCon : self . sshCon . threadedDisconnect () del self . sshCon self . sshCon = None self . modules . clear () def checkConnection ( self , * args , ** kwargs ) -> bool : \"\"\" This wraps around the 'checkConnection' method of the sshConnector \"\"\" if not self . sshCon : return False return self . sshCon . checkConnection ( * args , ** kwargs ) def getAvailableModules ( self , moduleType : str = None ) -> list : \"\"\" This Function returns all modules found under the 'LinuxModules' directory. - :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. \"\"\" return find_modules ( moduleSubDir = moduleType ) def getModules ( self , * args , ** kwargs ) -> Union [ GenericCmdModule, List[GenericCmdModule ] ]: \"\"\" Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. - :param args: str or iterable - :param kwargs: Ignores - :return: CommandModule object as a single item or in a list. \"\"\" def _parseNames ( moduleNames ) : if len ( moduleNames ) == 1 : moduleNames = moduleNames [ 0 ] if isinstance ( moduleNames , str ) : return [ moduleNames ] return moduleNames or [] def _buildOutputList ( names ) : outputModules = [] for name in _parseNames ( names ) : if name in self . modules : outputModules . append ( self . modules [ name ] ) else : outputModules . append ( self . _importAndInstantiateModule ( name , ** kwargs )) if len ( outputModules ) == 1 : return outputModules . pop () return outputModules if 'modules' in kwargs : args = kwargs . pop ( 'modules' ) elif 'name' in kwargs : args = kwargs . pop ( 'name' ) return _buildOutputList ( args ) def _importAndInstantiateModule ( self , moduleName : str , ** kwargs ) -> GenericCmdModule : \"\"\" This is called directly by the 'getModules' function and should not be directly called. This function uses the '_importAndInstantiateModuleHelper' to do most of the heavy lifting. This functions job is to iterate thru the modulesNames variable and pass it along to the helper class. - :param moduleName: string - :return: GenericCmdModule \"\"\" def _parseName ( name ) : if 'Module' not in name : name += \"Module\" return name . lower (), name if moduleName in self . __KNOWNMODULES__ : knowModule = self . __KNOWNMODULES__ [ moduleName ] moduleObj = self . _importAndInstantiateModuleHelper ( knowModule [ 'from' ] , knowModule [ 'import' ] , ** kwargs ) else : moduleObj = self . _importAndInstantiateModuleHelper ( * _parseName ( moduleName ), ** kwargs ) if moduleObj is not None : self . modules [ moduleName ] = moduleObj if hasattr ( self , moduleName ) : # report any naming conflicts log . warning ( 'Overwriting value for module \"%s\": Name already exists with value: %s' % ( moduleObj , getattr ( self , moduleName ))) setattr ( self , moduleName , moduleObj ) return moduleObj def _importAndInstantiateModuleHelper ( self , moduleFrom : str , moduleImport : str , ** kwargs ) -> GenericCmdModule : \"\"\" Utilized by the '_importAndInstantiateModule' only this function attempts to dynamically import and instantiate an Class and return the object or return None. - :param moduleName: The single module name that it will try to import - :param knownMod: Whether or not the name can be found in the '__KNOWNMODULES__' class variable. - :return: GenericCmdModule \"\"\" def _importHelper ( fromName , importName ) : try : return getattr ( __import__ ( fromName ), importName ) except Exception as e : print ( f \"Failed to import module {importName} with error:\\n{e}\" ) print ( f \"StackTrace: {traceback.format_exc()}\" ) log . error ( f \"Failed to import module {importName} with error:\\n{e}\" ) def _instantiateModule ( module ) : try : if 'tki' in kwargs : return module ( ** kwargs ) return module ( tki = self , ** kwargs ) except Exception as e : print ( f \"Failed to instantiate module {str(module)} with error:\\n{e}\" ) print ( f \"StackTrace: {traceback.format_exc()}\" ) log . error ( \"Failed to instantiate module %s with error:\\n%s\" % ( str ( module ), e )) return _instantiateModule ( _importHelper ( moduleFrom , moduleImport )) def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any : \"\"\" This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. - :param commands: string,dict,CommandContainer/list/tuple/set - :param threading: Bool, default True - :param kwargs: Values passed to the CommandContainer and thus to the sshThreader - :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. \"\"\" log . info ( f 'Executing command/type: {commands}/{type(commands)} with threading = {threading}' ) if not isinstance ( commands , CommandContainer ) : kwargs . update ( { 'tki' : kwargs . get ( 'tki' , self ) } ) kwargs . update ( { 'commandKey' : kwargs . get ( 'commandKey' , None ) } ) commands = CommandContainer ( commands , ** kwargs ) if not self . checkConnection () : try : self . createConnection () except Exception as e : raise commands . forceComplete ( e ) env_obj = kwargs . get ( 'environment' , None ) if env_obj is not None : commands . root = False threading = commands . kwargs . get ( 'threading' , threading ) or threading if not threading : return self . _executeUnthread ( commands ) self . sshCon . executeOnThread ( commands , EnvObj = env_obj ) return commands def _executeUnthread ( self , commands : Any ) -> Any : \"\"\" This allows unthreaded commands to be mixed with threaded ones. This is called by the execute method. \"\"\" def _exeUnthread ( cmd ) : with cmd : cmd . executor ( tki = self ) return cmd . results if type ( commands ) is list : outDict = {} for command in commands : outDict [ command.commandKey ] = _exeUnthread ( command ) return outDict return _exeUnthread ( commands ) def waitForIdle ( self , timeout : Union [ int, float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool : \"\"\" This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting. It is thread safe and does not rely on signals. This will return False if tasks remain but no threads exist unless standbyTasks==True. - :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds - :param delay: (float) Time to wait between checks for all tasks complete - :param block: (bool) Block the task queue so that no new tasks can be added - :return: bool \"\"\" if not self . checkConnection () : return True return self . sshCon . waitForIdle ( timeout = timeout , delay = delay , block = block ) def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps the sshConnector's 'escalate' method \"\"\" return self . sshCon . escalate ( * args , ** kwargs ) def becomeRoot ( self , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps around becomeRoot in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeRoot ( ** kwargs ) def becomeUser ( self , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps around becomeUser in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeUser ( ** kwargs ) def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps sshConnector's 'environmentChange' \"\"\" return self . sshCon . environmentChange ( * args , ** kwargs ) def checkWhoami ( self , environment = None ) -> str : \"\"\" Wraps around the sshConnector's 'checkWhoAmI' method \"\"\" return self . sshCon . checkWhoAmI ( environment = environment ) def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool, EnvironmentControls ] : \"\"\" Wraps around the sshConnector's 'getEnvironment' method \"\"\" if not self . checkConnection () : self . createConnection () return self . sshCon . getEnvironment ( * args , ** kwargs ) def createEnvironment ( self , ** kwargs ) -> Union [ bool, EnvironmentControls ] : \"\"\" Wraps around the sshConnector's 'createEnvironment' method \"\"\" if not self . checkConnection () : self . createConnection () return self . sshCon . createEnvironment ( ** kwargs ) def getSFTPClient ( self ) -> SFTPChannel : \"\"\" Creates and returns a SFTP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SFTPChannel ( self ) def getSCPClient ( self ) -> SCPChannel : \"\"\" Creates and returns a SCP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SCPChannel ( self ) Methods becomeRoot def becomeRoot ( self , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps around becomeRoot in the sshEnvironmentControl class. View Source def becomeRoot ( self , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps around becomeRoot in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeRoot ( ** kwargs ) becomeUser def becomeUser ( self , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps around becomeUser in the sshEnvironmentControl class. View Source def becomeUser ( self , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps around becomeUser in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeUser ( ** kwargs ) checkConnection def checkConnection ( self , * args , ** kwargs ) -> bool This wraps around the 'checkConnection' method of the sshConnector View Source def checkConnection ( self , * args , ** kwargs ) -> bool : \"\"\" This wraps around the ' checkConnection ' method of the sshConnector \"\"\" if not self . sshCon : return False return self . sshCon . checkConnection ( * args , ** kwargs ) checkWhoami def checkWhoami ( self , environment = None ) -> str Wraps around the sshConnector's 'checkWhoAmI' method View Source def checkWhoami ( self , environment = None ) -> str : \"\"\" Wraps around the sshConnector' s 'checkWhoAmI' method \"\"\" return self.sshCon.checkWhoAmI(environment=environment) createConnection def createConnection ( self , arguments : Optional [ libs . ArgumentWrapper . ArgumentParsers ] = None ) -> sshConnector . sshThreader . sshThreader This creates a new SSH connection using the sshConnector tool which wraps Paramiko :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments :return: (threadedSSH) View Source def createConnection ( self , arguments : Optional [ ArgumentParsers ] = None ) -> threadedSSH : \"\"\" This creates a new SSH connection using the sshConnector tool which wraps Paramiko - :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments - :return: (threadedSSH) \"\"\" if self . sshCon is not None : if self . checkConnection () : return self . sshCon self . disconnect () try : if arguments is None : arguments = self . arguments self . sshCon = threadedSSH ( arguments = arguments , tki = self ) return self . sshCon except Exception as e : log . error ( f 'ERROR: for method createConnection: {e}' ) log . debug ( f '[DEBUG] for method createConnection: {traceback.format_exc()}' ) raise e createEnvironment def createEnvironment ( self , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Wraps around the sshConnector's 'createEnvironment' method View Source def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ] : \"\"\" Wraps around the sshConnector' s 'createEnvironment' method \"\"\" if not self.checkConnection(): self.createConnection() return self.sshCon.createEnvironment(**kwargs) disconnect def disconnect ( self ) -> None This wraps around the 'threadedDisconnect' method of the sshConnector View Source def disconnect ( self ) -> None : \"\"\" This wraps around the ' threadedDisconnect ' method of the sshConnector \"\"\" if self . sshCon : self . sshCon . threadedDisconnect () del self . sshCon self . sshCon = None self . modules . clear () environmentChange def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps sshConnector's 'environmentChange' View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps sshConnector' s 'environmentChange' \"\"\" return self.sshCon.environmentChange(*args, **kwargs) escalate def escalate ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps the sshConnector's 'escalate' method View Source def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps the sshConnector' s 'escalate' method \"\"\" return self.sshCon.escalate(*args, **kwargs) execute def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. :param commands: string,dict,CommandContainer/list/tuple/set :param threading: Bool, default True :param kwargs: Values passed to the CommandContainer and thus to the sshThreader :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. View Source def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any : \"\"\" This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. - :param commands: string,dict,CommandContainer/list/tuple/set - :param threading: Bool, default True - :param kwargs: Values passed to the CommandContainer and thus to the sshThreader - :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. \"\"\" log . info ( f ' Executing command / type : { commands } / { type ( commands )} with threading = { threading } ' ) if not isinstance ( commands , CommandContainer ): kwargs . update ({ ' tki ' : kwargs . get ( ' tki ' , self )}) kwargs . update ({ ' commandKey ' : kwargs . get ( ' commandKey ' , None )}) commands = CommandContainer ( commands , ** kwargs ) if not self . checkConnection (): try : self . createConnection () except Exception as e : raise commands . forceComplete ( e ) env_obj = kwargs . get ( ' environment ' , None ) if env_obj is not None : commands . root = False threading = commands . kwargs . get ( ' threading ' , threading ) or threading if not threading : return self . _executeUnthread ( commands ) self . sshCon . executeOnThread ( commands , EnvObj = env_obj ) return commands getAvailableModules def getAvailableModules ( self , moduleType : str = None ) -> list This Function returns all modules found under the 'LinuxModules' directory. :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. View Source def getAvailableModules ( self , moduleType : str = None ) -> list : \"\"\" This Function returns all modules found under the ' LinuxModules ' directory. - :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. \"\"\" return find_modules ( moduleSubDir = moduleType ) getEnvironment def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Wraps around the sshConnector's 'getEnvironment' method View Source def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool , EnvironmentControls ] : \"\"\" Wraps around the sshConnector' s 'getEnvironment' method \"\"\" if not self.checkConnection(): self.createConnection() return self.sshCon.getEnvironment(*args, **kwargs) getModules def getModules ( self , * args , ** kwargs ) -> Union [ LinuxModules . genericCmdModule . GenericCmdModule , List [ LinuxModules . genericCmdModule . GenericCmdModule ]] Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. :param args: str or iterable :param kwargs: Ignores :return: CommandModule object as a single item or in a list. View Source def getModules ( self , * args , ** kwargs ) -> Union [ GenericCmdModule, List[GenericCmdModule ] ]: \"\"\" Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. - :param args: str or iterable - :param kwargs: Ignores - :return: CommandModule object as a single item or in a list. \"\"\" def _parseNames ( moduleNames ) : if len ( moduleNames ) == 1 : moduleNames = moduleNames [ 0 ] if isinstance ( moduleNames , str ) : return [ moduleNames ] return moduleNames or [] def _buildOutputList ( names ) : outputModules = [] for name in _parseNames ( names ) : if name in self . modules : outputModules . append ( self . modules [ name ] ) else : outputModules . append ( self . _importAndInstantiateModule ( name , ** kwargs )) if len ( outputModules ) == 1 : return outputModules . pop () return outputModules if 'modules' in kwargs : args = kwargs . pop ( 'modules' ) elif 'name' in kwargs : args = kwargs . pop ( 'name' ) return _buildOutputList ( args ) getSCPClient def getSCPClient ( self ) -> sshConnector . sshLibs . SCPChannel . SCPChannel Creates and returns a SCP Channel object View Source def getSCPClient ( self ) -> SCPChannel : \"\"\" Creates and returns a SCP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SCPChannel ( self ) getSFTPClient def getSFTPClient ( self ) -> sshConnector . sshLibs . SFTPChannel . SFTPChannel Creates and returns a SFTP Channel object View Source def getSFTPClient ( self ) -> SFTPChannel : \"\"\" Creates and returns a SFTP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SFTPChannel ( self ) waitForIdle def waitForIdle ( self , timeout : Union [ int , float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting . It is thread safe and does not rely on signals . This will return False if tasks remain but no threads exist unless standbyTasks == True . :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds :param delay: (float) Time to wait between checks for all tasks complete :param block: (bool) Block the task queue so that no new tasks can be added :return: bool View Source def waitForIdle ( self , timeout : Union [ int , float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool : \"\"\" This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting. It is thread safe and does not rely on signals. This will return False if tasks remain but no threads exist unless standbyTasks==True. - :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds - :param delay: (float) Time to wait between checks for all tasks complete - :param block: (bool) Block the task queue so that no new tasks can be added - :return: bool \"\"\" if not self . checkConnection (): return True return self . sshCon . waitForIdle ( timeout = timeout , delay = delay , block = block )","title":"Ldtk"},{"location":"reference/ldtk/#module-ldtk","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson, Timothy Nodine # Version: 1.0 # Date: 02/19/15 # Description: This is designed to be an interface between sshConnector and different Command Modules. The purpose of # this package is to create a sort of one-stop shop for programs to interact with modules and allow modules to easily # interact with each other. Simply passing the ToolKitInterface across to each module allows them to be able to see # each other. import logging import warnings from cryptography.utils import CryptographyDeprecationWarning warnings . filterwarnings ( 'ignore' , category = CryptographyDeprecationWarning ) import traceback from PyLinuxDiagnosticToolKit import find_modules from libs import ArgumentWrapper from libs.ArgumentWrapper import ArgumentParsers from LinuxModules.genericCmdModule import GenericCmdModule from LinuxModules.CommandContainers import CommandContainer from sshConnector.sshThreader import sshThreader as threadedSSH from sshConnector.sshLibs.SCPChannel import SCPChannel from sshConnector.sshLibs.SFTPChannel import SFTPChannel from sshConnector.sshLibs.sshChannelEnvironment import sshEnvironment , EnvironmentControls from typing import Union , List , Any , Optional # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.DEBUG) # _ptlog = logging.getLogger('paramiko.transport') # _ptlog.setLevel(logging.WARNING) # _pclog = logging.getLogger('paramiko.channel') # _pclog.setLevel(logging.WARNING) log = logging . getLogger ( 'ToolKitInterface' ) class _ToolKitModules ( dict ): tki = None def __init__ ( self , tki , * args , ** kwargs ): self . tki = tki super ( _ToolKitModules , self ) . __init__ ( * args , ** kwargs ) def __getattr__ ( self , item ): if not ( item . startswith ( '_' ) or ( item . startswith ( '__' ) and item . endswith ( '__' ))): return self . tki . getModules ( item ) or getattr ( self . tki , item ) class ToolKitInterface : __KNOWNMODULES__ = { 'oracle' : { 'from' : 'Oraclemodule' , 'import' : 'oracleModule' }, 'mysql' : { 'from' : 'mysqlmodule' , 'import' : 'mysqlModule' }} def __init__ ( self , arguments : Optional [ ArgumentParsers ] = None , auto_login : bool = True , * args , ** kwargs ): \"\"\" This acts differently depending on what is passed to it. More explained below. - :param arguments: Args is from argparse and is the main way data is passed between classes - :param autoLogin: Automatically attempt to log into the specified device - :param kwargs: This is an unused placeholder. This class inherits from object and its best practice to have have kwargs. \"\"\" log . debug ( \"Creating a ToolKitInterface module\" ) self . sshCon : Optional [ threadedSSH ] = None self . modules = _ToolKitModules ( self ) if arguments is None : arguments = ArgumentWrapper . arguments () . parse_known_args ()[ 0 ] self . arguments = arguments self . auto_login = auto_login if auto_login : self . createConnection () def createConnection ( self , arguments : Optional [ ArgumentParsers ] = None ) -> threadedSSH : \"\"\" This creates a new SSH connection using the sshConnector tool which wraps Paramiko - :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments - :return: (threadedSSH) \"\"\" if self . sshCon is not None : if self . checkConnection (): return self . sshCon self . disconnect () try : if arguments is None : arguments = self . arguments self . sshCon = threadedSSH ( arguments = arguments , tki = self ) return self . sshCon except Exception as e : log . error ( f 'ERROR: for method createConnection: { e } ' ) log . debug ( f '[DEBUG] for method createConnection: { traceback . format_exc () } ' ) raise e def disconnect ( self ) -> None : \"\"\" This wraps around the 'threadedDisconnect' method of the sshConnector \"\"\" if self . sshCon : self . sshCon . threadedDisconnect () del self . sshCon self . sshCon = None self . modules . clear () def checkConnection ( self , * args , ** kwargs ) -> bool : \"\"\" This wraps around the 'checkConnection' method of the sshConnector \"\"\" if not self . sshCon : return False return self . sshCon . checkConnection ( * args , ** kwargs ) def getAvailableModules ( self , moduleType : str = None ) -> list : \"\"\" This Function returns all modules found under the 'LinuxModules' directory. - :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. \"\"\" return find_modules ( moduleSubDir = moduleType ) def getModules ( self , * args , ** kwargs ) -> Union [ GenericCmdModule , List [ GenericCmdModule ]]: \"\"\" Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. - :param args: str or iterable - :param kwargs: Ignores - :return: CommandModule object as a single item or in a list. \"\"\" def _parseNames ( moduleNames ): if len ( moduleNames ) == 1 : moduleNames = moduleNames [ 0 ] if isinstance ( moduleNames , str ): return [ moduleNames ] return moduleNames or [] def _buildOutputList ( names ): outputModules = [] for name in _parseNames ( names ): if name in self . modules : outputModules . append ( self . modules [ name ]) else : outputModules . append ( self . _importAndInstantiateModule ( name , ** kwargs )) if len ( outputModules ) == 1 : return outputModules . pop () return outputModules if 'modules' in kwargs : args = kwargs . pop ( 'modules' ) elif 'name' in kwargs : args = kwargs . pop ( 'name' ) return _buildOutputList ( args ) def _importAndInstantiateModule ( self , moduleName : str , ** kwargs ) -> GenericCmdModule : \"\"\" This is called directly by the 'getModules' function and should not be directly called. This function uses the '_importAndInstantiateModuleHelper' to do most of the heavy lifting. This functions job is to iterate thru the modulesNames variable and pass it along to the helper class. - :param moduleName: string - :return: GenericCmdModule \"\"\" def _parseName ( name ): if 'Module' not in name : name += \"Module\" return name . lower (), name if moduleName in self . __KNOWNMODULES__ : knowModule = self . __KNOWNMODULES__ [ moduleName ] moduleObj = self . _importAndInstantiateModuleHelper ( knowModule [ 'from' ], knowModule [ 'import' ], ** kwargs ) else : moduleObj = self . _importAndInstantiateModuleHelper ( * _parseName ( moduleName ), ** kwargs ) if moduleObj is not None : self . modules [ moduleName ] = moduleObj if hasattr ( self , moduleName ): # report any naming conflicts log . warning ( 'Overwriting value for module \" %s \": Name already exists with value: %s ' % ( moduleObj , getattr ( self , moduleName ))) setattr ( self , moduleName , moduleObj ) return moduleObj def _importAndInstantiateModuleHelper ( self , moduleFrom : str , moduleImport : str , ** kwargs ) -> GenericCmdModule : \"\"\" Utilized by the '_importAndInstantiateModule' only this function attempts to dynamically import and instantiate an Class and return the object or return None. - :param moduleName: The single module name that it will try to import - :param knownMod: Whether or not the name can be found in the '__KNOWNMODULES__' class variable. - :return: GenericCmdModule \"\"\" def _importHelper ( fromName , importName ): try : return getattr ( __import__ ( fromName ), importName ) except Exception as e : print ( f \"Failed to import module { importName } with error: \\n { e } \" ) print ( f \"StackTrace: { traceback . format_exc () } \" ) log . error ( f \"Failed to import module { importName } with error: \\n { e } \" ) def _instantiateModule ( module ): try : if 'tki' in kwargs : return module ( ** kwargs ) return module ( tki = self , ** kwargs ) except Exception as e : print ( f \"Failed to instantiate module { str ( module ) } with error: \\n { e } \" ) print ( f \"StackTrace: { traceback . format_exc () } \" ) log . error ( \"Failed to instantiate module %s with error: \\n %s \" % ( str ( module ), e )) return _instantiateModule ( _importHelper ( moduleFrom , moduleImport )) def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any : \"\"\" This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. - :param commands: string,dict,CommandContainer/list/tuple/set - :param threading: Bool, default True - :param kwargs: Values passed to the CommandContainer and thus to the sshThreader - :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. \"\"\" log . info ( f 'Executing command/type: { commands } / { type ( commands ) } with threading = { threading } ' ) if not isinstance ( commands , CommandContainer ): kwargs . update ({ 'tki' : kwargs . get ( 'tki' , self )}) kwargs . update ({ 'commandKey' : kwargs . get ( 'commandKey' , None )}) commands = CommandContainer ( commands , ** kwargs ) if not self . checkConnection (): try : self . createConnection () except Exception as e : raise commands . forceComplete ( e ) env_obj = kwargs . get ( 'environment' , None ) if env_obj is not None : commands . root = False threading = commands . kwargs . get ( 'threading' , threading ) or threading if not threading : return self . _executeUnthread ( commands ) self . sshCon . executeOnThread ( commands , EnvObj = env_obj ) return commands def _executeUnthread ( self , commands : Any ) -> Any : \"\"\" This allows unthreaded commands to be mixed with threaded ones. This is called by the execute method. \"\"\" def _exeUnthread ( cmd ): with cmd : cmd . executor ( tki = self ) return cmd . results if type ( commands ) is list : outDict = {} for command in commands : outDict [ command . commandKey ] = _exeUnthread ( command ) return outDict return _exeUnthread ( commands ) def waitForIdle ( self , timeout : Union [ int , float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool : \"\"\" This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting. It is thread safe and does not rely on signals. This will return False if tasks remain but no threads exist unless standbyTasks==True. - :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds - :param delay: (float) Time to wait between checks for all tasks complete - :param block: (bool) Block the task queue so that no new tasks can be added - :return: bool \"\"\" if not self . checkConnection (): return True return self . sshCon . waitForIdle ( timeout = timeout , delay = delay , block = block ) def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps the sshConnector's 'escalate' method \"\"\" return self . sshCon . escalate ( * args , ** kwargs ) def becomeRoot ( self , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps around becomeRoot in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeRoot ( ** kwargs ) def becomeUser ( self , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps around becomeUser in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeUser ( ** kwargs ) def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wraps sshConnector's 'environmentChange' \"\"\" return self . sshCon . environmentChange ( * args , ** kwargs ) def checkWhoami ( self , environment = None ) -> str : \"\"\" Wraps around the sshConnector's 'checkWhoAmI' method \"\"\" return self . sshCon . checkWhoAmI ( environment = environment ) def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Wraps around the sshConnector's 'getEnvironment' method \"\"\" if not self . checkConnection (): self . createConnection () return self . sshCon . getEnvironment ( * args , ** kwargs ) def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Wraps around the sshConnector's 'createEnvironment' method \"\"\" if not self . checkConnection (): self . createConnection () return self . sshCon . createEnvironment ( ** kwargs ) def getSFTPClient ( self ) -> SFTPChannel : \"\"\" Creates and returns a SFTP Channel object \"\"\" if not self . checkConnection (): self . createConnection () return SFTPChannel ( self ) def getSCPClient ( self ) -> SCPChannel : \"\"\" Creates and returns a SCP Channel object \"\"\" if not self . checkConnection (): self . createConnection () return SCPChannel ( self ) if __name__ == '__main__' : print ( \"This should be called as a module.\" )","title":"Module ldtk"},{"location":"reference/ldtk/#variables","text":"log","title":"Variables"},{"location":"reference/ldtk/#classes","text":"","title":"Classes"},{"location":"reference/ldtk/#toolkitinterface","text":"class ToolKitInterface ( arguments : Optional [ libs . ArgumentWrapper . ArgumentParsers ] = None , auto_login : bool = True , * args , ** kwargs ) View Source class ToolKitInterface : __KNOWNMODULES__ = { 'oracle' : { 'from' : 'Oraclemodule' , 'import' : 'oracleModule' } , 'mysql' : { 'from' : 'mysqlmodule' , 'import' : 'mysqlModule' }} def __init__ ( self , arguments : Optional [ ArgumentParsers ] = None , auto_login : bool = True , * args , ** kwargs ) : \"\"\" This acts differently depending on what is passed to it. More explained below. - :param arguments: Args is from argparse and is the main way data is passed between classes - :param autoLogin: Automatically attempt to log into the specified device - :param kwargs: This is an unused placeholder. This class inherits from object and its best practice to have have kwargs. \"\"\" log . debug ( \"Creating a ToolKitInterface module\" ) self . sshCon : Optional [ threadedSSH ] = None self . modules = _ToolKitModules ( self ) if arguments is None : arguments = ArgumentWrapper . arguments (). parse_known_args () [ 0 ] self . arguments = arguments self . auto_login = auto_login if auto_login : self . createConnection () def createConnection ( self , arguments : Optional [ ArgumentParsers ] = None ) -> threadedSSH : \"\"\" This creates a new SSH connection using the sshConnector tool which wraps Paramiko - :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments - :return: (threadedSSH) \"\"\" if self . sshCon is not None : if self . checkConnection () : return self . sshCon self . disconnect () try : if arguments is None : arguments = self . arguments self . sshCon = threadedSSH ( arguments = arguments , tki = self ) return self . sshCon except Exception as e : log . error ( f 'ERROR: for method createConnection: {e}' ) log . debug ( f '[DEBUG] for method createConnection: {traceback.format_exc()}' ) raise e def disconnect ( self ) -> None : \"\"\" This wraps around the 'threadedDisconnect' method of the sshConnector \"\"\" if self . sshCon : self . sshCon . threadedDisconnect () del self . sshCon self . sshCon = None self . modules . clear () def checkConnection ( self , * args , ** kwargs ) -> bool : \"\"\" This wraps around the 'checkConnection' method of the sshConnector \"\"\" if not self . sshCon : return False return self . sshCon . checkConnection ( * args , ** kwargs ) def getAvailableModules ( self , moduleType : str = None ) -> list : \"\"\" This Function returns all modules found under the 'LinuxModules' directory. - :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. \"\"\" return find_modules ( moduleSubDir = moduleType ) def getModules ( self , * args , ** kwargs ) -> Union [ GenericCmdModule, List[GenericCmdModule ] ]: \"\"\" Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. - :param args: str or iterable - :param kwargs: Ignores - :return: CommandModule object as a single item or in a list. \"\"\" def _parseNames ( moduleNames ) : if len ( moduleNames ) == 1 : moduleNames = moduleNames [ 0 ] if isinstance ( moduleNames , str ) : return [ moduleNames ] return moduleNames or [] def _buildOutputList ( names ) : outputModules = [] for name in _parseNames ( names ) : if name in self . modules : outputModules . append ( self . modules [ name ] ) else : outputModules . append ( self . _importAndInstantiateModule ( name , ** kwargs )) if len ( outputModules ) == 1 : return outputModules . pop () return outputModules if 'modules' in kwargs : args = kwargs . pop ( 'modules' ) elif 'name' in kwargs : args = kwargs . pop ( 'name' ) return _buildOutputList ( args ) def _importAndInstantiateModule ( self , moduleName : str , ** kwargs ) -> GenericCmdModule : \"\"\" This is called directly by the 'getModules' function and should not be directly called. This function uses the '_importAndInstantiateModuleHelper' to do most of the heavy lifting. This functions job is to iterate thru the modulesNames variable and pass it along to the helper class. - :param moduleName: string - :return: GenericCmdModule \"\"\" def _parseName ( name ) : if 'Module' not in name : name += \"Module\" return name . lower (), name if moduleName in self . __KNOWNMODULES__ : knowModule = self . __KNOWNMODULES__ [ moduleName ] moduleObj = self . _importAndInstantiateModuleHelper ( knowModule [ 'from' ] , knowModule [ 'import' ] , ** kwargs ) else : moduleObj = self . _importAndInstantiateModuleHelper ( * _parseName ( moduleName ), ** kwargs ) if moduleObj is not None : self . modules [ moduleName ] = moduleObj if hasattr ( self , moduleName ) : # report any naming conflicts log . warning ( 'Overwriting value for module \"%s\": Name already exists with value: %s' % ( moduleObj , getattr ( self , moduleName ))) setattr ( self , moduleName , moduleObj ) return moduleObj def _importAndInstantiateModuleHelper ( self , moduleFrom : str , moduleImport : str , ** kwargs ) -> GenericCmdModule : \"\"\" Utilized by the '_importAndInstantiateModule' only this function attempts to dynamically import and instantiate an Class and return the object or return None. - :param moduleName: The single module name that it will try to import - :param knownMod: Whether or not the name can be found in the '__KNOWNMODULES__' class variable. - :return: GenericCmdModule \"\"\" def _importHelper ( fromName , importName ) : try : return getattr ( __import__ ( fromName ), importName ) except Exception as e : print ( f \"Failed to import module {importName} with error:\\n{e}\" ) print ( f \"StackTrace: {traceback.format_exc()}\" ) log . error ( f \"Failed to import module {importName} with error:\\n{e}\" ) def _instantiateModule ( module ) : try : if 'tki' in kwargs : return module ( ** kwargs ) return module ( tki = self , ** kwargs ) except Exception as e : print ( f \"Failed to instantiate module {str(module)} with error:\\n{e}\" ) print ( f \"StackTrace: {traceback.format_exc()}\" ) log . error ( \"Failed to instantiate module %s with error:\\n%s\" % ( str ( module ), e )) return _instantiateModule ( _importHelper ( moduleFrom , moduleImport )) def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any : \"\"\" This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. - :param commands: string,dict,CommandContainer/list/tuple/set - :param threading: Bool, default True - :param kwargs: Values passed to the CommandContainer and thus to the sshThreader - :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. \"\"\" log . info ( f 'Executing command/type: {commands}/{type(commands)} with threading = {threading}' ) if not isinstance ( commands , CommandContainer ) : kwargs . update ( { 'tki' : kwargs . get ( 'tki' , self ) } ) kwargs . update ( { 'commandKey' : kwargs . get ( 'commandKey' , None ) } ) commands = CommandContainer ( commands , ** kwargs ) if not self . checkConnection () : try : self . createConnection () except Exception as e : raise commands . forceComplete ( e ) env_obj = kwargs . get ( 'environment' , None ) if env_obj is not None : commands . root = False threading = commands . kwargs . get ( 'threading' , threading ) or threading if not threading : return self . _executeUnthread ( commands ) self . sshCon . executeOnThread ( commands , EnvObj = env_obj ) return commands def _executeUnthread ( self , commands : Any ) -> Any : \"\"\" This allows unthreaded commands to be mixed with threaded ones. This is called by the execute method. \"\"\" def _exeUnthread ( cmd ) : with cmd : cmd . executor ( tki = self ) return cmd . results if type ( commands ) is list : outDict = {} for command in commands : outDict [ command.commandKey ] = _exeUnthread ( command ) return outDict return _exeUnthread ( commands ) def waitForIdle ( self , timeout : Union [ int, float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool : \"\"\" This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting. It is thread safe and does not rely on signals. This will return False if tasks remain but no threads exist unless standbyTasks==True. - :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds - :param delay: (float) Time to wait between checks for all tasks complete - :param block: (bool) Block the task queue so that no new tasks can be added - :return: bool \"\"\" if not self . checkConnection () : return True return self . sshCon . waitForIdle ( timeout = timeout , delay = delay , block = block ) def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps the sshConnector's 'escalate' method \"\"\" return self . sshCon . escalate ( * args , ** kwargs ) def becomeRoot ( self , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps around becomeRoot in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeRoot ( ** kwargs ) def becomeUser ( self , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps around becomeUser in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeUser ( ** kwargs ) def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" Wraps sshConnector's 'environmentChange' \"\"\" return self . sshCon . environmentChange ( * args , ** kwargs ) def checkWhoami ( self , environment = None ) -> str : \"\"\" Wraps around the sshConnector's 'checkWhoAmI' method \"\"\" return self . sshCon . checkWhoAmI ( environment = environment ) def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool, EnvironmentControls ] : \"\"\" Wraps around the sshConnector's 'getEnvironment' method \"\"\" if not self . checkConnection () : self . createConnection () return self . sshCon . getEnvironment ( * args , ** kwargs ) def createEnvironment ( self , ** kwargs ) -> Union [ bool, EnvironmentControls ] : \"\"\" Wraps around the sshConnector's 'createEnvironment' method \"\"\" if not self . checkConnection () : self . createConnection () return self . sshCon . createEnvironment ( ** kwargs ) def getSFTPClient ( self ) -> SFTPChannel : \"\"\" Creates and returns a SFTP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SFTPChannel ( self ) def getSCPClient ( self ) -> SCPChannel : \"\"\" Creates and returns a SCP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SCPChannel ( self )","title":"ToolKitInterface"},{"location":"reference/ldtk/#methods","text":"","title":"Methods"},{"location":"reference/ldtk/#becomeroot","text":"def becomeRoot ( self , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps around becomeRoot in the sshEnvironmentControl class. View Source def becomeRoot ( self , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps around becomeRoot in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeRoot ( ** kwargs )","title":"becomeRoot"},{"location":"reference/ldtk/#becomeuser","text":"def becomeUser ( self , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps around becomeUser in the sshEnvironmentControl class. View Source def becomeUser ( self , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps around becomeUser in the sshEnvironmentControl class. \"\"\" return self . sshCon . becomeUser ( ** kwargs )","title":"becomeUser"},{"location":"reference/ldtk/#checkconnection","text":"def checkConnection ( self , * args , ** kwargs ) -> bool This wraps around the 'checkConnection' method of the sshConnector View Source def checkConnection ( self , * args , ** kwargs ) -> bool : \"\"\" This wraps around the ' checkConnection ' method of the sshConnector \"\"\" if not self . sshCon : return False return self . sshCon . checkConnection ( * args , ** kwargs )","title":"checkConnection"},{"location":"reference/ldtk/#checkwhoami","text":"def checkWhoami ( self , environment = None ) -> str Wraps around the sshConnector's 'checkWhoAmI' method View Source def checkWhoami ( self , environment = None ) -> str : \"\"\" Wraps around the sshConnector' s 'checkWhoAmI' method \"\"\" return self.sshCon.checkWhoAmI(environment=environment)","title":"checkWhoami"},{"location":"reference/ldtk/#createconnection","text":"def createConnection ( self , arguments : Optional [ libs . ArgumentWrapper . ArgumentParsers ] = None ) -> sshConnector . sshThreader . sshThreader This creates a new SSH connection using the sshConnector tool which wraps Paramiko :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments :return: (threadedSSH) View Source def createConnection ( self , arguments : Optional [ ArgumentParsers ] = None ) -> threadedSSH : \"\"\" This creates a new SSH connection using the sshConnector tool which wraps Paramiko - :param arguments: (ArgumentParsers) This is a wrapper object around the argparse parser object it handles script arguments - :return: (threadedSSH) \"\"\" if self . sshCon is not None : if self . checkConnection () : return self . sshCon self . disconnect () try : if arguments is None : arguments = self . arguments self . sshCon = threadedSSH ( arguments = arguments , tki = self ) return self . sshCon except Exception as e : log . error ( f 'ERROR: for method createConnection: {e}' ) log . debug ( f '[DEBUG] for method createConnection: {traceback.format_exc()}' ) raise e","title":"createConnection"},{"location":"reference/ldtk/#createenvironment","text":"def createEnvironment ( self , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Wraps around the sshConnector's 'createEnvironment' method View Source def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ] : \"\"\" Wraps around the sshConnector' s 'createEnvironment' method \"\"\" if not self.checkConnection(): self.createConnection() return self.sshCon.createEnvironment(**kwargs)","title":"createEnvironment"},{"location":"reference/ldtk/#disconnect","text":"def disconnect ( self ) -> None This wraps around the 'threadedDisconnect' method of the sshConnector View Source def disconnect ( self ) -> None : \"\"\" This wraps around the ' threadedDisconnect ' method of the sshConnector \"\"\" if self . sshCon : self . sshCon . threadedDisconnect () del self . sshCon self . sshCon = None self . modules . clear ()","title":"disconnect"},{"location":"reference/ldtk/#environmentchange","text":"def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps sshConnector's 'environmentChange' View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps sshConnector' s 'environmentChange' \"\"\" return self.sshCon.environmentChange(*args, **kwargs)","title":"environmentChange"},{"location":"reference/ldtk/#escalate","text":"def escalate ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Wraps the sshConnector's 'escalate' method View Source def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wraps the sshConnector' s 'escalate' method \"\"\" return self.sshCon.escalate(*args, **kwargs)","title":"escalate"},{"location":"reference/ldtk/#execute","text":"def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. :param commands: string,dict,CommandContainer/list/tuple/set :param threading: Bool, default True :param kwargs: Values passed to the CommandContainer and thus to the sshThreader :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. View Source def execute ( self , commands : Any , threading : bool = True , ** kwargs ) -> Any : \"\"\" This is the primary function of the LDTK for executing any command. It can be passed a string, dict, CommandContainer object or a list of those types. It can execute commands threaded or unthreaded. Threaded is default and unthreaded will use the base/main ssh channel that was opened upon connection. - :param commands: string,dict,CommandContainer/list/tuple/set - :param threading: Bool, default True - :param kwargs: Values passed to the CommandContainer and thus to the sshThreader - :return: Depends on if threading is true or not and if successful. Threading=True: It will return a CommandContainer. Threading=False: It will return a dictionary. \"\"\" log . info ( f ' Executing command / type : { commands } / { type ( commands )} with threading = { threading } ' ) if not isinstance ( commands , CommandContainer ): kwargs . update ({ ' tki ' : kwargs . get ( ' tki ' , self )}) kwargs . update ({ ' commandKey ' : kwargs . get ( ' commandKey ' , None )}) commands = CommandContainer ( commands , ** kwargs ) if not self . checkConnection (): try : self . createConnection () except Exception as e : raise commands . forceComplete ( e ) env_obj = kwargs . get ( ' environment ' , None ) if env_obj is not None : commands . root = False threading = commands . kwargs . get ( ' threading ' , threading ) or threading if not threading : return self . _executeUnthread ( commands ) self . sshCon . executeOnThread ( commands , EnvObj = env_obj ) return commands","title":"execute"},{"location":"reference/ldtk/#getavailablemodules","text":"def getAvailableModules ( self , moduleType : str = None ) -> list This Function returns all modules found under the 'LinuxModules' directory. :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. View Source def getAvailableModules ( self , moduleType : str = None ) -> list : \"\"\" This Function returns all modules found under the ' LinuxModules ' directory. - :param moduleTYpe: (str or None) Defaults too None. This the sub-directory that the helper function find modules will search under. IE: CommandModules or ProgramModules. \"\"\" return find_modules ( moduleSubDir = moduleType )","title":"getAvailableModules"},{"location":"reference/ldtk/#getenvironment","text":"def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Wraps around the sshConnector's 'getEnvironment' method View Source def getEnvironment ( self , * args , ** kwargs ) -> Union [ bool , EnvironmentControls ] : \"\"\" Wraps around the sshConnector' s 'getEnvironment' method \"\"\" if not self.checkConnection(): self.createConnection() return self.sshCon.getEnvironment(*args, **kwargs)","title":"getEnvironment"},{"location":"reference/ldtk/#getmodules","text":"def getModules ( self , * args , ** kwargs ) -> Union [ LinuxModules . genericCmdModule . GenericCmdModule , List [ LinuxModules . genericCmdModule . GenericCmdModule ]] Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. :param args: str or iterable :param kwargs: Ignores :return: CommandModule object as a single item or in a list. View Source def getModules ( self , * args , ** kwargs ) -> Union [ GenericCmdModule, List[GenericCmdModule ] ]: \"\"\" Takes in arguments as args or a single arg in the form of a str or iterable data type. This will take that string and attempt to return an CommandModule object that it is associated with. I.E: 'ps' will return a 'psModule' instance of the psModule. Call this function a second time and it will return the same instance. - :param args: str or iterable - :param kwargs: Ignores - :return: CommandModule object as a single item or in a list. \"\"\" def _parseNames ( moduleNames ) : if len ( moduleNames ) == 1 : moduleNames = moduleNames [ 0 ] if isinstance ( moduleNames , str ) : return [ moduleNames ] return moduleNames or [] def _buildOutputList ( names ) : outputModules = [] for name in _parseNames ( names ) : if name in self . modules : outputModules . append ( self . modules [ name ] ) else : outputModules . append ( self . _importAndInstantiateModule ( name , ** kwargs )) if len ( outputModules ) == 1 : return outputModules . pop () return outputModules if 'modules' in kwargs : args = kwargs . pop ( 'modules' ) elif 'name' in kwargs : args = kwargs . pop ( 'name' ) return _buildOutputList ( args )","title":"getModules"},{"location":"reference/ldtk/#getscpclient","text":"def getSCPClient ( self ) -> sshConnector . sshLibs . SCPChannel . SCPChannel Creates and returns a SCP Channel object View Source def getSCPClient ( self ) -> SCPChannel : \"\"\" Creates and returns a SCP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SCPChannel ( self )","title":"getSCPClient"},{"location":"reference/ldtk/#getsftpclient","text":"def getSFTPClient ( self ) -> sshConnector . sshLibs . SFTPChannel . SFTPChannel Creates and returns a SFTP Channel object View Source def getSFTPClient ( self ) -> SFTPChannel : \"\"\" Creates and returns a SFTP Channel object \"\"\" if not self . checkConnection () : self . createConnection () return SFTPChannel ( self )","title":"getSFTPClient"},{"location":"reference/ldtk/#waitforidle","text":"def waitForIdle ( self , timeout : Union [ int , float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting . It is thread safe and does not rely on signals . This will return False if tasks remain but no threads exist unless standbyTasks == True . :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds :param delay: (float) Time to wait between checks for all tasks complete :param block: (bool) Block the task queue so that no new tasks can be added :return: bool View Source def waitForIdle ( self , timeout : Union [ int , float ] = 60 , delay : float = 0.1 , block : bool = False ) -> bool : \"\"\" This waits on the threads in the sshThreader class within sshConnector, to complete. This actually calls the 'waitForIdle' method in sshThreader which just calls the 'waitCompletion' method in ThreadPool. Below are the docs from that method: This is the preferred method for waiting. It is thread safe and does not rely on signals. This will return False if tasks remain but no threads exist unless standbyTasks==True. - :param timeout: (int) Time to wait for all tasks to complete that cannot exceed 500 seconds - :param delay: (float) Time to wait between checks for all tasks complete - :param block: (bool) Block the task queue so that no new tasks can be added - :return: bool \"\"\" if not self . checkConnection (): return True return self . sshCon . waitForIdle ( timeout = timeout , delay = delay , block = block )","title":"waitForIdle"},{"location":"reference/sshBufferControl/","text":"Module sshBufferControl View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 12/10/14 # Description: This is the second class in the sshConnector chain. Here we are simply adding the ability to run commands # on a Linux box via SSH. This is necessary to progress to user management and threading. import logging import socket import re import time import warnings import traceback from time import sleep from sshConnector.sshConnect import sshConnect as sshCon from paramiko import Channel from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from io import StringIO from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import ClosedBufferException , RecvReady , BetweenBitException , \\ TimeToFirstBitException , SSHExceptionConn from typing import Any , AnyStr , Optional , Union , Tuple , Type log = logging . getLogger ( 'sshBufferControl' ) warnings . filterwarnings ( \"ignore\" , category = ResourceWarning ) warnings . filterwarnings ( \"ignore\" , category = DeprecationWarning ) class sshBufferControl ( sshCon ): promptTextTuple = ( '$' , '>' , '#' , '@' , ']' , '~' ) escapeChars = re . compile ( r '((\\x9B|\\x1B\\[)[0-?]*[ -\\/]*[@-~]|[\\x00|\\x0e-\\x1f])' ) def __init__ ( self , arguments , ** kwargs ): \"\"\" init function for sshBufferControl. - :param arguments: (NameSpaceDict) - :param kwargs: This is only here to satisfy recommended class inheritance issues. \"\"\" super ( sshBufferControl , self ) . __init__ ( arguments , ** kwargs ) def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union [ AnyStr , Tuple ]] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ): try : # print(f'=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n') tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: { e } ' ) log . debug ( f \"[DEBUG] for _parseOutput: { traceback . format_exc () } \" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ) . strip () return tmpOut . replace ( tmpPrompt , '' ) . replace ( cmd , '' ) . strip () if not super ( sshBufferControl , self ) . checkConnection ( sshChannel = environment ): log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: { cmd } \" ) out = StringIO () output = \"\" if isinstance ( prompt , str ): prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of { self . runTimeout } was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: { traceback . format_exc () } \" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: { e } ' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: { cmd } on: { environment } ' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: { traceback . format_exc () } ' ) raise e finally : out . truncate ( 0 ) del out # log.debug(f\"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\") # print(f\"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\") return output def _bufferControl ( self , channel : EnvironmentControls , cmd : AnyStr , out : StringIO , prompt : Optional [ Union [ AnyStr , Tuple ]] = False , unsafe : bool = False , ** kwargs ) -> None : \"\"\" Controls Sending and Receiving Data Through Paramiko SSH Channels. It is recommended that this method not be touched. \"\"\" runTimeout , firstBitTimeout , betweenBitTimeout , delay = self . _parseTimeouts ( ** kwargs ) try : while channel . recv_ready (): log . debug ( 'There is old data left in the Channel Buffer. Clearing...' ) channel . recv ( 65536 ) sleep ( .1 ) # log.debug(f'Waiting to send for channel: [{cmd}] : [{str(channel)[18:20]}] Closed: {channel.closed}') while channel . send_ready () is not True : # log.debug(f\"Channel rec: {channel.recv(65536)}\") if channel . isClosed : log . debug ( f 'Channel closed while waiting to send command: [ { cmd } ] : [ { str ( channel )[ 18 : 20 ] } ]' ) return sleep ( .1 ) # log.debug(f'Send buffer ready to receive... ' # f'For channel: [{cmd}] : [{str(channel)[18:20]}] Closed: {channel.isClosed}') self . _bufferSendWait ( data = f ' { cmd } ' , channel = channel ) # loop through and record all data in recv buffer # log.debug(f'Receive buffer ready... Fetching output data from receive buffer for ' # f'channel: [{cmd}] : [{str(channel)[18:20]}] Closed: {channel.isClosed}') if prompt : # if prompt was captured use prompt as terminator log . debug ( f \"Executing on { channel . _id } cmd: { cmd } with prompt: { prompt } \" ) self . _bufferGenerator ( channel = channel , out = out , runTimeout = runTimeout , firstBitTimeout = firstBitTimeout , betweenBitTimeout = betweenBitTimeout , delay = delay , endText = prompt , cmd = cmd ) elif unsafe : log . debug ( f \"Executing on { channel . _id } cmd: { cmd } with unsafe mode\" ) # log.debug(f'Fetching data in unsafe mode for channel: ' # f'[{cmd}] : [{str(channel)[18:20]}] Closed: {channel.closed}') sshBufferControl . _bufferTimeToFirstBit ( channel , time . time () + 1 , delay ) while channel . recv_ready () is True : if channel . isClosed : return out . write ( channel . recv ( 65536 ) . decode ( 'utf-8' )) sleep ( .1 ) else : if 'echo CMDEND' in cmd : endText = 'CMDEND' else : endText = ( '$' , '>' , '#' , '@' , ']' , '~' ) log . debug ( f \"Executing on { channel . _id } cmd: { cmd } with END TEXT: { endText } \" ) try : self . _bufferGenerator ( channel = channel , out = out , runTimeout = runTimeout , firstBitTimeout = firstBitTimeout , betweenBitTimeout = betweenBitTimeout , delay = delay , endText = endText , cmd = cmd ) except BetweenBitException : log . debug ( \"noprompt execution has returned a timeout failure for BetweenBit. Ignoring\" ) except TimeToFirstBitException : log . debug ( \"noprompt execution has returned a timeout failure for Time To First Bit. Ignoring\" ) # log.debug(f'Channel releasing buffer: [{str(channel)[18:20]}] Closed: {channel.closed}') except socket . error as e : log . debug ( f 'An error occurred: { e } ' ) channel . get_transport () . close () raise SSHExceptionConn ( f \"Connection Error: { e } \" ) from e def _capturePrompt ( self , channel : Channel , out : StringIO ) -> Union [ bool , AnyStr ]: \"\"\" Captures Shell Prompt to be used in _bufferControl. \"\"\" log . info ( \" === Attempting to capture prompt via BufferControl\" ) out . truncate ( 0 ) log . info ( f 'Capturing Shell Prompt for channel: [ { str ( channel )[ 18 : 20 ] } ]' ) self . _bufferControl ( channel , ' ' , out , unsafe = True ) # match prompt on the last line of output to account for failed logins prompt = out . getvalue () . splitlines () # log.debug(f\" === The prompt raw value is: {prompt}\\n\") if prompt : prompt = re . search ( '[ \\\\ w \\\\ W].+' , prompt [ - 1 ]) if prompt : prompt = prompt . group () . strip () log . debug ( f \" === The search prompt value is: { prompt } \" ) return sshBufferControl . escapeChars . sub ( '' , sshBufferControl . _decodeStringEscape ( prompt )) . strip () return False def _passwdWait ( self , channel : Channel , out : StringIO , cmd : AnyStr = '' , ** kwargs ) -> Optional [ bool ]: \"\"\" Wait for the password prompt before inputting the password. \"\"\" try : return self . _bufferWait ( channel = channel , out = out , runTimeout = kwargs . get ( \"runTimeout\" , self . runTimeout ), firstBitTimeout = 0 , betweenBitTimeout = kwargs . get ( \"betweenBitTimeout\" , self . betweenBitTimeout ), delay = kwargs . get ( \"delay\" , self . delay ), endText = ( 'assword' , 'assword:' ) + sshBufferControl . promptTextTuple , cmd = cmd ) except BetweenBitException : log . debug ( \"_passwdWait execution has returned a timeout failure for BetweenBit. Ignoring\" ) except TimeToFirstBitException : log . debug ( \"_passwdWait execution has returned a timeout failure for Time To First Bit. Ignoring\" ) return None def _promptWait ( self , channel : Channel , out : StringIO , cmd : AnyStr = '' , clear : bool = True , ** kwargs ) -> Optional [ bool ]: \"\"\" Waits for Login Attempt to Return Prompt. \"\"\" try : if clear : out . truncate ( 0 ) for _ in range ( int ( kwargs . get ( 'insertNewLine' , 0 ))): sleep ( 0.01 ) self . _bufferControl ( channel , '' , out , unsafe = True ) return self . _bufferWait ( channel = channel , out = out , runTimeout = kwargs . get ( \"runTimeout\" , self . runTimeout ), firstBitTimeout = 0 , betweenBitTimeout = kwargs . get ( \"betweenBitTimeout\" , self . betweenBitTimeout ), delay = kwargs . get ( \"delay\" , self . delay ), endText = kwargs . get ( 'endText' , sshBufferControl . promptTextTuple ), cmd = cmd , exitOnAnything = True ) except BetweenBitException : log . debug ( \"_promptWait execution has returned a timeout failure for BetweenBit. Ignoring\" ) except TimeToFirstBitException : log . debug ( \"_promptWait execution has returned a timeout failure for Time To First Bit. Ignoring\" ) return False def _parseTimeouts ( self , ** kwargs ) -> Tuple [ int , int , int , float ]: \"\"\" This parses custom timeouts for different commands running through the sshBufferControl. - :param kwargs: - :return: (tuple) (int, int, int, float) \"\"\" runTimeout = kwargs . get ( 'runTimeout' , self . runTimeout ) firstBitTimeout = kwargs . get ( 'firstBitTimeout' , self . firstBitTimeout ) betweenBitTimeout = kwargs . get ( 'betweenBitTimeout' , self . betweenBitTimeout ) delay = kwargs . get ( 'delay' , self . delay ) if firstBitTimeout > runTimeout : firstBitTimeout = int ( runTimeout * 0.8 ) if betweenBitTimeout > runTimeout : betweenBitTimeout = int ( runTimeout * 0.1 ) if delay > int (( runTimeout / 5 )): delay = 0.2 # log.debug(f'runTimeout: {runTimeout}, firstBitTimeout: {firstBitTimeout}, ' # f'betweenBitTimeout: {betweenBitTimeout}, delay: {delay}') return runTimeout , firstBitTimeout , betweenBitTimeout , delay @staticmethod def _decodeStringEscape ( s : AnyStr , encoding : AnyStr = 'utf-8' ) -> AnyStr : # print(f'String:\\n======\\n{s}\\n=======\\n\\n\\nString type: {type(s)}\\n') try : return ( s . encode ( 'latin1' ) # To bytes, required by 'unicode-escape' . decode ( 'unicode-escape' ) # Perform the actual octal-escaping decode . encode ( 'latin1' ) # 1:1 mapping back to bytes . decode ( encoding )) # Decode original encoding` except : return ( s . encode ( 'unicode-escape' ) . decode ( 'utf-8' ) . encode ( 'latin1' ) . decode ( 'unicode-escape' ) . encode ( 'latin1' ) . decode ( encoding )) @staticmethod def _processString ( s : AnyStr , encoding : AnyStr = 'utf-8' ) -> AnyStr : return sshBufferControl . escapeChars . sub ( '' , sshBufferControl . _decodeStringEscape ( s . strip (), encoding )) . strip () @staticmethod def _bufferTimeToFirstBit ( channel : Channel , fbEnd : float , delay : float ) -> True : \"\"\" This is a helper tool used by _bufferGenerator and _bufferWait to use the time to first bit timeout value. Please review those method's doc strings for more information. - :param channel: - :param fbEnd: - :param delay: - :return: \"\"\" while time . time () <= fbEnd : if channel . recv_ready () is True : return True if channel . closed : raise ClosedBufferException ( \"Channel closed while attempting to get first bit!\" ) sleep ( delay ) raise TimeToFirstBitException ( \"Time to First Bit exceeded timeout: %s \" % str ( fbEnd )) @staticmethod def _bufferBetweenBitWait ( channel : Channel , bbEnd : float , delay : float ) -> Any : \"\"\" This is a helper tool used by _bufferGenerator and _bufferWait to use the betweenBitTimeout value. Please review those method's doc strings for more information. :param channel: (Channel) :param bbEnd: (float) :param delay: (float) :return: \"\"\" while time . time () <= bbEnd : try : if channel . recv_ready () is True : return channel . recv ( 65536 ) . decode ( 'utf-8' ) except socket . timeout as e : if channel . closed : raise ClosedBufferException ( \"Channel closed while attempting to read from it!\" ) from e except Exception as e : log . error ( f 'ERROR: for method _bufferBetweenBitWait: { e } ' ) log . debug ( f '[DEBUG] for method _bufferBetweenBitWait: { traceback . format_exc () } ' ) sleep ( delay ) raise BetweenBitException ( f \"IO Timeout: waited for { str ( bbEnd ) } \" ) @staticmethod def _bufferSendWait ( data : AnyStr , channel : EnvironmentControls ) -> None : try : channel . sendall ( data ) channel . sendall ( ' \\n ' ) except socket . timeout as e : if channel . isClosed : raise ClosedBufferException ( 'Channel closed while attempting to send data to it!' ) from e @staticmethod def _endTextParser ( endText : Union [ Tuple , AnyStr ]) -> Tuple [ Type , Union [ Tuple , AnyStr ]]: \"\"\" This gets the endTextType so it doens't need to be parsed more then once. If it is a string then it also removes escape characters from it. Escape characters can be found in the endtext when the prompt was captured as use for the end text. :param endText: (Tuple or Str) :return: tuple \"\"\" endTextType = type ( endText ) # log.debug(f\"endText before: {repr(endText)}\") if endTextType is str : endText = sshBufferControl . escapeChars . sub ( '' , endText ) . strip () # log.debug(f\"endText after: {repr(endText)}\") return endTextType , endText @staticmethod def _endTextAnalyzer ( outValue : AnyStr , endText : Union [ Tuple , AnyStr ], endTextType : Type , cmd : Optional [ AnyStr ] = None ) -> bool : \"\"\" This is a helper tool used by _bufferGenerator and _bufferWait to help deal with the 'endText' value. Please review those method's doc strings for more information. - :param outValue: - :param endText: - :param endTextType: - :param cmd: - :return: \"\"\" # print(f\"\\n==== _endTextAnalyzer\\ncmd: {cmd}\\noutValue: \\n{outValue}\\n\\n\" # f\"endText: {repr(endText)}\\nendTextType: {endTextType}\\n====\\n\") if not outValue : return True if not endText : return True if cmd and cmd in outValue . splitlines ()[ - 1 ]: return True if endTextType is tuple : line = sshBufferControl . escapeChars . sub ( '' , outValue . splitlines ()[ - 1 ]) . strip () for item in endText : if len ( item ) == 1 and line . endswith ( item ): return False elif len ( item ) > 1 and item in line : return False return True if endTextType is str : if endText == 'CMDEND' : for line in ( sshBufferControl . _processString ( line . strip ()) for line in outValue . splitlines () if cmd not in line and endText in line ): if line == endText : return False # print(f\"\\n=== Compare: {repr(endText)} - {repr(outValue.splitlines()[-1])}\") return endText not in outValue . splitlines ()[ - 1 ] return True @staticmethod def _bufferGenerator ( channel : Channel , out : StringIO , runTimeout : int , firstBitTimeout : int , betweenBitTimeout : int , delay : float , endText : Union [ Tuple , AnyStr ] = \"\" , closeOnFailure : bool = False , cmd : Optional [ AnyStr ] = None ) -> None : \"\"\" This is a tool designed to yield data from a Paramiko Channel buffer with several timeout controls - :param channel: The Paramiko Channel - :param runTimeout: (int/float) A positive number that determines how long the method should wait to complete the command. - :param firstBitTimeout: (int/float) A positive number that determines how long the method should wait for the first bit to arrive. - :param betweenBitTimeout: (int/float) A positive number that determines how long the method should wait inbetween bits of data on the buffer before assuming that the command isn't going to return any. - :param delay: (float) A positive number that determines how long the method should wait inbetween trying to listen for activity on the Paramiko Channel Buffer. - :param endText: (string/tuple) A string or tuple of strings that the method will look for in the strings that come from the buffer. If found then the method will assume the end of the buffer. This can be the prompt or 'CMDEND' or an example of the tuple is: ('$', '>', '#', '@', ']', '~') - :return: \"\"\" # print(f\"\\n==== BufferGenerator\\nRun Timeout: {runTimeout}\\nFirst Bit Timeout: {firstBitTimeout}\\n\" # f\"Between Bit Timeout: {betweenBitTimeout}\\nDelay: {delay}\\n\") # print(f\"\\n==== The endText is: {endText}\\n\") outValue = \"\" endTextType , endText = sshBufferControl . _endTextParser ( endText ) endTime = time . time () + runTimeout sshBufferControl . _bufferTimeToFirstBit ( channel , time . time () + firstBitTimeout , delay ) while time . time () <= endTime and not channel . closed and sshBufferControl . _endTextAnalyzer ( outValue , endText , endTextType , cmd = cmd ): outValue = sshBufferControl . _bufferBetweenBitWait ( channel , time . time () + betweenBitTimeout , delay ) # print(f'outValue: {outValue}') out . write ( outValue ) if sshBufferControl . _endTextAnalyzer ( outValue , endText , endTextType , cmd = cmd ) and not channel . closed and closeOnFailure : if time . time () > endTime : log . debug ( f 'Buffer wait expired before all data was gathered and prompt ' f 'appeared: [ { str ( channel )[ 18 : 20 ] } ]: Closed: { channel . closed } ' ) else : log . debug ( f 'Buffer timeout expired attempting to gather the next piece ' f 'of data: [ { str ( channel )[ 18 : 20 ] } ]: Closed: { channel . closed } ' ) channel . close () @staticmethod def _bufferWait ( channel : Channel , out : StringIO , runTimeout : int , firstBitTimeout : int , betweenBitTimeout : int , delay : float , endText : Union [ Tuple , AnyStr ], cmd : AnyStr = '' , exitOnAnything : bool = False ) -> Optional [ bool ]: \"\"\" This is a tool designed to write to a StringIO from a Paramiko Channel buffer. It has multiple time controls - :param channel: The Paramiko Channel - :param out: StringIO object - :param runTimeout: (int/float) A positive number that determines how long the method should wait to complete the command. - :param firstBitTimeout: (int/float) A positive number that determines how long the method should wait for the first bit to arrive. - :param betweenBitTimeout: (int/float) A positive number that determines how long the method should wait inbetween bits of data on the buffer before assuming that the command isn't going to return any. - :param delay: (float) A positive number that determines how long the method should wait inbetween trying to listen for activity on the Paramiko Channel Buffer. - :param endText: (string/tuple) A string or tuple of strings that the method will look for in the strings that come from the buffer. If found then the method will assume the end of the buffer. This can be the prompt or 'CMDEND' or an example of the tuple is: ('$', '>', '#', '@', ']', '~') - :param cmd: (string) OPTIONAL. If provided this method will simply confirm that the cmd string is not in the returning value and thus assumes that command has been executed and doesn't attempt to pull any additional bits from the Paramiko Channel buffer. - :param exitOnAnything: (bool) OPTIONAL. If provided this will exit one any bits are received. - :return: None if 'cmd' is used, True if 'exitOnAnything' is used, False for anything else. \"\"\" # print(f\"\\n==== BufferWait\\nRun Timeout: {runTimeout}\\nFirst Bit Timeout: {firstBitTimeout}\\n\" # f\"Between Bit Timeout: {betweenBitTimeout}\\nDelay: {delay}\\n\") outValue = out . getvalue () endTextType , endText = sshBufferControl . _endTextParser ( endText ) endTime = time . time () + runTimeout if firstBitTimeout : sshBufferControl . _bufferTimeToFirstBit ( channel , time . time () + firstBitTimeout , delay ) while time . time () <= endTime and not channel . closed and sshBufferControl . _endTextAnalyzer ( outValue , endText , endTextType , cmd = cmd ): if exitOnAnything and len ( outValue ) > 0 : if len ( cmd ) > 0 and cmd in outValue . splitlines ()[ - 1 ]: continue return None out . write ( sshBufferControl . _bufferBetweenBitWait ( channel , time . time () + betweenBitTimeout , delay )) outValue = out . getvalue () if time . time () > endTime or channel . closed or len ( outValue ) == 0 : return False if endTextType is tuple : return sshBufferControl . escapeChars . sub ( '' , outValue . splitlines ()[ - 1 ]) . strip () . endswith ( endText ) if endTextType is str : return endText not in outValue . splitlines ()[ - 1 ] return None Variables log Classes sshBufferControl class sshBufferControl ( arguments , ** kwargs ) Ancestors (in MRO) sshConnector.sshConnect.sshConnect Class variables arguments escapeChars promptTextTuple ssh Static methods processRootLogin def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' Instance variables mainEnvironment Methods checkConnection def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed createConn def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh disconnect def disconnect ( self ) -> None Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. View Source def disconnect ( self ) -> None : \"\"\" Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. \"\"\" try : self . mainEnvironment . get_transport (). close () self . ssh . close () except Exception as e : log . error ( f 'Disconnect failed: {e}' ) log . debug ( f '[DEBUG]: Disconnect failure reason: {traceback.format_exc()}' ) executeOnEnvironment def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output","title":"Sshbuffercontrol"},{"location":"reference/sshBufferControl/#module-sshbuffercontrol","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 12/10/14 # Description: This is the second class in the sshConnector chain. Here we are simply adding the ability to run commands # on a Linux box via SSH. This is necessary to progress to user management and threading. import logging import socket import re import time import warnings import traceback from time import sleep from sshConnector.sshConnect import sshConnect as sshCon from paramiko import Channel from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from io import StringIO from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import ClosedBufferException , RecvReady , BetweenBitException , \\ TimeToFirstBitException , SSHExceptionConn from typing import Any , AnyStr , Optional , Union , Tuple , Type log = logging . getLogger ( 'sshBufferControl' ) warnings . filterwarnings ( \"ignore\" , category = ResourceWarning ) warnings . filterwarnings ( \"ignore\" , category = DeprecationWarning ) class sshBufferControl ( sshCon ): promptTextTuple = ( '$' , '>' , '#' , '@' , ']' , '~' ) escapeChars = re . compile ( r '((\\x9B|\\x1B\\[)[0-?]*[ -\\/]*[@-~]|[\\x00|\\x0e-\\x1f])' ) def __init__ ( self , arguments , ** kwargs ): \"\"\" init function for sshBufferControl. - :param arguments: (NameSpaceDict) - :param kwargs: This is only here to satisfy recommended class inheritance issues. \"\"\" super ( sshBufferControl , self ) . __init__ ( arguments , ** kwargs ) def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union [ AnyStr , Tuple ]] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ): try : # print(f'=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n') tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: { e } ' ) log . debug ( f \"[DEBUG] for _parseOutput: { traceback . format_exc () } \" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ) . strip () return tmpOut . replace ( tmpPrompt , '' ) . replace ( cmd , '' ) . strip () if not super ( sshBufferControl , self ) . checkConnection ( sshChannel = environment ): log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: { cmd } \" ) out = StringIO () output = \"\" if isinstance ( prompt , str ): prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of { self . runTimeout } was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: { traceback . format_exc () } \" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: { e } ' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: { cmd } on: { environment } ' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: { traceback . format_exc () } ' ) raise e finally : out . truncate ( 0 ) del out # log.debug(f\"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\") # print(f\"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\") return output def _bufferControl ( self , channel : EnvironmentControls , cmd : AnyStr , out : StringIO , prompt : Optional [ Union [ AnyStr , Tuple ]] = False , unsafe : bool = False , ** kwargs ) -> None : \"\"\" Controls Sending and Receiving Data Through Paramiko SSH Channels. It is recommended that this method not be touched. \"\"\" runTimeout , firstBitTimeout , betweenBitTimeout , delay = self . _parseTimeouts ( ** kwargs ) try : while channel . recv_ready (): log . debug ( 'There is old data left in the Channel Buffer. Clearing...' ) channel . recv ( 65536 ) sleep ( .1 ) # log.debug(f'Waiting to send for channel: [{cmd}] : [{str(channel)[18:20]}] Closed: {channel.closed}') while channel . send_ready () is not True : # log.debug(f\"Channel rec: {channel.recv(65536)}\") if channel . isClosed : log . debug ( f 'Channel closed while waiting to send command: [ { cmd } ] : [ { str ( channel )[ 18 : 20 ] } ]' ) return sleep ( .1 ) # log.debug(f'Send buffer ready to receive... ' # f'For channel: [{cmd}] : [{str(channel)[18:20]}] Closed: {channel.isClosed}') self . _bufferSendWait ( data = f ' { cmd } ' , channel = channel ) # loop through and record all data in recv buffer # log.debug(f'Receive buffer ready... Fetching output data from receive buffer for ' # f'channel: [{cmd}] : [{str(channel)[18:20]}] Closed: {channel.isClosed}') if prompt : # if prompt was captured use prompt as terminator log . debug ( f \"Executing on { channel . _id } cmd: { cmd } with prompt: { prompt } \" ) self . _bufferGenerator ( channel = channel , out = out , runTimeout = runTimeout , firstBitTimeout = firstBitTimeout , betweenBitTimeout = betweenBitTimeout , delay = delay , endText = prompt , cmd = cmd ) elif unsafe : log . debug ( f \"Executing on { channel . _id } cmd: { cmd } with unsafe mode\" ) # log.debug(f'Fetching data in unsafe mode for channel: ' # f'[{cmd}] : [{str(channel)[18:20]}] Closed: {channel.closed}') sshBufferControl . _bufferTimeToFirstBit ( channel , time . time () + 1 , delay ) while channel . recv_ready () is True : if channel . isClosed : return out . write ( channel . recv ( 65536 ) . decode ( 'utf-8' )) sleep ( .1 ) else : if 'echo CMDEND' in cmd : endText = 'CMDEND' else : endText = ( '$' , '>' , '#' , '@' , ']' , '~' ) log . debug ( f \"Executing on { channel . _id } cmd: { cmd } with END TEXT: { endText } \" ) try : self . _bufferGenerator ( channel = channel , out = out , runTimeout = runTimeout , firstBitTimeout = firstBitTimeout , betweenBitTimeout = betweenBitTimeout , delay = delay , endText = endText , cmd = cmd ) except BetweenBitException : log . debug ( \"noprompt execution has returned a timeout failure for BetweenBit. Ignoring\" ) except TimeToFirstBitException : log . debug ( \"noprompt execution has returned a timeout failure for Time To First Bit. Ignoring\" ) # log.debug(f'Channel releasing buffer: [{str(channel)[18:20]}] Closed: {channel.closed}') except socket . error as e : log . debug ( f 'An error occurred: { e } ' ) channel . get_transport () . close () raise SSHExceptionConn ( f \"Connection Error: { e } \" ) from e def _capturePrompt ( self , channel : Channel , out : StringIO ) -> Union [ bool , AnyStr ]: \"\"\" Captures Shell Prompt to be used in _bufferControl. \"\"\" log . info ( \" === Attempting to capture prompt via BufferControl\" ) out . truncate ( 0 ) log . info ( f 'Capturing Shell Prompt for channel: [ { str ( channel )[ 18 : 20 ] } ]' ) self . _bufferControl ( channel , ' ' , out , unsafe = True ) # match prompt on the last line of output to account for failed logins prompt = out . getvalue () . splitlines () # log.debug(f\" === The prompt raw value is: {prompt}\\n\") if prompt : prompt = re . search ( '[ \\\\ w \\\\ W].+' , prompt [ - 1 ]) if prompt : prompt = prompt . group () . strip () log . debug ( f \" === The search prompt value is: { prompt } \" ) return sshBufferControl . escapeChars . sub ( '' , sshBufferControl . _decodeStringEscape ( prompt )) . strip () return False def _passwdWait ( self , channel : Channel , out : StringIO , cmd : AnyStr = '' , ** kwargs ) -> Optional [ bool ]: \"\"\" Wait for the password prompt before inputting the password. \"\"\" try : return self . _bufferWait ( channel = channel , out = out , runTimeout = kwargs . get ( \"runTimeout\" , self . runTimeout ), firstBitTimeout = 0 , betweenBitTimeout = kwargs . get ( \"betweenBitTimeout\" , self . betweenBitTimeout ), delay = kwargs . get ( \"delay\" , self . delay ), endText = ( 'assword' , 'assword:' ) + sshBufferControl . promptTextTuple , cmd = cmd ) except BetweenBitException : log . debug ( \"_passwdWait execution has returned a timeout failure for BetweenBit. Ignoring\" ) except TimeToFirstBitException : log . debug ( \"_passwdWait execution has returned a timeout failure for Time To First Bit. Ignoring\" ) return None def _promptWait ( self , channel : Channel , out : StringIO , cmd : AnyStr = '' , clear : bool = True , ** kwargs ) -> Optional [ bool ]: \"\"\" Waits for Login Attempt to Return Prompt. \"\"\" try : if clear : out . truncate ( 0 ) for _ in range ( int ( kwargs . get ( 'insertNewLine' , 0 ))): sleep ( 0.01 ) self . _bufferControl ( channel , '' , out , unsafe = True ) return self . _bufferWait ( channel = channel , out = out , runTimeout = kwargs . get ( \"runTimeout\" , self . runTimeout ), firstBitTimeout = 0 , betweenBitTimeout = kwargs . get ( \"betweenBitTimeout\" , self . betweenBitTimeout ), delay = kwargs . get ( \"delay\" , self . delay ), endText = kwargs . get ( 'endText' , sshBufferControl . promptTextTuple ), cmd = cmd , exitOnAnything = True ) except BetweenBitException : log . debug ( \"_promptWait execution has returned a timeout failure for BetweenBit. Ignoring\" ) except TimeToFirstBitException : log . debug ( \"_promptWait execution has returned a timeout failure for Time To First Bit. Ignoring\" ) return False def _parseTimeouts ( self , ** kwargs ) -> Tuple [ int , int , int , float ]: \"\"\" This parses custom timeouts for different commands running through the sshBufferControl. - :param kwargs: - :return: (tuple) (int, int, int, float) \"\"\" runTimeout = kwargs . get ( 'runTimeout' , self . runTimeout ) firstBitTimeout = kwargs . get ( 'firstBitTimeout' , self . firstBitTimeout ) betweenBitTimeout = kwargs . get ( 'betweenBitTimeout' , self . betweenBitTimeout ) delay = kwargs . get ( 'delay' , self . delay ) if firstBitTimeout > runTimeout : firstBitTimeout = int ( runTimeout * 0.8 ) if betweenBitTimeout > runTimeout : betweenBitTimeout = int ( runTimeout * 0.1 ) if delay > int (( runTimeout / 5 )): delay = 0.2 # log.debug(f'runTimeout: {runTimeout}, firstBitTimeout: {firstBitTimeout}, ' # f'betweenBitTimeout: {betweenBitTimeout}, delay: {delay}') return runTimeout , firstBitTimeout , betweenBitTimeout , delay @staticmethod def _decodeStringEscape ( s : AnyStr , encoding : AnyStr = 'utf-8' ) -> AnyStr : # print(f'String:\\n======\\n{s}\\n=======\\n\\n\\nString type: {type(s)}\\n') try : return ( s . encode ( 'latin1' ) # To bytes, required by 'unicode-escape' . decode ( 'unicode-escape' ) # Perform the actual octal-escaping decode . encode ( 'latin1' ) # 1:1 mapping back to bytes . decode ( encoding )) # Decode original encoding` except : return ( s . encode ( 'unicode-escape' ) . decode ( 'utf-8' ) . encode ( 'latin1' ) . decode ( 'unicode-escape' ) . encode ( 'latin1' ) . decode ( encoding )) @staticmethod def _processString ( s : AnyStr , encoding : AnyStr = 'utf-8' ) -> AnyStr : return sshBufferControl . escapeChars . sub ( '' , sshBufferControl . _decodeStringEscape ( s . strip (), encoding )) . strip () @staticmethod def _bufferTimeToFirstBit ( channel : Channel , fbEnd : float , delay : float ) -> True : \"\"\" This is a helper tool used by _bufferGenerator and _bufferWait to use the time to first bit timeout value. Please review those method's doc strings for more information. - :param channel: - :param fbEnd: - :param delay: - :return: \"\"\" while time . time () <= fbEnd : if channel . recv_ready () is True : return True if channel . closed : raise ClosedBufferException ( \"Channel closed while attempting to get first bit!\" ) sleep ( delay ) raise TimeToFirstBitException ( \"Time to First Bit exceeded timeout: %s \" % str ( fbEnd )) @staticmethod def _bufferBetweenBitWait ( channel : Channel , bbEnd : float , delay : float ) -> Any : \"\"\" This is a helper tool used by _bufferGenerator and _bufferWait to use the betweenBitTimeout value. Please review those method's doc strings for more information. :param channel: (Channel) :param bbEnd: (float) :param delay: (float) :return: \"\"\" while time . time () <= bbEnd : try : if channel . recv_ready () is True : return channel . recv ( 65536 ) . decode ( 'utf-8' ) except socket . timeout as e : if channel . closed : raise ClosedBufferException ( \"Channel closed while attempting to read from it!\" ) from e except Exception as e : log . error ( f 'ERROR: for method _bufferBetweenBitWait: { e } ' ) log . debug ( f '[DEBUG] for method _bufferBetweenBitWait: { traceback . format_exc () } ' ) sleep ( delay ) raise BetweenBitException ( f \"IO Timeout: waited for { str ( bbEnd ) } \" ) @staticmethod def _bufferSendWait ( data : AnyStr , channel : EnvironmentControls ) -> None : try : channel . sendall ( data ) channel . sendall ( ' \\n ' ) except socket . timeout as e : if channel . isClosed : raise ClosedBufferException ( 'Channel closed while attempting to send data to it!' ) from e @staticmethod def _endTextParser ( endText : Union [ Tuple , AnyStr ]) -> Tuple [ Type , Union [ Tuple , AnyStr ]]: \"\"\" This gets the endTextType so it doens't need to be parsed more then once. If it is a string then it also removes escape characters from it. Escape characters can be found in the endtext when the prompt was captured as use for the end text. :param endText: (Tuple or Str) :return: tuple \"\"\" endTextType = type ( endText ) # log.debug(f\"endText before: {repr(endText)}\") if endTextType is str : endText = sshBufferControl . escapeChars . sub ( '' , endText ) . strip () # log.debug(f\"endText after: {repr(endText)}\") return endTextType , endText @staticmethod def _endTextAnalyzer ( outValue : AnyStr , endText : Union [ Tuple , AnyStr ], endTextType : Type , cmd : Optional [ AnyStr ] = None ) -> bool : \"\"\" This is a helper tool used by _bufferGenerator and _bufferWait to help deal with the 'endText' value. Please review those method's doc strings for more information. - :param outValue: - :param endText: - :param endTextType: - :param cmd: - :return: \"\"\" # print(f\"\\n==== _endTextAnalyzer\\ncmd: {cmd}\\noutValue: \\n{outValue}\\n\\n\" # f\"endText: {repr(endText)}\\nendTextType: {endTextType}\\n====\\n\") if not outValue : return True if not endText : return True if cmd and cmd in outValue . splitlines ()[ - 1 ]: return True if endTextType is tuple : line = sshBufferControl . escapeChars . sub ( '' , outValue . splitlines ()[ - 1 ]) . strip () for item in endText : if len ( item ) == 1 and line . endswith ( item ): return False elif len ( item ) > 1 and item in line : return False return True if endTextType is str : if endText == 'CMDEND' : for line in ( sshBufferControl . _processString ( line . strip ()) for line in outValue . splitlines () if cmd not in line and endText in line ): if line == endText : return False # print(f\"\\n=== Compare: {repr(endText)} - {repr(outValue.splitlines()[-1])}\") return endText not in outValue . splitlines ()[ - 1 ] return True @staticmethod def _bufferGenerator ( channel : Channel , out : StringIO , runTimeout : int , firstBitTimeout : int , betweenBitTimeout : int , delay : float , endText : Union [ Tuple , AnyStr ] = \"\" , closeOnFailure : bool = False , cmd : Optional [ AnyStr ] = None ) -> None : \"\"\" This is a tool designed to yield data from a Paramiko Channel buffer with several timeout controls - :param channel: The Paramiko Channel - :param runTimeout: (int/float) A positive number that determines how long the method should wait to complete the command. - :param firstBitTimeout: (int/float) A positive number that determines how long the method should wait for the first bit to arrive. - :param betweenBitTimeout: (int/float) A positive number that determines how long the method should wait inbetween bits of data on the buffer before assuming that the command isn't going to return any. - :param delay: (float) A positive number that determines how long the method should wait inbetween trying to listen for activity on the Paramiko Channel Buffer. - :param endText: (string/tuple) A string or tuple of strings that the method will look for in the strings that come from the buffer. If found then the method will assume the end of the buffer. This can be the prompt or 'CMDEND' or an example of the tuple is: ('$', '>', '#', '@', ']', '~') - :return: \"\"\" # print(f\"\\n==== BufferGenerator\\nRun Timeout: {runTimeout}\\nFirst Bit Timeout: {firstBitTimeout}\\n\" # f\"Between Bit Timeout: {betweenBitTimeout}\\nDelay: {delay}\\n\") # print(f\"\\n==== The endText is: {endText}\\n\") outValue = \"\" endTextType , endText = sshBufferControl . _endTextParser ( endText ) endTime = time . time () + runTimeout sshBufferControl . _bufferTimeToFirstBit ( channel , time . time () + firstBitTimeout , delay ) while time . time () <= endTime and not channel . closed and sshBufferControl . _endTextAnalyzer ( outValue , endText , endTextType , cmd = cmd ): outValue = sshBufferControl . _bufferBetweenBitWait ( channel , time . time () + betweenBitTimeout , delay ) # print(f'outValue: {outValue}') out . write ( outValue ) if sshBufferControl . _endTextAnalyzer ( outValue , endText , endTextType , cmd = cmd ) and not channel . closed and closeOnFailure : if time . time () > endTime : log . debug ( f 'Buffer wait expired before all data was gathered and prompt ' f 'appeared: [ { str ( channel )[ 18 : 20 ] } ]: Closed: { channel . closed } ' ) else : log . debug ( f 'Buffer timeout expired attempting to gather the next piece ' f 'of data: [ { str ( channel )[ 18 : 20 ] } ]: Closed: { channel . closed } ' ) channel . close () @staticmethod def _bufferWait ( channel : Channel , out : StringIO , runTimeout : int , firstBitTimeout : int , betweenBitTimeout : int , delay : float , endText : Union [ Tuple , AnyStr ], cmd : AnyStr = '' , exitOnAnything : bool = False ) -> Optional [ bool ]: \"\"\" This is a tool designed to write to a StringIO from a Paramiko Channel buffer. It has multiple time controls - :param channel: The Paramiko Channel - :param out: StringIO object - :param runTimeout: (int/float) A positive number that determines how long the method should wait to complete the command. - :param firstBitTimeout: (int/float) A positive number that determines how long the method should wait for the first bit to arrive. - :param betweenBitTimeout: (int/float) A positive number that determines how long the method should wait inbetween bits of data on the buffer before assuming that the command isn't going to return any. - :param delay: (float) A positive number that determines how long the method should wait inbetween trying to listen for activity on the Paramiko Channel Buffer. - :param endText: (string/tuple) A string or tuple of strings that the method will look for in the strings that come from the buffer. If found then the method will assume the end of the buffer. This can be the prompt or 'CMDEND' or an example of the tuple is: ('$', '>', '#', '@', ']', '~') - :param cmd: (string) OPTIONAL. If provided this method will simply confirm that the cmd string is not in the returning value and thus assumes that command has been executed and doesn't attempt to pull any additional bits from the Paramiko Channel buffer. - :param exitOnAnything: (bool) OPTIONAL. If provided this will exit one any bits are received. - :return: None if 'cmd' is used, True if 'exitOnAnything' is used, False for anything else. \"\"\" # print(f\"\\n==== BufferWait\\nRun Timeout: {runTimeout}\\nFirst Bit Timeout: {firstBitTimeout}\\n\" # f\"Between Bit Timeout: {betweenBitTimeout}\\nDelay: {delay}\\n\") outValue = out . getvalue () endTextType , endText = sshBufferControl . _endTextParser ( endText ) endTime = time . time () + runTimeout if firstBitTimeout : sshBufferControl . _bufferTimeToFirstBit ( channel , time . time () + firstBitTimeout , delay ) while time . time () <= endTime and not channel . closed and sshBufferControl . _endTextAnalyzer ( outValue , endText , endTextType , cmd = cmd ): if exitOnAnything and len ( outValue ) > 0 : if len ( cmd ) > 0 and cmd in outValue . splitlines ()[ - 1 ]: continue return None out . write ( sshBufferControl . _bufferBetweenBitWait ( channel , time . time () + betweenBitTimeout , delay )) outValue = out . getvalue () if time . time () > endTime or channel . closed or len ( outValue ) == 0 : return False if endTextType is tuple : return sshBufferControl . escapeChars . sub ( '' , outValue . splitlines ()[ - 1 ]) . strip () . endswith ( endText ) if endTextType is str : return endText not in outValue . splitlines ()[ - 1 ] return None","title":"Module sshBufferControl"},{"location":"reference/sshBufferControl/#variables","text":"log","title":"Variables"},{"location":"reference/sshBufferControl/#classes","text":"","title":"Classes"},{"location":"reference/sshBufferControl/#sshbuffercontrol","text":"class sshBufferControl ( arguments , ** kwargs )","title":"sshBufferControl"},{"location":"reference/sshBufferControl/#ancestors-in-mro","text":"sshConnector.sshConnect.sshConnect","title":"Ancestors (in MRO)"},{"location":"reference/sshBufferControl/#class-variables","text":"arguments escapeChars promptTextTuple ssh","title":"Class variables"},{"location":"reference/sshBufferControl/#static-methods","text":"","title":"Static methods"},{"location":"reference/sshBufferControl/#processrootlogin","text":"def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -'","title":"processRootLogin"},{"location":"reference/sshBufferControl/#instance-variables","text":"mainEnvironment","title":"Instance variables"},{"location":"reference/sshBufferControl/#methods","text":"","title":"Methods"},{"location":"reference/sshBufferControl/#checkconnection","text":"def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed","title":"checkConnection"},{"location":"reference/sshBufferControl/#createconn","text":"def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh","title":"createConn"},{"location":"reference/sshBufferControl/#disconnect","text":"def disconnect ( self ) -> None Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. View Source def disconnect ( self ) -> None : \"\"\" Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. \"\"\" try : self . mainEnvironment . get_transport (). close () self . ssh . close () except Exception as e : log . error ( f 'Disconnect failed: {e}' ) log . debug ( f '[DEBUG]: Disconnect failure reason: {traceback.format_exc()}' )","title":"disconnect"},{"location":"reference/sshBufferControl/#executeonenvironment","text":"def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output","title":"executeOnEnvironment"},{"location":"reference/sshChannelEnvironment/","text":"Module sshChannelEnvironment View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson # Version: 0.5.0 # Date: 12/10/14 # Description: import logging import uuid import traceback import re from paramiko import Channel from threading import RLock from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import SSHExceptionConn from typing import Optional , Union , AnyStr , Any log = logging . getLogger ( 'sshChannelEnvironment' ) # noinspection PyMissingConstructor,PyUnusedLocal class sshChannelWrapper ( Channel ): \"\"\" This is a special wrapper class for the Paramiko Channel class. This is designed to store additional information regarding the status of environment associated with the channel. IE: console type, user permissions, PATH and so on. \"\"\" _id = None __MAIN__ = None _defaultPromptReg = r \"bash-\\d\\.\\d[#|$|>|@|~]\" _defaultPromptCompileReg = None def __new__ ( cls , parentInst : Any , ** kwargs ): parentInst . __class__ = sshChannelWrapper return parentInst def __init__ ( self , parentInst : Any , main : bool = False , ** kwargs ): self . _id = str ( uuid . uuid4 ()) self . __MAIN__ = main self . _defaultPromptCompileReg = re . compile ( self . _defaultPromptReg ) @property def isMain ( self ): return self . __MAIN__ # noinspection PyMissingConstructor,PyUnusedLocal class sshEnvironment ( sshChannelWrapper ): \"\"\" Uses the sshChannelWrapper and is used by the EnvironmentControls. This handles the state of the ssh Environment it is associated with. Such as the prompt/current user/console and so on. \"\"\" BASH = \"BASH\" CSH = \"CSH\" ZSH = \"ZSH\" SH = \"SH\" NOSH = \"NO_SH\" ORACLE = \"ORACLE\" MYSQL = \"MYSQL\" __USER_ESCALATION__ = 1 __CONSOLE_ESCALATION__ = 2 __ENVIRONMENT_CHANGE__ = 3 __UNKNOWN__ = 4 __TYPE_DICT__ = { 'user' : 1 , 'console' : 2 , 'env' : 3 , 'unknown' : 4 } __INVERTED_TYPE_DICT__ = { 1 : 'User' , 2 : 'Console' , 3 : 'Environment' , 4 : 'Unknown' } # Item template Type, Command, Input # InputType is one of the static variables above # Name: This is the console or userName or the name of the environment variable being changed # Command is a string/dictionary that will be ran on the console # Input is usually the password used. But can also be any other expected input for the command to complete. # _template = (type, name, command, input) _template = ( None , None , None , None ) prompt : str = None _consoleStack : list = None _CONSOLESTACK_LOCK : RLock = None def __new__ ( cls , parentInst : Any , * args , ** kwargs ): parentInst . __class__ = sshEnvironment return parentInst def __init__ ( self , parentInst : Any , ** kwargs ): # log.debug(\"Creating the Console Stack Object\") self . _CONSOLESTACK_LOCK = RLock () self . consoleStack = kwargs . get ( 'consoleStack' , []) def __iter__ ( self ): if self . consoleStack : for item in self . consoleStack : yield item def printStack ( self ) -> str : \"\"\" This returns a string. It is a nicely formatted list of the history of console changes on the Environment\"\"\" output = \"\" for item in self . consoleStack : if not item or len ( item ) < 4 : continue typeStr = self . __INVERTED_TYPE_DICT__ . get ( item [ 0 ]) output += f ' { typeStr } : { item [ 1 ] } Using Command: { item [ 2 ] } AdditionalInput: { item [ 3 ] } \\n ' return output def push ( self , item : Union [ tuple , str ], name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool : \"\"\" Append a new change to the console. This is to record a change to the environment. :param item: (either tuple or str) :param name: (str) :param escalationType: (int) This should either be (__USER_ESCALATION__) 1, (__CONSOLE_ESCALATION__) 2, (__ENVIRONMENT_CHANGE__) 3 or (__UNKNOWN__) 4. :param additionalInput: (str) Optional additional information for example a password. :return: (bool) \"\"\" def _parsePushInput ( _item , _name , _escalationType , _additionalInput ): if type ( _item ) is not tuple and ( type ( _escalationType ) is int or type ( _escalationType ) is str ): if type ( _escalationType ) is str : _escalationType = self . __TYPE_DICT__ . get ( _escalationType ) or 4 elif abs ( _escalationType ) > 4 or _escalationType <= 0 : _escalationType = 4 return _escalationType , _name , _item , _additionalInput if type ( _item ) is tuple and len ( _item ) == 4 and type ( _item [ 0 ] is int ): return _item if type ( _item ) is str or type ( _item ) is dict and _escalationType is None : return self . __USER_ESCALATION__ , _name , _item , _additionalInput return False command = _parsePushInput ( item , name , escalationType , additionalInput ) if command is False : return False self . consoleStack . append ( command ) return True def pull ( self ) -> tuple : \"\"\" This pulls from the consoleStack removing the item and returning it. :return: (tuple) The escalation information formated as a tuple \"\"\" if len ( self . consoleStack ) >= 1 : return self . consoleStack . pop () return tuple () def peak ( self ) -> tuple : \"\"\" Just like a peak it simply returns the last console change without removing it. \"\"\" if self . consoleStack : return self . consoleStack [ - 1 ] def peer ( self , num ) -> tuple : \"\"\" Just like a peer for a stack this allows one to look at an particular index of the stack. \"\"\" try : return self . consoleStack [ num ] except : return () def getPreviousEscalation ( self ) -> tuple : return self . peak () def getPreviousEscalationType ( self ) -> int : return self . peak ()[ 0 ] def getUserList ( self ) -> list : \"\"\" This returns a list of users that are currently logged into this environment in order of there login. \"\"\" def _filterUsers ( item ): return self . __USER_ESCALATION__ == item [ 0 ] def _userGenerator ( itemListToGen ): output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output if not self . consoleStack : return [] # itemList = list(filter(_filterUsers, self.consoleStack)) return _userGenerator ( filter ( _filterUsers , self . consoleStack )) def getCurrentUser ( self ) -> str : \"\"\" Returns a string that is the name of the current user authenticated on this environment. \"\"\" currentUsers = self . getUserList () if currentUsers : return currentUsers [ - 1 ] return '' def getConsoleList ( self ) -> list : \"\"\" LIke 'getUserList' but returns a list of the console escalations in order that they happened. \"\"\" def _filterConsoles ( item ): return self . __CONSOLE_ESCALATION__ == item [ 0 ] def _consoleGenerator ( itemListToGen ): output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output # itemList = list(filter(_filterConsoles, self.consoleStack)) return _consoleGenerator ( filter ( _filterConsoles , self . consoleStack )) def getCurrentConsole ( self ) -> str : \"\"\" Like 'getCurrentUser' but gets what the current console type is. \"\"\" consoles = self . getConsoleList () if consoles : return consoles [ - 1 ] return \"BASH\" def resetEnvironment ( self ) -> None : \"\"\" Resets the environment console stack \"\"\" numOfPulls = 0 for item in reversed ( self . consoleStack ): if item [ 0 ] == self . __USER_ESCALATION__ or item [ 0 ] == self . __CONSOLE_ESCALATION__ : break numOfPulls += 1 for x in range ( numOfPulls ): self . consoleStack . pop () @property def console ( self ): return self . getCurrentConsole () @property def userCount ( self ): return len ( self . getUserList ()) @property def consoleStack ( self ): try : with self . _CONSOLESTACK_LOCK : return self . _consoleStack except RuntimeError : pass @consoleStack . setter def consoleStack ( self , value ): try : with self . _CONSOLESTACK_LOCK : self . _consoleStack = value except RuntimeError : pass @consoleStack . deleter def consoleStack ( self ): if self . _consoleStack : del self . _consoleStack @property def numEscalations ( self ): def _filterUsers ( item ): return self . __USER_ESCALATION__ == item [ 0 ] or self . __CONSOLE_ESCALATION__ == item [ 0 ] if not self . consoleStack : return 0 return len ( list ( filter ( _filterUsers , self . consoleStack ))) @property def numUsers ( self ): return len ( self . getUserList ()) @property def userList ( self ): return self . getUserList () @property def whoami ( self ): return self . getCurrentUser () # noinspection PyMissingConstructor,PyUnusedLocal class EnvironmentControls ( sshEnvironment ): \"\"\" This is meant to be an easy access to the methods within the sshEnvironmentControl class. There that class can handle any ssh Environment/Paramiko ssh Channel this wraps a single Channel and when calling the methods within this class it uses the methods of the same name within its sshParent (an instance of sshEnvironmentControl) and passes itself as the environment to be acted on. This also adds locks for thread safe actions and is designed to work along side a Command Container. \"\"\" _LOCK : RLock = None dead : bool = None sshChannel : Channel = None sshParent : Any = None _label : str = None active : bool = None command : Optional [ str ] = None _commandObject : Any = None timeout : Optional [ Union [ int , float ]] = None kwargs : Optional [ dict ] = {} customChannel : bool = None def __new__ ( cls , parentInst : Any , ** kwargs ): parentInst . __class__ = EnvironmentControls return parentInst def __init__ ( self , parentInst : Any , ** kwargs ): \"\"\" Creates the EnvironmentControls object. Read more about the class in the class comments above. - :param sshParent: This is a sshThreader object. The sshThread class passes itself to the container. - :param label: This is a string identifying this channel. This is unnecessary as we already had a UUID. However the label need not be uniq which can lead to some interesting combinations. Such as two \"MySQL\" channels. The search can look for MySQL instead of a specific UUID. It doesn't matter which one it finds. - :return: \"\"\" self . dead = False self . active = False self . _label = kwargs . get ( 'label' , '' ) self . customChannel = kwargs . get ( 'customChannel' , True if self . _label else False ) self . _LOCK = RLock () self . sshParent = kwargs . get ( 'sshParent' ) if kwargs . get ( 'autoConnect' , False ): self . sshParent . createConn () def __enter__ ( self ): if not self . _LOCK . acquire (): raise RuntimeError ( f \"Channel ID: { self . EnvironmentID } The Lock failed within the time frame: 60\" ) if not self . sshParent . checkConnection ( self ): raise SSHExceptionConn ( \"Connection closed!\" ) self . active = True return self # noinspection PyProtectedMember def __exit__ ( self , exc_type , exc_val , exc_tb ): try : self . _LOCK . release () except RuntimeError as e : log . debug ( f \"An RuntimeError occurred while attempting to release lock: { e } \" ) except Exception as e : log . debug ( f \"An unknown error occurred while releasing the lock: { e } \" ) finally : if not self . checkConnection (): log . debug ( \"About to disconnect channel because checkConnection returned False\" ) self . disconnectEnvironment () if not self . _LOCK . _is_owned (): self . active = False del self . commandObject def __hash__ ( self ): return hash ( self . EnvironmentID ) def executeOnEnvironment ( self , * args , ** kwargs ) -> AnyStr : \"\"\" Takes the param command is passes it to executeOnEnvironment function in 'sshCommand' class with the environment and prompt variables as well. - :return: \"\"\" kwargs . pop ( 'environment' , None ) return self . sshParent . executeOnEnvironment ( self , * args , ** kwargs ) def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the escalate method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . escalate ( * args , ** kwargs ) def becomeRoot ( self , * args , ** kwargs ) -> bool : \"\"\" This is specific logic just for handling becoming the root user. This hopefully will be deprecated once sshUserControl becomes more thread friendly. - :return: bool: True if successful or already root, false if it didn't even try. \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . becomeRoot ( * args , ** kwargs ) def becomeUser ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the becomeUser method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . becomeUser ( * args , ** kwargs ) def consoleEscalation ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the consoleEscalation method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . consoleEscalation ( * args , ** kwargs ) def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the environmentChange method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . environmentChange ( * args , ** kwargs ) def getPrompt ( self , reCapturePrompt : bool = False ) -> Optional [ str ]: \"\"\" Wrapper for the getPrompt method on the sshEnvironmentControl \"\"\" return self . sshParent . getPrompt ( self , reCapturePrompt = reCapturePrompt ) def isPromptDefault ( self , reCapturePrompt : bool = False ) -> bool : \"\"\" Uses getPrompt and attempts to determine if prompt is the default bash prompt ie: bash-5.1$ \"\"\" return self . _defaultPromptCompileReg . search ( self . getPrompt ( reCapturePrompt )) is not None def checkConnection ( self ) -> bool : \"\"\" Wrapper for the checkConnection method on the sshEnvironmentControl \"\"\" if not self . sshParent . checkConnection ( self ): self . dead = True return False return True def disconnectEnvironment ( self , * args , ** kwargs ) -> bool : \"\"\" This attempts to log out of the channel gracefully exiting the terminal connection. This should normally be called inside of a thread although it doesn't matter. This also reduces 'channelCount' variable by one. - :param args: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :param kwargs: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :return: (bool) False if it is already disconnected True for everything else \"\"\" with self . _LOCK : try : if not self . checkConnection (): log . debug ( 'Connection already closed this will set \"dead\" variable to True and remove this from ' 'the Environment list' ) return False self . sshParent . disconnect ( environment = self ) except SSHExceptionConn : log . debug ( \"Failed to complete logout correctly! This could because of a corrupt userList!\" ) except Exception as e : log . error ( f \"error in disconnectEnvironment: { e } \" ) log . debug ( f \"[DEBUG] for disconnectEnvironment: { traceback . format_exc () } \" ) finally : self . dead = True self . sshParent . removeEnvironment ( self ) return True def logoutCurrentUser ( self ) -> None : \"\"\" Wrapper for the logoutCurrentUser method on the sshEnvironmentControl \"\"\" self . sshParent . logoutCurrentUser ( environment = self ) def logoutConsole ( self , * args , ** kwargs ) -> bool : \"\"\" A override method for logoutConsole on the sshEnvironmentControl class \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . logoutConsole ( * args , ** kwargs ) def getPasswordFor ( self , name : str ) -> str : \"\"\" Gets the current recorded password for the user specified by the 'name' parameter. :param name: (str) the name of the user that you are getting a password for. :return: (str) \"\"\" def _filterUserByName ( x ): return name . lower () in str ( x [ 1 ]) . lower () if name in self . sshParent . usermap : return self . sshParent . usermap . get ( name , \"\" ) for item in filter ( _filterUserByName , self . consoleStack ): if item [ - 1 ] is not None : return item [ - 1 ] return \"\" # noinspection PyProtectedMember def _becomePreviousUser ( self , * args , ** kwargs ) -> sshEnvironment : \"\"\" De-escalates the current user in a provided channel \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . _becomePreviousUser ( * args , ** kwargs ) @property def isClosed ( self ): return self . dead or not self . sshParent . checkConnection ( sshChannel = self ) @property def commandObject ( self ): return self . _commandObject @commandObject . setter def commandObject ( self , value ): self . command = value . command self . timeout = value . timeout self . kwargs = value . kwargs @commandObject . deleter def commandObject ( self ): self . _commandObject = None self . timeout = None self . kwargs = None @property def userName ( self ): return self . whoami @property def EnvironmentID ( self ): return self . _id @property def label ( self ): if self . __MAIN__ : return \"MAIN\" return self . _label @label . setter def label ( self , value ): if not self . __MAIN__ == \"MAIN\" or str ( value ) == \"MAIN\" : self . _label = str ( value ) Variables log Classes EnvironmentControls class EnvironmentControls ( parentInst : Any , ** kwargs ) This is meant to be an easy access to the methods within the sshEnvironmentControl class. There that class can handle any ssh Environment/Paramiko ssh Channel this wraps a single Channel and when calling the methods within this class it uses the methods of the same name within its sshParent (an instance of sshEnvironmentControl) and passes itself as the environment to be acted on. This also adds locks for thread safe actions and is designed to work along side a Command Container. Ancestors (in MRO) sshChannelEnvironment.sshEnvironment sshChannelEnvironment.sshChannelWrapper paramiko.channel.Channel paramiko.util.ClosingContextManager Class variables BASH CSH MYSQL NOSH ORACLE SH ZSH active command customChannel dead kwargs prompt sshChannel sshParent timeout Instance variables EnvironmentID commandObject console consoleStack isClosed isMain label numEscalations numUsers userCount userList userName whoami Methods becomeRoot def becomeRoot ( self , * args , ** kwargs ) -> bool This is specific logic just for handling becoming the root user. This hopefully will be deprecated once sshUserControl becomes more thread friendly. :return: bool: True if successful or already root, false if it didn't even try. View Source def becomeRoot ( self , * args , ** kwargs ) -> bool : \"\"\" This is specific logic just for handling becoming the root user. This hopefully will be deprecated once sshUserControl becomes more thread friendly. - :return: bool: True if successful or already root, false if it didn' t even try . \"\"\" kwargs.update({' environment ': self}) return self.sshParent.becomeRoot(*args, **kwargs) becomeUser def becomeUser ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the becomeUser method on the sshEnvironmentControl View Source def becomeUser ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the becomeUser method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . becomeUser ( * args , ** kwargs ) checkConnection def checkConnection ( self ) -> bool Wrapper for the checkConnection method on the sshEnvironmentControl View Source def checkConnection ( self ) -> bool : \"\"\" Wrapper for the checkConnection method on the sshEnvironmentControl \"\"\" if not self . sshParent . checkConnection ( self ) : self . dead = True return False return True close def close ( self ) Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their .Transport is closed or when they are garbage collected. View Source def close(self): \"\"\" Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their `.Transport` is closed or when they are garbage collected. \"\"\" self.lock.acquire() try: # only close the pipe when the user explicitly closes the channel. # otherwise they will get unpleasant surprises. (and do it before # checking self.closed, since the remote host may have already # closed the connection.) if self._pipe is not None: self._pipe.close() self._pipe = None if not self.active or self.closed: return msgs = self._close_internal() finally: self.lock.release() for m in msgs: if m is not None: self.transport._send_user_message(m) consoleEscalation def consoleEscalation ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the consoleEscalation method on the sshEnvironmentControl View Source def consoleEscalation ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the consoleEscalation method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . consoleEscalation ( * args , ** kwargs ) disconnectEnvironment def disconnectEnvironment ( self , * args , ** kwargs ) -> bool This attempts to log out of the channel gracefully exiting the terminal connection. This should normally be called inside of a thread although it doesn't matter. This also reduces 'channelCount' variable by one. :param args: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. :param kwargs: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. :return: (bool) False if it is already disconnected True for everything else View Source def disconnectEnvironment ( self , * args , ** kwargs ) -> bool : \"\"\" This attempts to log out of the channel gracefully exiting the terminal connection. This should normally be called inside of a thread although it doesn't matter. This also reduces 'channelCount' variable by one. - :param args: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :param kwargs: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :return: (bool) False if it is already disconnected True for everything else \"\"\" with self . _LOCK : try : if not self . checkConnection () : log . debug ( 'Connection already closed this will set \"dead\" variable to True and remove this from ' 'the Environment list' ) return False self . sshParent . disconnect ( environment = self ) except SSHExceptionConn : log . debug ( \"Failed to complete logout correctly! This could because of a corrupt userList!\" ) except Exception as e : log . error ( f \"error in disconnectEnvironment: {e}\" ) log . debug ( f \"[DEBUG] for disconnectEnvironment: {traceback.format_exc()}\" ) finally : self . dead = True self . sshParent . removeEnvironment ( self ) return True environmentChange def environmentChange ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the environmentChange method on the sshEnvironmentControl View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the environmentChange method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . environmentChange ( * args , ** kwargs ) escalate def escalate ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the escalate method on the sshEnvironmentControl View Source def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the escalate method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . escalate ( * args , ** kwargs ) exec_command def exec_command ( self , command ) Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. Parameters: Name Type Description Default command str a shell command to execute. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def exec_command ( self , command ) : \"\"\" Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. :param str command: a shell command to execute. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"exec\" ) m . add_boolean ( True ) m . add_string ( command ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () executeOnEnvironment def executeOnEnvironment ( self , * args , ** kwargs ) -> ~ AnyStr Takes the param command is passes it to executeOnEnvironment function in 'sshCommand' class with the environment and prompt variables as well. :return: View Source def executeOnEnvironment ( self , * args , ** kwargs ) -> AnyStr : \"\"\" Takes the param command is passes it to executeOnEnvironment function in 'sshCommand' class with the environment and prompt variables as well. - :return: \"\"\" kwargs . pop ( 'environment' , None ) return self . sshParent . executeOnEnvironment ( self , * args , ** kwargs ) exit_status_ready def exit_status_ready ( self ) Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in recv_exit_status . Note that the server may not return an exit status in some cases (like bad servers). Returns: Type Description None True if recv_exit_status will return immediately, else False . .. versionadded:: 1.7.3 View Source def exit_status_ready ( self ) : \" \"\" Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in `recv_exit_status`. Note that the server may not return an exit status in some cases (like bad servers). :return: ``True`` if `recv_exit_status` will return immediately, else ``False``. .. versionadded:: 1.7.3 \"\" \" return self . closed or self . status_event . is_set () fileno def fileno ( self ) Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's select module to work. The first time fileno is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) Returns: Type Description None an OS-level file descriptor ( int ) .. warning:: This method causes channel reads to be slightly less efficient. View Source def fileno ( self ) : \" \"\" Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's ``select`` module to work. The first time ``fileno`` is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) :return: an OS-level file descriptor (`int`) .. warning:: This method causes channel reads to be slightly less efficient. \"\" \" self . lock . acquire () try : if self . _pipe is not None : return self . _pipe . fileno () # create the pipe and feed in any existing data self . _pipe = pipe . make_pipe () p1 , p2 = pipe . make_or_pipe ( self . _pipe ) self . in_buffer . set _event ( p1 ) self . in_stderr_buffer . set _event ( p2 ) return self . _pipe . fileno () finally : self . lock . release () getConsoleList def getConsoleList ( self ) -> list LIke 'getUserList' but returns a list of the console escalations in order that they happened. View Source def getConsoleList ( self ) -> list : \"\"\" LIke ' getUserList ' but returns a list of the console escalations in order that they happened. \"\"\" def _filterConsoles ( item ) : return self . __CONSOLE_ESCALATION__ == item [ 0 ] def _consoleGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output # itemList = list ( filter ( _filterConsoles , self . consoleStack )) return _consoleGenerator ( filter ( _filterConsoles , self . consoleStack )) getCurrentConsole def getCurrentConsole ( self ) -> str Like 'getCurrentUser' but gets what the current console type is. View Source def getCurrentConsole ( self ) -> str : \"\"\" Like 'getCurrentUser' but gets what the current console type is. \"\"\" consoles = self . getConsoleList () if consoles : return consoles [ - 1 ] return \"BASH\" getCurrentUser def getCurrentUser ( self ) -> str Returns a string that is the name of the current user authenticated on this environment. View Source def getCurrentUser ( self ) -> str : \"\"\" Returns a string that is the name of the current user authenticated on this environment. \"\"\" currentUsers = self . getUserList () if currentUsers : return currentUsers [ - 1 ] return '' getPasswordFor def getPasswordFor ( self , name : str ) -> str Gets the current recorded password for the user specified by the 'name' parameter. Parameters: Name Type Description Default name None (str) the name of the user that you are getting a password for. None Returns: Type Description None (str) View Source def getPasswordFor ( self , name : str ) -> str : \"\"\" Gets the current recorded password for the user specified by the ' name ' parameter. :param name: (str) the name of the user that you are getting a password for. :return: (str) \"\"\" def _filterUserByName ( x ) : return name . lower () in str ( x [ 1 ]). lower () if name in self . sshParent . usermap : return self . sshParent . usermap . get ( name , \"\" ) for item in filter ( _filterUserByName , self . consoleStack ) : if item [ - 1 ] is not None : return item [ - 1 ] return \"\" getPreviousEscalation def getPreviousEscalation ( self ) -> tuple View Source def getPreviousEscalation ( self ) -> tuple : return self . peak () getPreviousEscalationType def getPreviousEscalationType ( self ) -> int View Source def getPreviousEscalationType ( self ) -> int : return self . peak ()[ 0 ] getPrompt def getPrompt ( self , reCapturePrompt : bool = False ) -> Optional [ str ] Wrapper for the getPrompt method on the sshEnvironmentControl View Source def getPrompt ( self , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" Wrapper for the getPrompt method on the sshEnvironmentControl \"\"\" return self . sshParent . getPrompt ( self , reCapturePrompt = reCapturePrompt ) getUserList def getUserList ( self ) -> list This returns a list of users that are currently logged into this environment in order of there login. View Source def getUserList ( self ) -> list : \"\"\" This returns a list of users that are currently logged into this environment in order of there login. \"\"\" def _filterUsers ( item ) : return self . __USER_ESCALATION__ == item [ 0 ] def _userGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output if not self . consoleStack : return [] # itemList = list ( filter ( _filterUsers , self . consoleStack )) return _userGenerator ( filter ( _filterUsers , self . consoleStack )) get_id def get_id ( self ) Return the int ID # for this channel. The channel ID is unique across a .Transport and usually a small number. It's also the number passed to .ServerInterface.check_channel_request when determining whether to accept a channel request in server mode. View Source def get_id ( self ) : \" \"\" Return the `int` ID # for this channel. The channel ID is unique across a `.Transport` and usually a small number. It's also the number passed to `.ServerInterface.check_channel_request` when determining whether to accept a channel request in server mode. \"\" \" return self . chanid get_name def get_name ( self ) Get the name of this channel that was previously set by set_name . View Source def get_name ( self ) : \" \"\" Get the name of this channel that was previously set by `set_name`. \"\" \" return self . _name get_pty def get_pty ( self , term = 'vt100' , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with invoke_shell . It isn't necessary (or desirable) to call this method if you're going to execute a single command with exec_command . Parameters: Name Type Description Default term str the terminal type to emulate (for example, 'vt100' ) None width int width (in characters) of the terminal screen None height int height (in characters) of the terminal screen None width_pixels int width (in pixels) of the terminal screen None height_pixels int height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def get_pty ( self , term = \"vt100\" , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 , ) : \" \"\" Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with `invoke_shell`. It isn't necessary (or desirable) to call this method if you're going to execute a single command with `exec_command`. :param str term: the terminal type to emulate (for example, ``'vt100'``) :param int width: width (in characters) of the terminal screen :param int height: height (in characters) of the terminal screen :param int width_pixels: width (in pixels) of the terminal screen :param int height_pixels: height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"pty-req\" ) m . add_boolean ( True ) m . add_string ( term ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) m . add_string ( bytes ()) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () get_transport def get_transport ( self ) Return the .Transport associated with this channel. View Source def get_transport(self): \"\"\" Return the `.Transport` associated with this channel. \"\"\" return self.transport getpeername def getpeername ( self ) Return the address of the remote side of this Channel, if possible. This simply wraps .Transport.getpeername , used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call 'getpeername' .) View Source def getpeername ( self ): \"\"\" Return the address of the remote side of this Channel, if possible. This simply wraps `.Transport.getpeername`, used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call ``'getpeername'``.) \"\"\" return self . transport . getpeername () gettimeout def gettimeout ( self ) Returns the timeout in seconds (as a float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking or settimeout . View Source def gettimeout ( self ) : \" \"\" Returns the timeout in seconds (as a float) associated with socket operations, or ``None`` if no timeout is set. This reflects the last call to `setblocking` or `settimeout`. \"\" \" return self . timeout invoke_shell def invoke_shell ( self ) Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call get_pty before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_shell ( self ) : \" \"\" Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call `get_pty` before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"shell\" ) m . add_boolean ( True ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () invoke_subsystem def invoke_subsystem ( self , subsystem ) Request a subsystem on the server (for example, sftp ). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. Parameters: Name Type Description Default subsystem str name of the subsystem being requested. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_subsystem ( self , subsystem ) : \" \"\" Request a subsystem on the server (for example, ``sftp``). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. :param str subsystem: name of the subsystem being requested. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"subsystem\" ) m . add_boolean ( True ) m . add_string ( subsystem ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () isPromptDefault def isPromptDefault ( self , reCapturePrompt : bool = False ) -> bool Uses getPrompt and attempts to determine if prompt is the default bash prompt ie: bash-5.1$ View Source def isPromptDefault ( self , reCapturePrompt : bool = False ) -> bool : \"\"\" Uses getPrompt and attempts to determine if prompt is the default bash prompt ie: bash-5.1$ \"\"\" return self . _defaultPromptCompileReg . search ( self . getPrompt ( reCapturePrompt )) is not None logoutConsole def logoutConsole ( self , * args , ** kwargs ) -> bool A override method for logoutConsole on the sshEnvironmentControl class View Source def logoutConsole ( self , * args , ** kwargs ) -> bool : \"\"\" A override method for logoutConsole on the sshEnvironmentControl class \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . logoutConsole ( * args , ** kwargs ) logoutCurrentUser def logoutCurrentUser ( self ) -> None Wrapper for the logoutCurrentUser method on the sshEnvironmentControl View Source def logoutCurrentUser ( self ) -> None : \"\"\" Wrapper for the logoutCurrentUser method on the sshEnvironmentControl \"\"\" self . sshParent . logoutCurrentUser ( environment = self ) makefile def makefile ( self , * params ) Return a file-like object associated with this channel. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. Returns: Type Description None .ChannelFile object which can be used for Python file I/O. View Source def makefile ( self , * params ) : \" \"\" Return a file-like object associated with this channel. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. :return: `.ChannelFile` object which can be used for Python file I/O. \"\" \" return ChannelFile ( * ( [ self ] + list ( params ))) makefile_stderr def makefile_stderr ( self , * params ) Return a file-like object associated with this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. Returns: Type Description None .ChannelStderrFile object which can be used for Python file I/O. .. versionadded:: 1.1 View Source def makefile_stderr ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. :returns: `.ChannelStderrFile` object which can be used for Python file I/O. .. versionadded:: 1.1 \"\" \" return ChannelStderrFile ( * ( [ self ] + list ( params ))) makefile_stdin def makefile_stdin ( self , * params ) Return a file-like object associated with this channel's stdin stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. Returns: Type Description None .ChannelStdinFile object which can be used for Python file I/O. .. versionadded:: 2.6 View Source def makefile_stdin ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stdin stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. :returns: `.ChannelStdinFile` object which can be used for Python file I/O. .. versionadded:: 2.6 \"\" \" return ChannelStdinFile ( * ( [ self ] + list ( params ))) peak def peak ( self ) -> tuple Just like a peak it simply returns the last console change without removing it. View Source def peak ( self ) -> tuple : \"\"\" Just like a peak it simply returns the last console change without removing it. \"\"\" if self . consoleStack : return self . consoleStack [ - 1 ] peer def peer ( self , num ) -> tuple Just like a peer for a stack this allows one to look at an particular index of the stack. View Source def peer ( self , num ) -> tuple : \"\"\" Just like a peer for a stack this allows one to look at an particular index of the stack. \"\"\" try : return self . consoleStack [ num ] except : return () printStack def printStack ( self ) -> str This returns a string. It is a nicely formatted list of the history of console changes on the Environment View Source def printStack ( self ) -> str : \"\"\" This returns a string. It is a nicely formatted list of the history of console changes on the Environment\"\"\" output = \"\" for item in self . consoleStack : if not item or len ( item ) < 4 : continue typeStr = self . __INVERTED_TYPE_DICT__ . get ( item [ 0 ]) output += f ' { typeStr }: { item [ 1 ]} Using Command : { item [ 2 ]} AdditionalInput : { item [ 3 ]} \\ n ' return output pull def pull ( self ) -> tuple This pulls from the consoleStack removing the item and returning it. Returns: Type Description None (tuple) The escalation information formated as a tuple View Source def pull ( self ) -> tuple : \"\"\" This pulls from the consoleStack removing the item and returning it. :return: (tuple) The escalation information formated as a tuple \"\"\" if len ( self . consoleStack ) >= 1 : return self . consoleStack . pop () return tuple () push def push ( self , item : Union [ tuple , str ], name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool Append a new change to the console. This is to record a change to the environment. Parameters: Name Type Description Default item None (either tuple or str) None name None (str) None escalationType None (int) This should either be ( USER_ESCALATION ) 1, ( CONSOLE_ESCALATION ) 2, ( ENVIRONMENT_CHANGE ) 3 or ( UNKNOWN ) 4. None additionalInput None (str) Optional additional information for example a password. None Returns: Type Description None (bool) View Source def push ( self , item : Union [ tuple, str ] , name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool : \"\"\" Append a new change to the console. This is to record a change to the environment. :param item: (either tuple or str) :param name: (str) :param escalationType: (int) This should either be (__USER_ESCALATION__) 1, (__CONSOLE_ESCALATION__) 2, (__ENVIRONMENT_CHANGE__) 3 or (__UNKNOWN__) 4. :param additionalInput: (str) Optional additional information for example a password. :return: (bool) \"\"\" def _parsePushInput ( _item , _name , _escalationType , _additionalInput ) : if type ( _item ) is not tuple and ( type ( _escalationType ) is int or type ( _escalationType ) is str ) : if type ( _escalationType ) is str : _escalationType = self . __TYPE_DICT__ . get ( _escalationType ) or 4 elif abs ( _escalationType ) > 4 or _escalationType <= 0 : _escalationType = 4 return _escalationType , _name , _item , _additionalInput if type ( _item ) is tuple and len ( _item ) == 4 and type ( _item [ 0 ] is int ) : return _item if type ( _item ) is str or type ( _item ) is dict and _escalationType is None : return self . __USER_ESCALATION__ , _name , _item , _additionalInput return False command = _parsePushInput ( item , name , escalationType , additionalInput ) if command is False : return False self . consoleStack . append ( command ) return True recv def recv ( self , nbytes ) Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data, as a bytes . Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . View Source def recv ( self , nbytes ) : \" \"\" Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data, as a `bytes`. :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. \"\" \" try : out = self . in_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out recv_exit_status def recv_exit_status ( self ) Return the exit status from the process on the server. This is mostly useful for retrieving the results of an exec_command . If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current .Transport or session's window_size (e.g. that set by the default_window_size kwarg for .Transport.__init__ ) will cause .recv_exit_status to hang indefinitely if it is called prior to a sufficiently large .Channel.recv (or if there are no threads calling .Channel.recv in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. Returns: Type Description None the exit code (as an int ) of the process on the server. .. versionadded:: 1.2 View Source def recv_exit_status ( self ) : \" \"\" Return the exit status from the process on the server. This is mostly useful for retrieving the results of an `exec_command`. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current `.Transport` or session's ``window_size`` (e.g. that set by the ``default_window_size`` kwarg for `.Transport.__init__`) will cause `.recv_exit_status` to hang indefinitely if it is called prior to a sufficiently large `.Channel.recv` (or if there are no threads calling `.Channel.recv` in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. :return: the exit code (as an `int`) of the process on the server. .. versionadded:: 1.2 \"\" \" self . status_event . wait () assert self . status_event . is_set () return self . exit_status recv_ready def recv_ready ( self ) Returns true if data is buffered and ready to be read from this channel. A False result does not mean that the channel has closed; it means you may need to wait before more data arrives. Returns: Type Description None True if a recv call on this channel would immediately return at least one byte; False otherwise. View Source def recv_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel. A ``False`` result does not mean that the channel has closed; it means you may need to wait before more data arrives. :return: ``True`` if a `recv` call on this channel would immediately return at least one byte; ``False`` otherwise. \"\" \" return self . in_buffer . read_ready () recv_stderr def recv_stderr ( self , nbytes ) Receive data from the channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data as a bytes Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . .. versionadded:: 1.1 View Source def recv_stderr ( self , nbytes ) : \" \"\" Receive data from the channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data as a `bytes` :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" try : out = self . in_stderr_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out recv_stderr_ready def recv_stderr_ready ( self ) Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. Returns: Type Description None True if a recv_stderr call on this channel would immediately return at least one byte; False otherwise. .. versionadded:: 1.1 View Source def recv_stderr_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. :return: ``True`` if a `recv_stderr` call on this channel would immediately return at least one byte; ``False`` otherwise. .. versionadded:: 1.1 \"\" \" return self . in_stderr_buffer . read_ready () request_forward_agent def request_forward_agent ( self , handler ) Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! Parameters: Name Type Description Default handler None a required callable handler to use for incoming SSH Agent connections None Returns: Type Description None True if we are ok, else False (at that time we always return ok) Raises: Type Description None SSHException in case of channel problem. View Source @open_only def request_forward_agent ( self , handler ) : \"\"\" Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! :param handler: a required callable handler to use for incoming SSH Agent connections :return: True if we are ok, else False (at that time we always return ok) :raises: SSHException in case of channel problem. \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"auth-agent-req@openssh.com\" ) m . add_boolean ( False ) self . transport . _send_user_message ( m ) self . transport . _set_forward_agent_handler ( handler ) return True request_x11 def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None ) Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc: 4254 :: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake , random cookie , and that the cookie be checked and replaced by the real cookie when a connection request is received . If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using .Transport.accept . The handler's calling signature is:: handler ( channel : Channel , ( address : str , port : int )) Parameters: Name Type Description Default screen_number int the x11 screen number (0, 10, etc.) None auth_protocol str the name of the X11 authentication method used; if none is given, \"MIT-MAGIC-COOKIE-1\" is used None auth_cookie str hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated None single_connection bool if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) None handler None an optional callable handler to use for incoming X11 connections None Returns: Type Description None the auth_cookie used View Source @ open_only def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None , ): \"\"\" Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc:`4254`:: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake, random cookie, and that the cookie be checked and replaced by the real cookie when a connection request is received. If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using `.Transport.accept`. The handler's calling signature is:: handler(channel: Channel, (address: str, port: int)) :param int screen_number: the x11 screen number (0, 10, etc.) :param str auth_protocol: the name of the X11 authentication method used; if none is given, ``\" MIT - MAGIC - COOKIE - 1 \"`` is used :param str auth_cookie: hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated :param bool single_connection: if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) :param handler: an optional callable handler to use for incoming X11 connections :return: the auth_cookie used \"\"\" if auth_protocol is None : auth_protocol = \"MIT-MAGIC-COOKIE-1\" if auth_cookie is None : auth_cookie = binascii . hexlify ( os . urandom ( 16 )) m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"x11-req\" ) m . add_boolean ( True ) m . add_boolean ( single_connection ) m . add_string ( auth_protocol ) m . add_string ( auth_cookie ) m . add_int ( screen_number ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () self . transport . _set_x11_handler ( handler ) return auth_cookie resetEnvironment def resetEnvironment ( self ) -> None Resets the environment console stack View Source def resetEnvironment ( self ) -> None : \"\"\" Resets the environment console stack \"\"\" numOfPulls = 0 for item in reversed ( self . consoleStack ) : if item [ 0 ] == self . __USER_ESCALATION__ or item [ 0 ] == self . __CONSOLE_ESCALATION__ : break numOfPulls += 1 for x in range ( numOfPulls ) : self . consoleStack . pop () resize_pty def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous get_pty call. Parameters: Name Type Description Default width int new width (in characters) of the terminal screen None height int new height (in characters) of the terminal screen None width_pixels int new width (in pixels) of the terminal screen None height_pixels int new height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) : \" \"\" Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous `get_pty` call. :param int width: new width (in characters) of the terminal screen :param int height: new height (in characters) of the terminal screen :param int width_pixels: new width (in pixels) of the terminal screen :param int height_pixels: new height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"window-change\" ) m . add_boolean ( False ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) self . transport . _send_user_message ( m ) send def send ( self , s ) Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send None Returns: Type Description None number of bytes actually sent, as an int Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . View Source def send ( self , s ) : \" \"\" Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send :return: number of bytes actually sent, as an `int` :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_DATA ) m . add_int ( self . remote_chanid ) return self . _send ( s , m ) send_exit_status def send_exit_status ( self , status ) Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. Parameters: Name Type Description Default status int the exit code of the process .. versionadded:: 1.2 None View Source def send_exit_status(self, status): \"\"\" Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. :param int status: the exit code of the process .. versionadded:: 1.2 \"\"\" # in many cases, the channel will not still be open here. # that's fine. m = Message() m.add_byte(cMSG_CHANNEL_REQUEST) m.add_int(self.remote_chanid) m.add_string(\"exit-status\") m.add_boolean(False) m.add_int(status) self.transport._send_user_message(m) send_ready def send_ready ( self ) Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a send call will succeed immediately and return the number of bytes actually written. Returns: Type Description None True if a send call on this channel would immediately succeed or fail View Source def send_ready ( self ) : \" \"\" Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a `send` call will succeed immediately and return the number of bytes actually written. :return: ``True`` if a `send` call on this channel would immediately succeed or fail \"\" \" self . lock . acquire () try : if self . closed or self . eof_sent : return True return self . out_window_size > 0 finally : self . lock . release () send_stderr def send_stderr ( self , s ) Send data to the channel on the \"stderr\" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send. None Returns: Type Description None number of bytes actually sent, as an int . Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . .. versionadded:: 1.1 View Source def send_stderr ( self , s ) : \" \"\" Send data to the channel on the \" stderr \" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send. :return: number of bytes actually sent, as an `int`. :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_EXTENDED_DATA ) m . add_int ( self . remote_chanid ) m . add_int ( 1 ) return self . _send ( s , m ) sendall def sendall ( self , s ) Send data to the channel, without allowing partial results. Unlike send , this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. View Source def sendall ( self , s ) : \" \"\" Send data to the channel, without allowing partial results. Unlike `send`, this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. \"\" \" while s : sent = self . send ( s ) s = s [ sent : ] return None sendall_stderr def sendall_stderr ( self , s ) Send data to the channel's \"stderr\" stream, without allowing partial results. Unlike send_stderr , this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send to the client as \"stderr\" output. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. versionadded:: 1.1 View Source def sendall_stderr ( self , s ) : \" \"\" Send data to the channel's \" stderr \" stream, without allowing partial results. Unlike `send_stderr`, this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send to the client as \" stderr \" output. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. versionadded:: 1.1 \"\" \" while s : sent = self . send_stderr ( s ) s = s [ sent : ] return None set_combine_stderr def set_combine_stderr ( self , combine ) Set whether stderr should be combined into stdout on this channel. The default is False , but in some cases it may be convenient to have both streams combined. If this is False , and exec_command is called (or invoke_shell with no pty), output to stderr will not show up through the recv and recv_ready calls. You will have to use recv_stderr and recv_stderr_ready to get stderr output. If this is True , data will never show up via recv_stderr or recv_stderr_ready . Parameters: Name Type Description Default combine bool True if stderr output should be combined into stdout on this channel. None Returns: Type Description None the previous setting (a bool ). .. versionadded:: 1.1 View Source def set _combine_stderr ( self , combine ) : \" \"\" Set whether stderr should be combined into stdout on this channel. The default is ``False``, but in some cases it may be convenient to have both streams combined. If this is ``False``, and `exec_command` is called (or ``invoke_shell`` with no pty), output to stderr will not show up through the `recv` and `recv_ready` calls. You will have to use `recv_stderr` and `recv_stderr_ready` to get stderr output. If this is ``True``, data will never show up via `recv_stderr` or `recv_stderr_ready`. :param bool combine: ``True`` if stderr output should be combined into stdout on this channel. :return: the previous setting (a `bool`). .. versionadded:: 1.1 \"\" \" data = bytes () self . lock . acquire () try : old = self . combine_stderr self . combine_stderr = combine if combine and not old : # copy old stderr buffer into primary buffer data = self . in_stderr_buffer . empty () finally : self . lock . release () if len ( data ) > 0 : self . _feed ( data ) return old set_environment_variable def set_environment_variable ( self , name , value ) Set the value of an environment variable. .. warning:: The server may reject this request depending on its AcceptEnv setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! Parameters: Name Type Description Default name str name of the environment variable None value str value of the environment variable None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def set _environment_variable ( self , name , value ) : \" \"\" Set the value of an environment variable. .. warning:: The server may reject this request depending on its ``AcceptEnv`` setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! :param str name: name of the environment variable :param str value: value of the environment variable :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"env\" ) m . add_boolean ( False ) m . add_string ( name ) m . add_string ( value ) self . transport . _send_user_message ( m ) set_name def set_name ( self , name ) Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the get_name method. Parameters: Name Type Description Default name str new channel name None View Source def set _name ( self , name ) : \" \"\" Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the `get_name` method. :param str name: new channel name \"\" \" self . _name = name setblocking def setblocking ( self , blocking ) Set blocking or non-blocking mode of the channel: if blocking is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a recv call doesn't find any data, or if a send call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \"immediate data\" for recv , so if the channel is closed in the read direction, it will never block. chan.setblocking(0) is equivalent to chan.settimeout(0) ; chan.setblocking(1) is equivalent to chan.settimeout(None) . Parameters: Name Type Description Default blocking int 0 to set non-blocking mode; non-0 to set blocking mode. None View Source def set blocking ( self , blocking ) : \" \"\" Set blocking or non-blocking mode of the channel: if ``blocking`` is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a `recv` call doesn't find any data, or if a `send` call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \" immediate data \" for `recv`, so if the channel is closed in the read direction, it will never block. ``chan.setblocking(0)`` is equivalent to ``chan.settimeout(0)``; ``chan.setblocking(1)`` is equivalent to ``chan.settimeout(None)``. :param int blocking: 0 to set non-blocking mode; non-0 to set blocking mode. \"\" \" if blocking : self . set timeout ( None ) else : self . set timeout ( 0.0 ) settimeout def settimeout ( self , timeout ) Set a timeout on blocking read/write operations. The timeout argument can be a nonnegative float expressing seconds, or None . If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. chan.settimeout(0.0) is equivalent to chan.setblocking(0) ; chan.settimeout(None) is equivalent to chan.setblocking(1) . Parameters: Name Type Description Default timeout float seconds to wait for a pending read/write operation before raising socket.timeout , or None for no timeout. None View Source def set timeout ( self , timeout ) : \" \"\" Set a timeout on blocking read/write operations. The ``timeout`` argument can be a nonnegative float expressing seconds, or ``None``. If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of ``None`` disables timeouts on socket operations. ``chan.settimeout(0.0)`` is equivalent to ``chan.setblocking(0)``; ``chan.settimeout(None)`` is equivalent to ``chan.setblocking(1)``. :param float timeout: seconds to wait for a pending read/write operation before raising ``socket.timeout``, or ``None`` for no timeout. \"\" \" self . timeout = timeout shutdown def shutdown ( self , how ) Shut down one or both halves of the connection. If how is 0, further receives are disallowed. If how is 1, further sends are disallowed. If how is 2, further sends and receives are disallowed. This closes the stream in one or both directions. Parameters: Name Type Description Default how int 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). None View Source def shutdown ( self , how ) : \" \"\" Shut down one or both halves of the connection. If ``how`` is 0, further receives are disallowed. If ``how`` is 1, further sends are disallowed. If ``how`` is 2, further sends and receives are disallowed. This closes the stream in one or both directions. :param int how: 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). \"\" \" if ( how == 0 ) or ( how == 2 ) : # feign \"read\" shutdown self . eof_received = 1 if ( how == 1 ) or ( how == 2 ) : self . lock . acquire () try : m = self . _send_eof () finally : self . lock . release () if m is not None : self . transport . _send_user_message ( m ) shutdown_read def shutdown_read ( self ) Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to shutdown(0) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_read ( self ): \"\"\" Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(0)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 0 ) shutdown_write def shutdown_write ( self ) Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to shutdown(1) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_write ( self ): \"\"\" Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(1)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 1 ) update_environment def update_environment ( self , environment ) Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in set_environment_variable for details. Parameters: Name Type Description Default environment dict a dictionary containing the name and respective values to set None Raises: Type Description None .SSHException -- if any of the environment variables was rejected by the server or the channel was closed View Source @open_only def update_environment ( self , environment ) : \" \"\" Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in `set_environment_variable` for details. :param dict environment: a dictionary containing the name and respective values to set :raises: `.SSHException` -- if any of the environment variables was rejected by the server or the channel was closed \"\" \" for name , value in environment . items () : try : self . set _environment_variable ( name , value ) except SSHException as e : err = 'Failed to set environment variable \"{}\".' raise SSHException ( err . format ( name ), e ) sshChannelWrapper class sshChannelWrapper ( parentInst : Any , main : bool = False , ** kwargs ) This is a special wrapper class for the Paramiko Channel class. This is designed to store additional information regarding the status of environment associated with the channel. IE: console type, user permissions, PATH and so on. Ancestors (in MRO) paramiko.channel.Channel paramiko.util.ClosingContextManager Descendants sshChannelEnvironment.sshEnvironment Instance variables isMain Methods close def close ( self ) Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their .Transport is closed or when they are garbage collected. View Source def close(self): \"\"\" Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their `.Transport` is closed or when they are garbage collected. \"\"\" self.lock.acquire() try: # only close the pipe when the user explicitly closes the channel. # otherwise they will get unpleasant surprises. (and do it before # checking self.closed, since the remote host may have already # closed the connection.) if self._pipe is not None: self._pipe.close() self._pipe = None if not self.active or self.closed: return msgs = self._close_internal() finally: self.lock.release() for m in msgs: if m is not None: self.transport._send_user_message(m) exec_command def exec_command ( self , command ) Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. Parameters: Name Type Description Default command str a shell command to execute. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def exec_command ( self , command ) : \"\"\" Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. :param str command: a shell command to execute. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"exec\" ) m . add_boolean ( True ) m . add_string ( command ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () exit_status_ready def exit_status_ready ( self ) Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in recv_exit_status . Note that the server may not return an exit status in some cases (like bad servers). Returns: Type Description None True if recv_exit_status will return immediately, else False . .. versionadded:: 1.7.3 View Source def exit_status_ready ( self ) : \" \"\" Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in `recv_exit_status`. Note that the server may not return an exit status in some cases (like bad servers). :return: ``True`` if `recv_exit_status` will return immediately, else ``False``. .. versionadded:: 1.7.3 \"\" \" return self . closed or self . status_event . is_set () fileno def fileno ( self ) Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's select module to work. The first time fileno is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) Returns: Type Description None an OS-level file descriptor ( int ) .. warning:: This method causes channel reads to be slightly less efficient. View Source def fileno ( self ) : \" \"\" Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's ``select`` module to work. The first time ``fileno`` is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) :return: an OS-level file descriptor (`int`) .. warning:: This method causes channel reads to be slightly less efficient. \"\" \" self . lock . acquire () try : if self . _pipe is not None : return self . _pipe . fileno () # create the pipe and feed in any existing data self . _pipe = pipe . make_pipe () p1 , p2 = pipe . make_or_pipe ( self . _pipe ) self . in_buffer . set _event ( p1 ) self . in_stderr_buffer . set _event ( p2 ) return self . _pipe . fileno () finally : self . lock . release () get_id def get_id ( self ) Return the int ID # for this channel. The channel ID is unique across a .Transport and usually a small number. It's also the number passed to .ServerInterface.check_channel_request when determining whether to accept a channel request in server mode. View Source def get_id ( self ) : \" \"\" Return the `int` ID # for this channel. The channel ID is unique across a `.Transport` and usually a small number. It's also the number passed to `.ServerInterface.check_channel_request` when determining whether to accept a channel request in server mode. \"\" \" return self . chanid get_name def get_name ( self ) Get the name of this channel that was previously set by set_name . View Source def get_name ( self ) : \" \"\" Get the name of this channel that was previously set by `set_name`. \"\" \" return self . _name get_pty def get_pty ( self , term = 'vt100' , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with invoke_shell . It isn't necessary (or desirable) to call this method if you're going to execute a single command with exec_command . Parameters: Name Type Description Default term str the terminal type to emulate (for example, 'vt100' ) None width int width (in characters) of the terminal screen None height int height (in characters) of the terminal screen None width_pixels int width (in pixels) of the terminal screen None height_pixels int height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def get_pty ( self , term = \"vt100\" , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 , ) : \" \"\" Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with `invoke_shell`. It isn't necessary (or desirable) to call this method if you're going to execute a single command with `exec_command`. :param str term: the terminal type to emulate (for example, ``'vt100'``) :param int width: width (in characters) of the terminal screen :param int height: height (in characters) of the terminal screen :param int width_pixels: width (in pixels) of the terminal screen :param int height_pixels: height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"pty-req\" ) m . add_boolean ( True ) m . add_string ( term ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) m . add_string ( bytes ()) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () get_transport def get_transport ( self ) Return the .Transport associated with this channel. View Source def get_transport(self): \"\"\" Return the `.Transport` associated with this channel. \"\"\" return self.transport getpeername def getpeername ( self ) Return the address of the remote side of this Channel, if possible. This simply wraps .Transport.getpeername , used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call 'getpeername' .) View Source def getpeername ( self ): \"\"\" Return the address of the remote side of this Channel, if possible. This simply wraps `.Transport.getpeername`, used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call ``'getpeername'``.) \"\"\" return self . transport . getpeername () gettimeout def gettimeout ( self ) Returns the timeout in seconds (as a float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking or settimeout . View Source def gettimeout ( self ) : \" \"\" Returns the timeout in seconds (as a float) associated with socket operations, or ``None`` if no timeout is set. This reflects the last call to `setblocking` or `settimeout`. \"\" \" return self . timeout invoke_shell def invoke_shell ( self ) Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call get_pty before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_shell ( self ) : \" \"\" Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call `get_pty` before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"shell\" ) m . add_boolean ( True ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () invoke_subsystem def invoke_subsystem ( self , subsystem ) Request a subsystem on the server (for example, sftp ). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. Parameters: Name Type Description Default subsystem str name of the subsystem being requested. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_subsystem ( self , subsystem ) : \" \"\" Request a subsystem on the server (for example, ``sftp``). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. :param str subsystem: name of the subsystem being requested. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"subsystem\" ) m . add_boolean ( True ) m . add_string ( subsystem ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () makefile def makefile ( self , * params ) Return a file-like object associated with this channel. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. Returns: Type Description None .ChannelFile object which can be used for Python file I/O. View Source def makefile ( self , * params ) : \" \"\" Return a file-like object associated with this channel. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. :return: `.ChannelFile` object which can be used for Python file I/O. \"\" \" return ChannelFile ( * ( [ self ] + list ( params ))) makefile_stderr def makefile_stderr ( self , * params ) Return a file-like object associated with this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. Returns: Type Description None .ChannelStderrFile object which can be used for Python file I/O. .. versionadded:: 1.1 View Source def makefile_stderr ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. :returns: `.ChannelStderrFile` object which can be used for Python file I/O. .. versionadded:: 1.1 \"\" \" return ChannelStderrFile ( * ( [ self ] + list ( params ))) makefile_stdin def makefile_stdin ( self , * params ) Return a file-like object associated with this channel's stdin stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. Returns: Type Description None .ChannelStdinFile object which can be used for Python file I/O. .. versionadded:: 2.6 View Source def makefile_stdin ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stdin stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. :returns: `.ChannelStdinFile` object which can be used for Python file I/O. .. versionadded:: 2.6 \"\" \" return ChannelStdinFile ( * ( [ self ] + list ( params ))) recv def recv ( self , nbytes ) Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data, as a bytes . Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . View Source def recv ( self , nbytes ) : \" \"\" Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data, as a `bytes`. :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. \"\" \" try : out = self . in_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out recv_exit_status def recv_exit_status ( self ) Return the exit status from the process on the server. This is mostly useful for retrieving the results of an exec_command . If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current .Transport or session's window_size (e.g. that set by the default_window_size kwarg for .Transport.__init__ ) will cause .recv_exit_status to hang indefinitely if it is called prior to a sufficiently large .Channel.recv (or if there are no threads calling .Channel.recv in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. Returns: Type Description None the exit code (as an int ) of the process on the server. .. versionadded:: 1.2 View Source def recv_exit_status ( self ) : \" \"\" Return the exit status from the process on the server. This is mostly useful for retrieving the results of an `exec_command`. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current `.Transport` or session's ``window_size`` (e.g. that set by the ``default_window_size`` kwarg for `.Transport.__init__`) will cause `.recv_exit_status` to hang indefinitely if it is called prior to a sufficiently large `.Channel.recv` (or if there are no threads calling `.Channel.recv` in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. :return: the exit code (as an `int`) of the process on the server. .. versionadded:: 1.2 \"\" \" self . status_event . wait () assert self . status_event . is_set () return self . exit_status recv_ready def recv_ready ( self ) Returns true if data is buffered and ready to be read from this channel. A False result does not mean that the channel has closed; it means you may need to wait before more data arrives. Returns: Type Description None True if a recv call on this channel would immediately return at least one byte; False otherwise. View Source def recv_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel. A ``False`` result does not mean that the channel has closed; it means you may need to wait before more data arrives. :return: ``True`` if a `recv` call on this channel would immediately return at least one byte; ``False`` otherwise. \"\" \" return self . in_buffer . read_ready () recv_stderr def recv_stderr ( self , nbytes ) Receive data from the channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data as a bytes Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . .. versionadded:: 1.1 View Source def recv_stderr ( self , nbytes ) : \" \"\" Receive data from the channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data as a `bytes` :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" try : out = self . in_stderr_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out recv_stderr_ready def recv_stderr_ready ( self ) Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. Returns: Type Description None True if a recv_stderr call on this channel would immediately return at least one byte; False otherwise. .. versionadded:: 1.1 View Source def recv_stderr_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. :return: ``True`` if a `recv_stderr` call on this channel would immediately return at least one byte; ``False`` otherwise. .. versionadded:: 1.1 \"\" \" return self . in_stderr_buffer . read_ready () request_forward_agent def request_forward_agent ( self , handler ) Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! Parameters: Name Type Description Default handler None a required callable handler to use for incoming SSH Agent connections None Returns: Type Description None True if we are ok, else False (at that time we always return ok) Raises: Type Description None SSHException in case of channel problem. View Source @open_only def request_forward_agent ( self , handler ) : \"\"\" Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! :param handler: a required callable handler to use for incoming SSH Agent connections :return: True if we are ok, else False (at that time we always return ok) :raises: SSHException in case of channel problem. \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"auth-agent-req@openssh.com\" ) m . add_boolean ( False ) self . transport . _send_user_message ( m ) self . transport . _set_forward_agent_handler ( handler ) return True request_x11 def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None ) Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc: 4254 :: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake , random cookie , and that the cookie be checked and replaced by the real cookie when a connection request is received . If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using .Transport.accept . The handler's calling signature is:: handler ( channel : Channel , ( address : str , port : int )) Parameters: Name Type Description Default screen_number int the x11 screen number (0, 10, etc.) None auth_protocol str the name of the X11 authentication method used; if none is given, \"MIT-MAGIC-COOKIE-1\" is used None auth_cookie str hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated None single_connection bool if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) None handler None an optional callable handler to use for incoming X11 connections None Returns: Type Description None the auth_cookie used View Source @ open_only def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None , ): \"\"\" Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc:`4254`:: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake, random cookie, and that the cookie be checked and replaced by the real cookie when a connection request is received. If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using `.Transport.accept`. The handler's calling signature is:: handler(channel: Channel, (address: str, port: int)) :param int screen_number: the x11 screen number (0, 10, etc.) :param str auth_protocol: the name of the X11 authentication method used; if none is given, ``\" MIT - MAGIC - COOKIE - 1 \"`` is used :param str auth_cookie: hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated :param bool single_connection: if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) :param handler: an optional callable handler to use for incoming X11 connections :return: the auth_cookie used \"\"\" if auth_protocol is None : auth_protocol = \"MIT-MAGIC-COOKIE-1\" if auth_cookie is None : auth_cookie = binascii . hexlify ( os . urandom ( 16 )) m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"x11-req\" ) m . add_boolean ( True ) m . add_boolean ( single_connection ) m . add_string ( auth_protocol ) m . add_string ( auth_cookie ) m . add_int ( screen_number ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () self . transport . _set_x11_handler ( handler ) return auth_cookie resize_pty def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous get_pty call. Parameters: Name Type Description Default width int new width (in characters) of the terminal screen None height int new height (in characters) of the terminal screen None width_pixels int new width (in pixels) of the terminal screen None height_pixels int new height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) : \" \"\" Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous `get_pty` call. :param int width: new width (in characters) of the terminal screen :param int height: new height (in characters) of the terminal screen :param int width_pixels: new width (in pixels) of the terminal screen :param int height_pixels: new height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"window-change\" ) m . add_boolean ( False ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) self . transport . _send_user_message ( m ) send def send ( self , s ) Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send None Returns: Type Description None number of bytes actually sent, as an int Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . View Source def send ( self , s ) : \" \"\" Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send :return: number of bytes actually sent, as an `int` :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_DATA ) m . add_int ( self . remote_chanid ) return self . _send ( s , m ) send_exit_status def send_exit_status ( self , status ) Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. Parameters: Name Type Description Default status int the exit code of the process .. versionadded:: 1.2 None View Source def send_exit_status(self, status): \"\"\" Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. :param int status: the exit code of the process .. versionadded:: 1.2 \"\"\" # in many cases, the channel will not still be open here. # that's fine. m = Message() m.add_byte(cMSG_CHANNEL_REQUEST) m.add_int(self.remote_chanid) m.add_string(\"exit-status\") m.add_boolean(False) m.add_int(status) self.transport._send_user_message(m) send_ready def send_ready ( self ) Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a send call will succeed immediately and return the number of bytes actually written. Returns: Type Description None True if a send call on this channel would immediately succeed or fail View Source def send_ready ( self ) : \" \"\" Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a `send` call will succeed immediately and return the number of bytes actually written. :return: ``True`` if a `send` call on this channel would immediately succeed or fail \"\" \" self . lock . acquire () try : if self . closed or self . eof_sent : return True return self . out_window_size > 0 finally : self . lock . release () send_stderr def send_stderr ( self , s ) Send data to the channel on the \"stderr\" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send. None Returns: Type Description None number of bytes actually sent, as an int . Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . .. versionadded:: 1.1 View Source def send_stderr ( self , s ) : \" \"\" Send data to the channel on the \" stderr \" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send. :return: number of bytes actually sent, as an `int`. :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_EXTENDED_DATA ) m . add_int ( self . remote_chanid ) m . add_int ( 1 ) return self . _send ( s , m ) sendall def sendall ( self , s ) Send data to the channel, without allowing partial results. Unlike send , this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. View Source def sendall ( self , s ) : \" \"\" Send data to the channel, without allowing partial results. Unlike `send`, this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. \"\" \" while s : sent = self . send ( s ) s = s [ sent : ] return None sendall_stderr def sendall_stderr ( self , s ) Send data to the channel's \"stderr\" stream, without allowing partial results. Unlike send_stderr , this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send to the client as \"stderr\" output. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. versionadded:: 1.1 View Source def sendall_stderr ( self , s ) : \" \"\" Send data to the channel's \" stderr \" stream, without allowing partial results. Unlike `send_stderr`, this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send to the client as \" stderr \" output. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. versionadded:: 1.1 \"\" \" while s : sent = self . send_stderr ( s ) s = s [ sent : ] return None set_combine_stderr def set_combine_stderr ( self , combine ) Set whether stderr should be combined into stdout on this channel. The default is False , but in some cases it may be convenient to have both streams combined. If this is False , and exec_command is called (or invoke_shell with no pty), output to stderr will not show up through the recv and recv_ready calls. You will have to use recv_stderr and recv_stderr_ready to get stderr output. If this is True , data will never show up via recv_stderr or recv_stderr_ready . Parameters: Name Type Description Default combine bool True if stderr output should be combined into stdout on this channel. None Returns: Type Description None the previous setting (a bool ). .. versionadded:: 1.1 View Source def set _combine_stderr ( self , combine ) : \" \"\" Set whether stderr should be combined into stdout on this channel. The default is ``False``, but in some cases it may be convenient to have both streams combined. If this is ``False``, and `exec_command` is called (or ``invoke_shell`` with no pty), output to stderr will not show up through the `recv` and `recv_ready` calls. You will have to use `recv_stderr` and `recv_stderr_ready` to get stderr output. If this is ``True``, data will never show up via `recv_stderr` or `recv_stderr_ready`. :param bool combine: ``True`` if stderr output should be combined into stdout on this channel. :return: the previous setting (a `bool`). .. versionadded:: 1.1 \"\" \" data = bytes () self . lock . acquire () try : old = self . combine_stderr self . combine_stderr = combine if combine and not old : # copy old stderr buffer into primary buffer data = self . in_stderr_buffer . empty () finally : self . lock . release () if len ( data ) > 0 : self . _feed ( data ) return old set_environment_variable def set_environment_variable ( self , name , value ) Set the value of an environment variable. .. warning:: The server may reject this request depending on its AcceptEnv setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! Parameters: Name Type Description Default name str name of the environment variable None value str value of the environment variable None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def set _environment_variable ( self , name , value ) : \" \"\" Set the value of an environment variable. .. warning:: The server may reject this request depending on its ``AcceptEnv`` setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! :param str name: name of the environment variable :param str value: value of the environment variable :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"env\" ) m . add_boolean ( False ) m . add_string ( name ) m . add_string ( value ) self . transport . _send_user_message ( m ) set_name def set_name ( self , name ) Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the get_name method. Parameters: Name Type Description Default name str new channel name None View Source def set _name ( self , name ) : \" \"\" Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the `get_name` method. :param str name: new channel name \"\" \" self . _name = name setblocking def setblocking ( self , blocking ) Set blocking or non-blocking mode of the channel: if blocking is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a recv call doesn't find any data, or if a send call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \"immediate data\" for recv , so if the channel is closed in the read direction, it will never block. chan.setblocking(0) is equivalent to chan.settimeout(0) ; chan.setblocking(1) is equivalent to chan.settimeout(None) . Parameters: Name Type Description Default blocking int 0 to set non-blocking mode; non-0 to set blocking mode. None View Source def set blocking ( self , blocking ) : \" \"\" Set blocking or non-blocking mode of the channel: if ``blocking`` is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a `recv` call doesn't find any data, or if a `send` call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \" immediate data \" for `recv`, so if the channel is closed in the read direction, it will never block. ``chan.setblocking(0)`` is equivalent to ``chan.settimeout(0)``; ``chan.setblocking(1)`` is equivalent to ``chan.settimeout(None)``. :param int blocking: 0 to set non-blocking mode; non-0 to set blocking mode. \"\" \" if blocking : self . set timeout ( None ) else : self . set timeout ( 0.0 ) settimeout def settimeout ( self , timeout ) Set a timeout on blocking read/write operations. The timeout argument can be a nonnegative float expressing seconds, or None . If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. chan.settimeout(0.0) is equivalent to chan.setblocking(0) ; chan.settimeout(None) is equivalent to chan.setblocking(1) . Parameters: Name Type Description Default timeout float seconds to wait for a pending read/write operation before raising socket.timeout , or None for no timeout. None View Source def set timeout ( self , timeout ) : \" \"\" Set a timeout on blocking read/write operations. The ``timeout`` argument can be a nonnegative float expressing seconds, or ``None``. If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of ``None`` disables timeouts on socket operations. ``chan.settimeout(0.0)`` is equivalent to ``chan.setblocking(0)``; ``chan.settimeout(None)`` is equivalent to ``chan.setblocking(1)``. :param float timeout: seconds to wait for a pending read/write operation before raising ``socket.timeout``, or ``None`` for no timeout. \"\" \" self . timeout = timeout shutdown def shutdown ( self , how ) Shut down one or both halves of the connection. If how is 0, further receives are disallowed. If how is 1, further sends are disallowed. If how is 2, further sends and receives are disallowed. This closes the stream in one or both directions. Parameters: Name Type Description Default how int 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). None View Source def shutdown ( self , how ) : \" \"\" Shut down one or both halves of the connection. If ``how`` is 0, further receives are disallowed. If ``how`` is 1, further sends are disallowed. If ``how`` is 2, further sends and receives are disallowed. This closes the stream in one or both directions. :param int how: 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). \"\" \" if ( how == 0 ) or ( how == 2 ) : # feign \"read\" shutdown self . eof_received = 1 if ( how == 1 ) or ( how == 2 ) : self . lock . acquire () try : m = self . _send_eof () finally : self . lock . release () if m is not None : self . transport . _send_user_message ( m ) shutdown_read def shutdown_read ( self ) Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to shutdown(0) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_read ( self ): \"\"\" Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(0)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 0 ) shutdown_write def shutdown_write ( self ) Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to shutdown(1) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_write ( self ): \"\"\" Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(1)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 1 ) update_environment def update_environment ( self , environment ) Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in set_environment_variable for details. Parameters: Name Type Description Default environment dict a dictionary containing the name and respective values to set None Raises: Type Description None .SSHException -- if any of the environment variables was rejected by the server or the channel was closed View Source @open_only def update_environment ( self , environment ) : \" \"\" Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in `set_environment_variable` for details. :param dict environment: a dictionary containing the name and respective values to set :raises: `.SSHException` -- if any of the environment variables was rejected by the server or the channel was closed \"\" \" for name , value in environment . items () : try : self . set _environment_variable ( name , value ) except SSHException as e : err = 'Failed to set environment variable \"{}\".' raise SSHException ( err . format ( name ), e ) sshEnvironment class sshEnvironment ( parentInst : Any , ** kwargs ) Uses the sshChannelWrapper and is used by the EnvironmentControls. This handles the state of the ssh Environment it is associated with. Such as the prompt/current user/console and so on. Ancestors (in MRO) sshChannelEnvironment.sshChannelWrapper paramiko.channel.Channel paramiko.util.ClosingContextManager Descendants sshChannelEnvironment.EnvironmentControls Class variables BASH CSH MYSQL NOSH ORACLE SH ZSH prompt Instance variables console consoleStack isMain numEscalations numUsers userCount userList whoami Methods close def close ( self ) Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their .Transport is closed or when they are garbage collected. View Source def close(self): \"\"\" Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their `.Transport` is closed or when they are garbage collected. \"\"\" self.lock.acquire() try: # only close the pipe when the user explicitly closes the channel. # otherwise they will get unpleasant surprises. (and do it before # checking self.closed, since the remote host may have already # closed the connection.) if self._pipe is not None: self._pipe.close() self._pipe = None if not self.active or self.closed: return msgs = self._close_internal() finally: self.lock.release() for m in msgs: if m is not None: self.transport._send_user_message(m) exec_command def exec_command ( self , command ) Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. Parameters: Name Type Description Default command str a shell command to execute. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def exec_command ( self , command ) : \"\"\" Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. :param str command: a shell command to execute. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"exec\" ) m . add_boolean ( True ) m . add_string ( command ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () exit_status_ready def exit_status_ready ( self ) Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in recv_exit_status . Note that the server may not return an exit status in some cases (like bad servers). Returns: Type Description None True if recv_exit_status will return immediately, else False . .. versionadded:: 1.7.3 View Source def exit_status_ready ( self ) : \" \"\" Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in `recv_exit_status`. Note that the server may not return an exit status in some cases (like bad servers). :return: ``True`` if `recv_exit_status` will return immediately, else ``False``. .. versionadded:: 1.7.3 \"\" \" return self . closed or self . status_event . is_set () fileno def fileno ( self ) Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's select module to work. The first time fileno is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) Returns: Type Description None an OS-level file descriptor ( int ) .. warning:: This method causes channel reads to be slightly less efficient. View Source def fileno ( self ) : \" \"\" Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's ``select`` module to work. The first time ``fileno`` is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) :return: an OS-level file descriptor (`int`) .. warning:: This method causes channel reads to be slightly less efficient. \"\" \" self . lock . acquire () try : if self . _pipe is not None : return self . _pipe . fileno () # create the pipe and feed in any existing data self . _pipe = pipe . make_pipe () p1 , p2 = pipe . make_or_pipe ( self . _pipe ) self . in_buffer . set _event ( p1 ) self . in_stderr_buffer . set _event ( p2 ) return self . _pipe . fileno () finally : self . lock . release () getConsoleList def getConsoleList ( self ) -> list LIke 'getUserList' but returns a list of the console escalations in order that they happened. View Source def getConsoleList ( self ) -> list : \"\"\" LIke ' getUserList ' but returns a list of the console escalations in order that they happened. \"\"\" def _filterConsoles ( item ) : return self . __CONSOLE_ESCALATION__ == item [ 0 ] def _consoleGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output # itemList = list ( filter ( _filterConsoles , self . consoleStack )) return _consoleGenerator ( filter ( _filterConsoles , self . consoleStack )) getCurrentConsole def getCurrentConsole ( self ) -> str Like 'getCurrentUser' but gets what the current console type is. View Source def getCurrentConsole ( self ) -> str : \"\"\" Like 'getCurrentUser' but gets what the current console type is. \"\"\" consoles = self . getConsoleList () if consoles : return consoles [ - 1 ] return \"BASH\" getCurrentUser def getCurrentUser ( self ) -> str Returns a string that is the name of the current user authenticated on this environment. View Source def getCurrentUser ( self ) -> str : \"\"\" Returns a string that is the name of the current user authenticated on this environment. \"\"\" currentUsers = self . getUserList () if currentUsers : return currentUsers [ - 1 ] return '' getPreviousEscalation def getPreviousEscalation ( self ) -> tuple View Source def getPreviousEscalation ( self ) -> tuple : return self . peak () getPreviousEscalationType def getPreviousEscalationType ( self ) -> int View Source def getPreviousEscalationType ( self ) -> int : return self . peak ()[ 0 ] getUserList def getUserList ( self ) -> list This returns a list of users that are currently logged into this environment in order of there login. View Source def getUserList ( self ) -> list : \"\"\" This returns a list of users that are currently logged into this environment in order of there login. \"\"\" def _filterUsers ( item ) : return self . __USER_ESCALATION__ == item [ 0 ] def _userGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output if not self . consoleStack : return [] # itemList = list ( filter ( _filterUsers , self . consoleStack )) return _userGenerator ( filter ( _filterUsers , self . consoleStack )) get_id def get_id ( self ) Return the int ID # for this channel. The channel ID is unique across a .Transport and usually a small number. It's also the number passed to .ServerInterface.check_channel_request when determining whether to accept a channel request in server mode. View Source def get_id ( self ) : \" \"\" Return the `int` ID # for this channel. The channel ID is unique across a `.Transport` and usually a small number. It's also the number passed to `.ServerInterface.check_channel_request` when determining whether to accept a channel request in server mode. \"\" \" return self . chanid get_name def get_name ( self ) Get the name of this channel that was previously set by set_name . View Source def get_name ( self ) : \" \"\" Get the name of this channel that was previously set by `set_name`. \"\" \" return self . _name get_pty def get_pty ( self , term = 'vt100' , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with invoke_shell . It isn't necessary (or desirable) to call this method if you're going to execute a single command with exec_command . Parameters: Name Type Description Default term str the terminal type to emulate (for example, 'vt100' ) None width int width (in characters) of the terminal screen None height int height (in characters) of the terminal screen None width_pixels int width (in pixels) of the terminal screen None height_pixels int height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def get_pty ( self , term = \"vt100\" , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 , ) : \" \"\" Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with `invoke_shell`. It isn't necessary (or desirable) to call this method if you're going to execute a single command with `exec_command`. :param str term: the terminal type to emulate (for example, ``'vt100'``) :param int width: width (in characters) of the terminal screen :param int height: height (in characters) of the terminal screen :param int width_pixels: width (in pixels) of the terminal screen :param int height_pixels: height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"pty-req\" ) m . add_boolean ( True ) m . add_string ( term ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) m . add_string ( bytes ()) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () get_transport def get_transport ( self ) Return the .Transport associated with this channel. View Source def get_transport(self): \"\"\" Return the `.Transport` associated with this channel. \"\"\" return self.transport getpeername def getpeername ( self ) Return the address of the remote side of this Channel, if possible. This simply wraps .Transport.getpeername , used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call 'getpeername' .) View Source def getpeername ( self ): \"\"\" Return the address of the remote side of this Channel, if possible. This simply wraps `.Transport.getpeername`, used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call ``'getpeername'``.) \"\"\" return self . transport . getpeername () gettimeout def gettimeout ( self ) Returns the timeout in seconds (as a float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking or settimeout . View Source def gettimeout ( self ) : \" \"\" Returns the timeout in seconds (as a float) associated with socket operations, or ``None`` if no timeout is set. This reflects the last call to `setblocking` or `settimeout`. \"\" \" return self . timeout invoke_shell def invoke_shell ( self ) Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call get_pty before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_shell ( self ) : \" \"\" Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call `get_pty` before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"shell\" ) m . add_boolean ( True ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () invoke_subsystem def invoke_subsystem ( self , subsystem ) Request a subsystem on the server (for example, sftp ). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. Parameters: Name Type Description Default subsystem str name of the subsystem being requested. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_subsystem ( self , subsystem ) : \" \"\" Request a subsystem on the server (for example, ``sftp``). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. :param str subsystem: name of the subsystem being requested. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"subsystem\" ) m . add_boolean ( True ) m . add_string ( subsystem ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () makefile def makefile ( self , * params ) Return a file-like object associated with this channel. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. Returns: Type Description None .ChannelFile object which can be used for Python file I/O. View Source def makefile ( self , * params ) : \" \"\" Return a file-like object associated with this channel. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. :return: `.ChannelFile` object which can be used for Python file I/O. \"\" \" return ChannelFile ( * ( [ self ] + list ( params ))) makefile_stderr def makefile_stderr ( self , * params ) Return a file-like object associated with this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. Returns: Type Description None .ChannelStderrFile object which can be used for Python file I/O. .. versionadded:: 1.1 View Source def makefile_stderr ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. :returns: `.ChannelStderrFile` object which can be used for Python file I/O. .. versionadded:: 1.1 \"\" \" return ChannelStderrFile ( * ( [ self ] + list ( params ))) makefile_stdin def makefile_stdin ( self , * params ) Return a file-like object associated with this channel's stdin stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. Returns: Type Description None .ChannelStdinFile object which can be used for Python file I/O. .. versionadded:: 2.6 View Source def makefile_stdin ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stdin stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. :returns: `.ChannelStdinFile` object which can be used for Python file I/O. .. versionadded:: 2.6 \"\" \" return ChannelStdinFile ( * ( [ self ] + list ( params ))) peak def peak ( self ) -> tuple Just like a peak it simply returns the last console change without removing it. View Source def peak ( self ) -> tuple : \"\"\" Just like a peak it simply returns the last console change without removing it. \"\"\" if self . consoleStack : return self . consoleStack [ - 1 ] peer def peer ( self , num ) -> tuple Just like a peer for a stack this allows one to look at an particular index of the stack. View Source def peer ( self , num ) -> tuple : \"\"\" Just like a peer for a stack this allows one to look at an particular index of the stack. \"\"\" try : return self . consoleStack [ num ] except : return () printStack def printStack ( self ) -> str This returns a string. It is a nicely formatted list of the history of console changes on the Environment View Source def printStack ( self ) -> str : \"\"\" This returns a string. It is a nicely formatted list of the history of console changes on the Environment\"\"\" output = \"\" for item in self . consoleStack : if not item or len ( item ) < 4 : continue typeStr = self . __INVERTED_TYPE_DICT__ . get ( item [ 0 ]) output += f ' { typeStr }: { item [ 1 ]} Using Command : { item [ 2 ]} AdditionalInput : { item [ 3 ]} \\ n ' return output pull def pull ( self ) -> tuple This pulls from the consoleStack removing the item and returning it. Returns: Type Description None (tuple) The escalation information formated as a tuple View Source def pull ( self ) -> tuple : \"\"\" This pulls from the consoleStack removing the item and returning it. :return: (tuple) The escalation information formated as a tuple \"\"\" if len ( self . consoleStack ) >= 1 : return self . consoleStack . pop () return tuple () push def push ( self , item : Union [ tuple , str ], name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool Append a new change to the console. This is to record a change to the environment. Parameters: Name Type Description Default item None (either tuple or str) None name None (str) None escalationType None (int) This should either be ( USER_ESCALATION ) 1, ( CONSOLE_ESCALATION ) 2, ( ENVIRONMENT_CHANGE ) 3 or ( UNKNOWN ) 4. None additionalInput None (str) Optional additional information for example a password. None Returns: Type Description None (bool) View Source def push ( self , item : Union [ tuple, str ] , name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool : \"\"\" Append a new change to the console. This is to record a change to the environment. :param item: (either tuple or str) :param name: (str) :param escalationType: (int) This should either be (__USER_ESCALATION__) 1, (__CONSOLE_ESCALATION__) 2, (__ENVIRONMENT_CHANGE__) 3 or (__UNKNOWN__) 4. :param additionalInput: (str) Optional additional information for example a password. :return: (bool) \"\"\" def _parsePushInput ( _item , _name , _escalationType , _additionalInput ) : if type ( _item ) is not tuple and ( type ( _escalationType ) is int or type ( _escalationType ) is str ) : if type ( _escalationType ) is str : _escalationType = self . __TYPE_DICT__ . get ( _escalationType ) or 4 elif abs ( _escalationType ) > 4 or _escalationType <= 0 : _escalationType = 4 return _escalationType , _name , _item , _additionalInput if type ( _item ) is tuple and len ( _item ) == 4 and type ( _item [ 0 ] is int ) : return _item if type ( _item ) is str or type ( _item ) is dict and _escalationType is None : return self . __USER_ESCALATION__ , _name , _item , _additionalInput return False command = _parsePushInput ( item , name , escalationType , additionalInput ) if command is False : return False self . consoleStack . append ( command ) return True recv def recv ( self , nbytes ) Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data, as a bytes . Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . View Source def recv ( self , nbytes ) : \" \"\" Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data, as a `bytes`. :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. \"\" \" try : out = self . in_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out recv_exit_status def recv_exit_status ( self ) Return the exit status from the process on the server. This is mostly useful for retrieving the results of an exec_command . If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current .Transport or session's window_size (e.g. that set by the default_window_size kwarg for .Transport.__init__ ) will cause .recv_exit_status to hang indefinitely if it is called prior to a sufficiently large .Channel.recv (or if there are no threads calling .Channel.recv in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. Returns: Type Description None the exit code (as an int ) of the process on the server. .. versionadded:: 1.2 View Source def recv_exit_status ( self ) : \" \"\" Return the exit status from the process on the server. This is mostly useful for retrieving the results of an `exec_command`. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current `.Transport` or session's ``window_size`` (e.g. that set by the ``default_window_size`` kwarg for `.Transport.__init__`) will cause `.recv_exit_status` to hang indefinitely if it is called prior to a sufficiently large `.Channel.recv` (or if there are no threads calling `.Channel.recv` in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. :return: the exit code (as an `int`) of the process on the server. .. versionadded:: 1.2 \"\" \" self . status_event . wait () assert self . status_event . is_set () return self . exit_status recv_ready def recv_ready ( self ) Returns true if data is buffered and ready to be read from this channel. A False result does not mean that the channel has closed; it means you may need to wait before more data arrives. Returns: Type Description None True if a recv call on this channel would immediately return at least one byte; False otherwise. View Source def recv_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel. A ``False`` result does not mean that the channel has closed; it means you may need to wait before more data arrives. :return: ``True`` if a `recv` call on this channel would immediately return at least one byte; ``False`` otherwise. \"\" \" return self . in_buffer . read_ready () recv_stderr def recv_stderr ( self , nbytes ) Receive data from the channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data as a bytes Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . .. versionadded:: 1.1 View Source def recv_stderr ( self , nbytes ) : \" \"\" Receive data from the channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data as a `bytes` :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" try : out = self . in_stderr_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out recv_stderr_ready def recv_stderr_ready ( self ) Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. Returns: Type Description None True if a recv_stderr call on this channel would immediately return at least one byte; False otherwise. .. versionadded:: 1.1 View Source def recv_stderr_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. :return: ``True`` if a `recv_stderr` call on this channel would immediately return at least one byte; ``False`` otherwise. .. versionadded:: 1.1 \"\" \" return self . in_stderr_buffer . read_ready () request_forward_agent def request_forward_agent ( self , handler ) Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! Parameters: Name Type Description Default handler None a required callable handler to use for incoming SSH Agent connections None Returns: Type Description None True if we are ok, else False (at that time we always return ok) Raises: Type Description None SSHException in case of channel problem. View Source @open_only def request_forward_agent ( self , handler ) : \"\"\" Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! :param handler: a required callable handler to use for incoming SSH Agent connections :return: True if we are ok, else False (at that time we always return ok) :raises: SSHException in case of channel problem. \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"auth-agent-req@openssh.com\" ) m . add_boolean ( False ) self . transport . _send_user_message ( m ) self . transport . _set_forward_agent_handler ( handler ) return True request_x11 def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None ) Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc: 4254 :: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake , random cookie , and that the cookie be checked and replaced by the real cookie when a connection request is received . If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using .Transport.accept . The handler's calling signature is:: handler ( channel : Channel , ( address : str , port : int )) Parameters: Name Type Description Default screen_number int the x11 screen number (0, 10, etc.) None auth_protocol str the name of the X11 authentication method used; if none is given, \"MIT-MAGIC-COOKIE-1\" is used None auth_cookie str hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated None single_connection bool if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) None handler None an optional callable handler to use for incoming X11 connections None Returns: Type Description None the auth_cookie used View Source @ open_only def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None , ): \"\"\" Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc:`4254`:: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake, random cookie, and that the cookie be checked and replaced by the real cookie when a connection request is received. If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using `.Transport.accept`. The handler's calling signature is:: handler(channel: Channel, (address: str, port: int)) :param int screen_number: the x11 screen number (0, 10, etc.) :param str auth_protocol: the name of the X11 authentication method used; if none is given, ``\" MIT - MAGIC - COOKIE - 1 \"`` is used :param str auth_cookie: hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated :param bool single_connection: if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) :param handler: an optional callable handler to use for incoming X11 connections :return: the auth_cookie used \"\"\" if auth_protocol is None : auth_protocol = \"MIT-MAGIC-COOKIE-1\" if auth_cookie is None : auth_cookie = binascii . hexlify ( os . urandom ( 16 )) m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"x11-req\" ) m . add_boolean ( True ) m . add_boolean ( single_connection ) m . add_string ( auth_protocol ) m . add_string ( auth_cookie ) m . add_int ( screen_number ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () self . transport . _set_x11_handler ( handler ) return auth_cookie resetEnvironment def resetEnvironment ( self ) -> None Resets the environment console stack View Source def resetEnvironment ( self ) -> None : \"\"\" Resets the environment console stack \"\"\" numOfPulls = 0 for item in reversed ( self . consoleStack ) : if item [ 0 ] == self . __USER_ESCALATION__ or item [ 0 ] == self . __CONSOLE_ESCALATION__ : break numOfPulls += 1 for x in range ( numOfPulls ) : self . consoleStack . pop () resize_pty def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous get_pty call. Parameters: Name Type Description Default width int new width (in characters) of the terminal screen None height int new height (in characters) of the terminal screen None width_pixels int new width (in pixels) of the terminal screen None height_pixels int new height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) : \" \"\" Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous `get_pty` call. :param int width: new width (in characters) of the terminal screen :param int height: new height (in characters) of the terminal screen :param int width_pixels: new width (in pixels) of the terminal screen :param int height_pixels: new height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"window-change\" ) m . add_boolean ( False ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) self . transport . _send_user_message ( m ) send def send ( self , s ) Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send None Returns: Type Description None number of bytes actually sent, as an int Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . View Source def send ( self , s ) : \" \"\" Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send :return: number of bytes actually sent, as an `int` :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_DATA ) m . add_int ( self . remote_chanid ) return self . _send ( s , m ) send_exit_status def send_exit_status ( self , status ) Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. Parameters: Name Type Description Default status int the exit code of the process .. versionadded:: 1.2 None View Source def send_exit_status(self, status): \"\"\" Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. :param int status: the exit code of the process .. versionadded:: 1.2 \"\"\" # in many cases, the channel will not still be open here. # that's fine. m = Message() m.add_byte(cMSG_CHANNEL_REQUEST) m.add_int(self.remote_chanid) m.add_string(\"exit-status\") m.add_boolean(False) m.add_int(status) self.transport._send_user_message(m) send_ready def send_ready ( self ) Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a send call will succeed immediately and return the number of bytes actually written. Returns: Type Description None True if a send call on this channel would immediately succeed or fail View Source def send_ready ( self ) : \" \"\" Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a `send` call will succeed immediately and return the number of bytes actually written. :return: ``True`` if a `send` call on this channel would immediately succeed or fail \"\" \" self . lock . acquire () try : if self . closed or self . eof_sent : return True return self . out_window_size > 0 finally : self . lock . release () send_stderr def send_stderr ( self , s ) Send data to the channel on the \"stderr\" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send. None Returns: Type Description None number of bytes actually sent, as an int . Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . .. versionadded:: 1.1 View Source def send_stderr ( self , s ) : \" \"\" Send data to the channel on the \" stderr \" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send. :return: number of bytes actually sent, as an `int`. :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_EXTENDED_DATA ) m . add_int ( self . remote_chanid ) m . add_int ( 1 ) return self . _send ( s , m ) sendall def sendall ( self , s ) Send data to the channel, without allowing partial results. Unlike send , this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. View Source def sendall ( self , s ) : \" \"\" Send data to the channel, without allowing partial results. Unlike `send`, this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. \"\" \" while s : sent = self . send ( s ) s = s [ sent : ] return None sendall_stderr def sendall_stderr ( self , s ) Send data to the channel's \"stderr\" stream, without allowing partial results. Unlike send_stderr , this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send to the client as \"stderr\" output. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. versionadded:: 1.1 View Source def sendall_stderr ( self , s ) : \" \"\" Send data to the channel's \" stderr \" stream, without allowing partial results. Unlike `send_stderr`, this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send to the client as \" stderr \" output. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. versionadded:: 1.1 \"\" \" while s : sent = self . send_stderr ( s ) s = s [ sent : ] return None set_combine_stderr def set_combine_stderr ( self , combine ) Set whether stderr should be combined into stdout on this channel. The default is False , but in some cases it may be convenient to have both streams combined. If this is False , and exec_command is called (or invoke_shell with no pty), output to stderr will not show up through the recv and recv_ready calls. You will have to use recv_stderr and recv_stderr_ready to get stderr output. If this is True , data will never show up via recv_stderr or recv_stderr_ready . Parameters: Name Type Description Default combine bool True if stderr output should be combined into stdout on this channel. None Returns: Type Description None the previous setting (a bool ). .. versionadded:: 1.1 View Source def set _combine_stderr ( self , combine ) : \" \"\" Set whether stderr should be combined into stdout on this channel. The default is ``False``, but in some cases it may be convenient to have both streams combined. If this is ``False``, and `exec_command` is called (or ``invoke_shell`` with no pty), output to stderr will not show up through the `recv` and `recv_ready` calls. You will have to use `recv_stderr` and `recv_stderr_ready` to get stderr output. If this is ``True``, data will never show up via `recv_stderr` or `recv_stderr_ready`. :param bool combine: ``True`` if stderr output should be combined into stdout on this channel. :return: the previous setting (a `bool`). .. versionadded:: 1.1 \"\" \" data = bytes () self . lock . acquire () try : old = self . combine_stderr self . combine_stderr = combine if combine and not old : # copy old stderr buffer into primary buffer data = self . in_stderr_buffer . empty () finally : self . lock . release () if len ( data ) > 0 : self . _feed ( data ) return old set_environment_variable def set_environment_variable ( self , name , value ) Set the value of an environment variable. .. warning:: The server may reject this request depending on its AcceptEnv setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! Parameters: Name Type Description Default name str name of the environment variable None value str value of the environment variable None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def set _environment_variable ( self , name , value ) : \" \"\" Set the value of an environment variable. .. warning:: The server may reject this request depending on its ``AcceptEnv`` setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! :param str name: name of the environment variable :param str value: value of the environment variable :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"env\" ) m . add_boolean ( False ) m . add_string ( name ) m . add_string ( value ) self . transport . _send_user_message ( m ) set_name def set_name ( self , name ) Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the get_name method. Parameters: Name Type Description Default name str new channel name None View Source def set _name ( self , name ) : \" \"\" Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the `get_name` method. :param str name: new channel name \"\" \" self . _name = name setblocking def setblocking ( self , blocking ) Set blocking or non-blocking mode of the channel: if blocking is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a recv call doesn't find any data, or if a send call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \"immediate data\" for recv , so if the channel is closed in the read direction, it will never block. chan.setblocking(0) is equivalent to chan.settimeout(0) ; chan.setblocking(1) is equivalent to chan.settimeout(None) . Parameters: Name Type Description Default blocking int 0 to set non-blocking mode; non-0 to set blocking mode. None View Source def set blocking ( self , blocking ) : \" \"\" Set blocking or non-blocking mode of the channel: if ``blocking`` is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a `recv` call doesn't find any data, or if a `send` call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \" immediate data \" for `recv`, so if the channel is closed in the read direction, it will never block. ``chan.setblocking(0)`` is equivalent to ``chan.settimeout(0)``; ``chan.setblocking(1)`` is equivalent to ``chan.settimeout(None)``. :param int blocking: 0 to set non-blocking mode; non-0 to set blocking mode. \"\" \" if blocking : self . set timeout ( None ) else : self . set timeout ( 0.0 ) settimeout def settimeout ( self , timeout ) Set a timeout on blocking read/write operations. The timeout argument can be a nonnegative float expressing seconds, or None . If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. chan.settimeout(0.0) is equivalent to chan.setblocking(0) ; chan.settimeout(None) is equivalent to chan.setblocking(1) . Parameters: Name Type Description Default timeout float seconds to wait for a pending read/write operation before raising socket.timeout , or None for no timeout. None View Source def set timeout ( self , timeout ) : \" \"\" Set a timeout on blocking read/write operations. The ``timeout`` argument can be a nonnegative float expressing seconds, or ``None``. If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of ``None`` disables timeouts on socket operations. ``chan.settimeout(0.0)`` is equivalent to ``chan.setblocking(0)``; ``chan.settimeout(None)`` is equivalent to ``chan.setblocking(1)``. :param float timeout: seconds to wait for a pending read/write operation before raising ``socket.timeout``, or ``None`` for no timeout. \"\" \" self . timeout = timeout shutdown def shutdown ( self , how ) Shut down one or both halves of the connection. If how is 0, further receives are disallowed. If how is 1, further sends are disallowed. If how is 2, further sends and receives are disallowed. This closes the stream in one or both directions. Parameters: Name Type Description Default how int 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). None View Source def shutdown ( self , how ) : \" \"\" Shut down one or both halves of the connection. If ``how`` is 0, further receives are disallowed. If ``how`` is 1, further sends are disallowed. If ``how`` is 2, further sends and receives are disallowed. This closes the stream in one or both directions. :param int how: 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). \"\" \" if ( how == 0 ) or ( how == 2 ) : # feign \"read\" shutdown self . eof_received = 1 if ( how == 1 ) or ( how == 2 ) : self . lock . acquire () try : m = self . _send_eof () finally : self . lock . release () if m is not None : self . transport . _send_user_message ( m ) shutdown_read def shutdown_read ( self ) Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to shutdown(0) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_read ( self ): \"\"\" Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(0)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 0 ) shutdown_write def shutdown_write ( self ) Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to shutdown(1) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_write ( self ): \"\"\" Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(1)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 1 ) update_environment def update_environment ( self , environment ) Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in set_environment_variable for details. Parameters: Name Type Description Default environment dict a dictionary containing the name and respective values to set None Raises: Type Description None .SSHException -- if any of the environment variables was rejected by the server or the channel was closed View Source @open_only def update_environment ( self , environment ) : \" \"\" Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in `set_environment_variable` for details. :param dict environment: a dictionary containing the name and respective values to set :raises: `.SSHException` -- if any of the environment variables was rejected by the server or the channel was closed \"\" \" for name , value in environment . items () : try : self . set _environment_variable ( name , value ) except SSHException as e : err = 'Failed to set environment variable \"{}\".' raise SSHException ( err . format ( name ), e )","title":"Sshchannelenvironment"},{"location":"reference/sshChannelEnvironment/#module-sshchannelenvironment","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Ryan Henrichson # Version: 0.5.0 # Date: 12/10/14 # Description: import logging import uuid import traceback import re from paramiko import Channel from threading import RLock from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import SSHExceptionConn from typing import Optional , Union , AnyStr , Any log = logging . getLogger ( 'sshChannelEnvironment' ) # noinspection PyMissingConstructor,PyUnusedLocal class sshChannelWrapper ( Channel ): \"\"\" This is a special wrapper class for the Paramiko Channel class. This is designed to store additional information regarding the status of environment associated with the channel. IE: console type, user permissions, PATH and so on. \"\"\" _id = None __MAIN__ = None _defaultPromptReg = r \"bash-\\d\\.\\d[#|$|>|@|~]\" _defaultPromptCompileReg = None def __new__ ( cls , parentInst : Any , ** kwargs ): parentInst . __class__ = sshChannelWrapper return parentInst def __init__ ( self , parentInst : Any , main : bool = False , ** kwargs ): self . _id = str ( uuid . uuid4 ()) self . __MAIN__ = main self . _defaultPromptCompileReg = re . compile ( self . _defaultPromptReg ) @property def isMain ( self ): return self . __MAIN__ # noinspection PyMissingConstructor,PyUnusedLocal class sshEnvironment ( sshChannelWrapper ): \"\"\" Uses the sshChannelWrapper and is used by the EnvironmentControls. This handles the state of the ssh Environment it is associated with. Such as the prompt/current user/console and so on. \"\"\" BASH = \"BASH\" CSH = \"CSH\" ZSH = \"ZSH\" SH = \"SH\" NOSH = \"NO_SH\" ORACLE = \"ORACLE\" MYSQL = \"MYSQL\" __USER_ESCALATION__ = 1 __CONSOLE_ESCALATION__ = 2 __ENVIRONMENT_CHANGE__ = 3 __UNKNOWN__ = 4 __TYPE_DICT__ = { 'user' : 1 , 'console' : 2 , 'env' : 3 , 'unknown' : 4 } __INVERTED_TYPE_DICT__ = { 1 : 'User' , 2 : 'Console' , 3 : 'Environment' , 4 : 'Unknown' } # Item template Type, Command, Input # InputType is one of the static variables above # Name: This is the console or userName or the name of the environment variable being changed # Command is a string/dictionary that will be ran on the console # Input is usually the password used. But can also be any other expected input for the command to complete. # _template = (type, name, command, input) _template = ( None , None , None , None ) prompt : str = None _consoleStack : list = None _CONSOLESTACK_LOCK : RLock = None def __new__ ( cls , parentInst : Any , * args , ** kwargs ): parentInst . __class__ = sshEnvironment return parentInst def __init__ ( self , parentInst : Any , ** kwargs ): # log.debug(\"Creating the Console Stack Object\") self . _CONSOLESTACK_LOCK = RLock () self . consoleStack = kwargs . get ( 'consoleStack' , []) def __iter__ ( self ): if self . consoleStack : for item in self . consoleStack : yield item def printStack ( self ) -> str : \"\"\" This returns a string. It is a nicely formatted list of the history of console changes on the Environment\"\"\" output = \"\" for item in self . consoleStack : if not item or len ( item ) < 4 : continue typeStr = self . __INVERTED_TYPE_DICT__ . get ( item [ 0 ]) output += f ' { typeStr } : { item [ 1 ] } Using Command: { item [ 2 ] } AdditionalInput: { item [ 3 ] } \\n ' return output def push ( self , item : Union [ tuple , str ], name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool : \"\"\" Append a new change to the console. This is to record a change to the environment. :param item: (either tuple or str) :param name: (str) :param escalationType: (int) This should either be (__USER_ESCALATION__) 1, (__CONSOLE_ESCALATION__) 2, (__ENVIRONMENT_CHANGE__) 3 or (__UNKNOWN__) 4. :param additionalInput: (str) Optional additional information for example a password. :return: (bool) \"\"\" def _parsePushInput ( _item , _name , _escalationType , _additionalInput ): if type ( _item ) is not tuple and ( type ( _escalationType ) is int or type ( _escalationType ) is str ): if type ( _escalationType ) is str : _escalationType = self . __TYPE_DICT__ . get ( _escalationType ) or 4 elif abs ( _escalationType ) > 4 or _escalationType <= 0 : _escalationType = 4 return _escalationType , _name , _item , _additionalInput if type ( _item ) is tuple and len ( _item ) == 4 and type ( _item [ 0 ] is int ): return _item if type ( _item ) is str or type ( _item ) is dict and _escalationType is None : return self . __USER_ESCALATION__ , _name , _item , _additionalInput return False command = _parsePushInput ( item , name , escalationType , additionalInput ) if command is False : return False self . consoleStack . append ( command ) return True def pull ( self ) -> tuple : \"\"\" This pulls from the consoleStack removing the item and returning it. :return: (tuple) The escalation information formated as a tuple \"\"\" if len ( self . consoleStack ) >= 1 : return self . consoleStack . pop () return tuple () def peak ( self ) -> tuple : \"\"\" Just like a peak it simply returns the last console change without removing it. \"\"\" if self . consoleStack : return self . consoleStack [ - 1 ] def peer ( self , num ) -> tuple : \"\"\" Just like a peer for a stack this allows one to look at an particular index of the stack. \"\"\" try : return self . consoleStack [ num ] except : return () def getPreviousEscalation ( self ) -> tuple : return self . peak () def getPreviousEscalationType ( self ) -> int : return self . peak ()[ 0 ] def getUserList ( self ) -> list : \"\"\" This returns a list of users that are currently logged into this environment in order of there login. \"\"\" def _filterUsers ( item ): return self . __USER_ESCALATION__ == item [ 0 ] def _userGenerator ( itemListToGen ): output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output if not self . consoleStack : return [] # itemList = list(filter(_filterUsers, self.consoleStack)) return _userGenerator ( filter ( _filterUsers , self . consoleStack )) def getCurrentUser ( self ) -> str : \"\"\" Returns a string that is the name of the current user authenticated on this environment. \"\"\" currentUsers = self . getUserList () if currentUsers : return currentUsers [ - 1 ] return '' def getConsoleList ( self ) -> list : \"\"\" LIke 'getUserList' but returns a list of the console escalations in order that they happened. \"\"\" def _filterConsoles ( item ): return self . __CONSOLE_ESCALATION__ == item [ 0 ] def _consoleGenerator ( itemListToGen ): output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output # itemList = list(filter(_filterConsoles, self.consoleStack)) return _consoleGenerator ( filter ( _filterConsoles , self . consoleStack )) def getCurrentConsole ( self ) -> str : \"\"\" Like 'getCurrentUser' but gets what the current console type is. \"\"\" consoles = self . getConsoleList () if consoles : return consoles [ - 1 ] return \"BASH\" def resetEnvironment ( self ) -> None : \"\"\" Resets the environment console stack \"\"\" numOfPulls = 0 for item in reversed ( self . consoleStack ): if item [ 0 ] == self . __USER_ESCALATION__ or item [ 0 ] == self . __CONSOLE_ESCALATION__ : break numOfPulls += 1 for x in range ( numOfPulls ): self . consoleStack . pop () @property def console ( self ): return self . getCurrentConsole () @property def userCount ( self ): return len ( self . getUserList ()) @property def consoleStack ( self ): try : with self . _CONSOLESTACK_LOCK : return self . _consoleStack except RuntimeError : pass @consoleStack . setter def consoleStack ( self , value ): try : with self . _CONSOLESTACK_LOCK : self . _consoleStack = value except RuntimeError : pass @consoleStack . deleter def consoleStack ( self ): if self . _consoleStack : del self . _consoleStack @property def numEscalations ( self ): def _filterUsers ( item ): return self . __USER_ESCALATION__ == item [ 0 ] or self . __CONSOLE_ESCALATION__ == item [ 0 ] if not self . consoleStack : return 0 return len ( list ( filter ( _filterUsers , self . consoleStack ))) @property def numUsers ( self ): return len ( self . getUserList ()) @property def userList ( self ): return self . getUserList () @property def whoami ( self ): return self . getCurrentUser () # noinspection PyMissingConstructor,PyUnusedLocal class EnvironmentControls ( sshEnvironment ): \"\"\" This is meant to be an easy access to the methods within the sshEnvironmentControl class. There that class can handle any ssh Environment/Paramiko ssh Channel this wraps a single Channel and when calling the methods within this class it uses the methods of the same name within its sshParent (an instance of sshEnvironmentControl) and passes itself as the environment to be acted on. This also adds locks for thread safe actions and is designed to work along side a Command Container. \"\"\" _LOCK : RLock = None dead : bool = None sshChannel : Channel = None sshParent : Any = None _label : str = None active : bool = None command : Optional [ str ] = None _commandObject : Any = None timeout : Optional [ Union [ int , float ]] = None kwargs : Optional [ dict ] = {} customChannel : bool = None def __new__ ( cls , parentInst : Any , ** kwargs ): parentInst . __class__ = EnvironmentControls return parentInst def __init__ ( self , parentInst : Any , ** kwargs ): \"\"\" Creates the EnvironmentControls object. Read more about the class in the class comments above. - :param sshParent: This is a sshThreader object. The sshThread class passes itself to the container. - :param label: This is a string identifying this channel. This is unnecessary as we already had a UUID. However the label need not be uniq which can lead to some interesting combinations. Such as two \"MySQL\" channels. The search can look for MySQL instead of a specific UUID. It doesn't matter which one it finds. - :return: \"\"\" self . dead = False self . active = False self . _label = kwargs . get ( 'label' , '' ) self . customChannel = kwargs . get ( 'customChannel' , True if self . _label else False ) self . _LOCK = RLock () self . sshParent = kwargs . get ( 'sshParent' ) if kwargs . get ( 'autoConnect' , False ): self . sshParent . createConn () def __enter__ ( self ): if not self . _LOCK . acquire (): raise RuntimeError ( f \"Channel ID: { self . EnvironmentID } The Lock failed within the time frame: 60\" ) if not self . sshParent . checkConnection ( self ): raise SSHExceptionConn ( \"Connection closed!\" ) self . active = True return self # noinspection PyProtectedMember def __exit__ ( self , exc_type , exc_val , exc_tb ): try : self . _LOCK . release () except RuntimeError as e : log . debug ( f \"An RuntimeError occurred while attempting to release lock: { e } \" ) except Exception as e : log . debug ( f \"An unknown error occurred while releasing the lock: { e } \" ) finally : if not self . checkConnection (): log . debug ( \"About to disconnect channel because checkConnection returned False\" ) self . disconnectEnvironment () if not self . _LOCK . _is_owned (): self . active = False del self . commandObject def __hash__ ( self ): return hash ( self . EnvironmentID ) def executeOnEnvironment ( self , * args , ** kwargs ) -> AnyStr : \"\"\" Takes the param command is passes it to executeOnEnvironment function in 'sshCommand' class with the environment and prompt variables as well. - :return: \"\"\" kwargs . pop ( 'environment' , None ) return self . sshParent . executeOnEnvironment ( self , * args , ** kwargs ) def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the escalate method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . escalate ( * args , ** kwargs ) def becomeRoot ( self , * args , ** kwargs ) -> bool : \"\"\" This is specific logic just for handling becoming the root user. This hopefully will be deprecated once sshUserControl becomes more thread friendly. - :return: bool: True if successful or already root, false if it didn't even try. \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . becomeRoot ( * args , ** kwargs ) def becomeUser ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the becomeUser method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . becomeUser ( * args , ** kwargs ) def consoleEscalation ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the consoleEscalation method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . consoleEscalation ( * args , ** kwargs ) def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Wrapper for the environmentChange method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . environmentChange ( * args , ** kwargs ) def getPrompt ( self , reCapturePrompt : bool = False ) -> Optional [ str ]: \"\"\" Wrapper for the getPrompt method on the sshEnvironmentControl \"\"\" return self . sshParent . getPrompt ( self , reCapturePrompt = reCapturePrompt ) def isPromptDefault ( self , reCapturePrompt : bool = False ) -> bool : \"\"\" Uses getPrompt and attempts to determine if prompt is the default bash prompt ie: bash-5.1$ \"\"\" return self . _defaultPromptCompileReg . search ( self . getPrompt ( reCapturePrompt )) is not None def checkConnection ( self ) -> bool : \"\"\" Wrapper for the checkConnection method on the sshEnvironmentControl \"\"\" if not self . sshParent . checkConnection ( self ): self . dead = True return False return True def disconnectEnvironment ( self , * args , ** kwargs ) -> bool : \"\"\" This attempts to log out of the channel gracefully exiting the terminal connection. This should normally be called inside of a thread although it doesn't matter. This also reduces 'channelCount' variable by one. - :param args: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :param kwargs: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :return: (bool) False if it is already disconnected True for everything else \"\"\" with self . _LOCK : try : if not self . checkConnection (): log . debug ( 'Connection already closed this will set \"dead\" variable to True and remove this from ' 'the Environment list' ) return False self . sshParent . disconnect ( environment = self ) except SSHExceptionConn : log . debug ( \"Failed to complete logout correctly! This could because of a corrupt userList!\" ) except Exception as e : log . error ( f \"error in disconnectEnvironment: { e } \" ) log . debug ( f \"[DEBUG] for disconnectEnvironment: { traceback . format_exc () } \" ) finally : self . dead = True self . sshParent . removeEnvironment ( self ) return True def logoutCurrentUser ( self ) -> None : \"\"\" Wrapper for the logoutCurrentUser method on the sshEnvironmentControl \"\"\" self . sshParent . logoutCurrentUser ( environment = self ) def logoutConsole ( self , * args , ** kwargs ) -> bool : \"\"\" A override method for logoutConsole on the sshEnvironmentControl class \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . logoutConsole ( * args , ** kwargs ) def getPasswordFor ( self , name : str ) -> str : \"\"\" Gets the current recorded password for the user specified by the 'name' parameter. :param name: (str) the name of the user that you are getting a password for. :return: (str) \"\"\" def _filterUserByName ( x ): return name . lower () in str ( x [ 1 ]) . lower () if name in self . sshParent . usermap : return self . sshParent . usermap . get ( name , \"\" ) for item in filter ( _filterUserByName , self . consoleStack ): if item [ - 1 ] is not None : return item [ - 1 ] return \"\" # noinspection PyProtectedMember def _becomePreviousUser ( self , * args , ** kwargs ) -> sshEnvironment : \"\"\" De-escalates the current user in a provided channel \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . _becomePreviousUser ( * args , ** kwargs ) @property def isClosed ( self ): return self . dead or not self . sshParent . checkConnection ( sshChannel = self ) @property def commandObject ( self ): return self . _commandObject @commandObject . setter def commandObject ( self , value ): self . command = value . command self . timeout = value . timeout self . kwargs = value . kwargs @commandObject . deleter def commandObject ( self ): self . _commandObject = None self . timeout = None self . kwargs = None @property def userName ( self ): return self . whoami @property def EnvironmentID ( self ): return self . _id @property def label ( self ): if self . __MAIN__ : return \"MAIN\" return self . _label @label . setter def label ( self , value ): if not self . __MAIN__ == \"MAIN\" or str ( value ) == \"MAIN\" : self . _label = str ( value )","title":"Module sshChannelEnvironment"},{"location":"reference/sshChannelEnvironment/#variables","text":"log","title":"Variables"},{"location":"reference/sshChannelEnvironment/#classes","text":"","title":"Classes"},{"location":"reference/sshChannelEnvironment/#environmentcontrols","text":"class EnvironmentControls ( parentInst : Any , ** kwargs ) This is meant to be an easy access to the methods within the sshEnvironmentControl class. There that class can handle any ssh Environment/Paramiko ssh Channel this wraps a single Channel and when calling the methods within this class it uses the methods of the same name within its sshParent (an instance of sshEnvironmentControl) and passes itself as the environment to be acted on. This also adds locks for thread safe actions and is designed to work along side a Command Container.","title":"EnvironmentControls"},{"location":"reference/sshChannelEnvironment/#ancestors-in-mro","text":"sshChannelEnvironment.sshEnvironment sshChannelEnvironment.sshChannelWrapper paramiko.channel.Channel paramiko.util.ClosingContextManager","title":"Ancestors (in MRO)"},{"location":"reference/sshChannelEnvironment/#class-variables","text":"BASH CSH MYSQL NOSH ORACLE SH ZSH active command customChannel dead kwargs prompt sshChannel sshParent timeout","title":"Class variables"},{"location":"reference/sshChannelEnvironment/#instance-variables","text":"EnvironmentID commandObject console consoleStack isClosed isMain label numEscalations numUsers userCount userList userName whoami","title":"Instance variables"},{"location":"reference/sshChannelEnvironment/#methods","text":"","title":"Methods"},{"location":"reference/sshChannelEnvironment/#becomeroot","text":"def becomeRoot ( self , * args , ** kwargs ) -> bool This is specific logic just for handling becoming the root user. This hopefully will be deprecated once sshUserControl becomes more thread friendly. :return: bool: True if successful or already root, false if it didn't even try. View Source def becomeRoot ( self , * args , ** kwargs ) -> bool : \"\"\" This is specific logic just for handling becoming the root user. This hopefully will be deprecated once sshUserControl becomes more thread friendly. - :return: bool: True if successful or already root, false if it didn' t even try . \"\"\" kwargs.update({' environment ': self}) return self.sshParent.becomeRoot(*args, **kwargs)","title":"becomeRoot"},{"location":"reference/sshChannelEnvironment/#becomeuser","text":"def becomeUser ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the becomeUser method on the sshEnvironmentControl View Source def becomeUser ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the becomeUser method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . becomeUser ( * args , ** kwargs )","title":"becomeUser"},{"location":"reference/sshChannelEnvironment/#checkconnection","text":"def checkConnection ( self ) -> bool Wrapper for the checkConnection method on the sshEnvironmentControl View Source def checkConnection ( self ) -> bool : \"\"\" Wrapper for the checkConnection method on the sshEnvironmentControl \"\"\" if not self . sshParent . checkConnection ( self ) : self . dead = True return False return True","title":"checkConnection"},{"location":"reference/sshChannelEnvironment/#close","text":"def close ( self ) Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their .Transport is closed or when they are garbage collected. View Source def close(self): \"\"\" Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their `.Transport` is closed or when they are garbage collected. \"\"\" self.lock.acquire() try: # only close the pipe when the user explicitly closes the channel. # otherwise they will get unpleasant surprises. (and do it before # checking self.closed, since the remote host may have already # closed the connection.) if self._pipe is not None: self._pipe.close() self._pipe = None if not self.active or self.closed: return msgs = self._close_internal() finally: self.lock.release() for m in msgs: if m is not None: self.transport._send_user_message(m)","title":"close"},{"location":"reference/sshChannelEnvironment/#consoleescalation","text":"def consoleEscalation ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the consoleEscalation method on the sshEnvironmentControl View Source def consoleEscalation ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the consoleEscalation method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . consoleEscalation ( * args , ** kwargs )","title":"consoleEscalation"},{"location":"reference/sshChannelEnvironment/#disconnectenvironment","text":"def disconnectEnvironment ( self , * args , ** kwargs ) -> bool This attempts to log out of the channel gracefully exiting the terminal connection. This should normally be called inside of a thread although it doesn't matter. This also reduces 'channelCount' variable by one. :param args: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. :param kwargs: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. :return: (bool) False if it is already disconnected True for everything else View Source def disconnectEnvironment ( self , * args , ** kwargs ) -> bool : \"\"\" This attempts to log out of the channel gracefully exiting the terminal connection. This should normally be called inside of a thread although it doesn't matter. This also reduces 'channelCount' variable by one. - :param args: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :param kwargs: This is simply a place holder to satisfy the '_Worker' class from the ThreadPool. - :return: (bool) False if it is already disconnected True for everything else \"\"\" with self . _LOCK : try : if not self . checkConnection () : log . debug ( 'Connection already closed this will set \"dead\" variable to True and remove this from ' 'the Environment list' ) return False self . sshParent . disconnect ( environment = self ) except SSHExceptionConn : log . debug ( \"Failed to complete logout correctly! This could because of a corrupt userList!\" ) except Exception as e : log . error ( f \"error in disconnectEnvironment: {e}\" ) log . debug ( f \"[DEBUG] for disconnectEnvironment: {traceback.format_exc()}\" ) finally : self . dead = True self . sshParent . removeEnvironment ( self ) return True","title":"disconnectEnvironment"},{"location":"reference/sshChannelEnvironment/#environmentchange","text":"def environmentChange ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the environmentChange method on the sshEnvironmentControl View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the environmentChange method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . environmentChange ( * args , ** kwargs )","title":"environmentChange"},{"location":"reference/sshChannelEnvironment/#escalate","text":"def escalate ( self , * args , ** kwargs ) -> Union [ sshChannelEnvironment . sshEnvironment , bool ] Wrapper for the escalate method on the sshEnvironmentControl View Source def escalate ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ] : \"\"\" Wrapper for the escalate method on the sshEnvironmentControl \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . escalate ( * args , ** kwargs )","title":"escalate"},{"location":"reference/sshChannelEnvironment/#exec_command","text":"def exec_command ( self , command ) Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. Parameters: Name Type Description Default command str a shell command to execute. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def exec_command ( self , command ) : \"\"\" Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. :param str command: a shell command to execute. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"exec\" ) m . add_boolean ( True ) m . add_string ( command ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"exec_command"},{"location":"reference/sshChannelEnvironment/#executeonenvironment","text":"def executeOnEnvironment ( self , * args , ** kwargs ) -> ~ AnyStr Takes the param command is passes it to executeOnEnvironment function in 'sshCommand' class with the environment and prompt variables as well. :return: View Source def executeOnEnvironment ( self , * args , ** kwargs ) -> AnyStr : \"\"\" Takes the param command is passes it to executeOnEnvironment function in 'sshCommand' class with the environment and prompt variables as well. - :return: \"\"\" kwargs . pop ( 'environment' , None ) return self . sshParent . executeOnEnvironment ( self , * args , ** kwargs )","title":"executeOnEnvironment"},{"location":"reference/sshChannelEnvironment/#exit_status_ready","text":"def exit_status_ready ( self ) Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in recv_exit_status . Note that the server may not return an exit status in some cases (like bad servers). Returns: Type Description None True if recv_exit_status will return immediately, else False . .. versionadded:: 1.7.3 View Source def exit_status_ready ( self ) : \" \"\" Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in `recv_exit_status`. Note that the server may not return an exit status in some cases (like bad servers). :return: ``True`` if `recv_exit_status` will return immediately, else ``False``. .. versionadded:: 1.7.3 \"\" \" return self . closed or self . status_event . is_set ()","title":"exit_status_ready"},{"location":"reference/sshChannelEnvironment/#fileno","text":"def fileno ( self ) Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's select module to work. The first time fileno is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) Returns: Type Description None an OS-level file descriptor ( int ) .. warning:: This method causes channel reads to be slightly less efficient. View Source def fileno ( self ) : \" \"\" Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's ``select`` module to work. The first time ``fileno`` is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) :return: an OS-level file descriptor (`int`) .. warning:: This method causes channel reads to be slightly less efficient. \"\" \" self . lock . acquire () try : if self . _pipe is not None : return self . _pipe . fileno () # create the pipe and feed in any existing data self . _pipe = pipe . make_pipe () p1 , p2 = pipe . make_or_pipe ( self . _pipe ) self . in_buffer . set _event ( p1 ) self . in_stderr_buffer . set _event ( p2 ) return self . _pipe . fileno () finally : self . lock . release ()","title":"fileno"},{"location":"reference/sshChannelEnvironment/#getconsolelist","text":"def getConsoleList ( self ) -> list LIke 'getUserList' but returns a list of the console escalations in order that they happened. View Source def getConsoleList ( self ) -> list : \"\"\" LIke ' getUserList ' but returns a list of the console escalations in order that they happened. \"\"\" def _filterConsoles ( item ) : return self . __CONSOLE_ESCALATION__ == item [ 0 ] def _consoleGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output # itemList = list ( filter ( _filterConsoles , self . consoleStack )) return _consoleGenerator ( filter ( _filterConsoles , self . consoleStack ))","title":"getConsoleList"},{"location":"reference/sshChannelEnvironment/#getcurrentconsole","text":"def getCurrentConsole ( self ) -> str Like 'getCurrentUser' but gets what the current console type is. View Source def getCurrentConsole ( self ) -> str : \"\"\" Like 'getCurrentUser' but gets what the current console type is. \"\"\" consoles = self . getConsoleList () if consoles : return consoles [ - 1 ] return \"BASH\"","title":"getCurrentConsole"},{"location":"reference/sshChannelEnvironment/#getcurrentuser","text":"def getCurrentUser ( self ) -> str Returns a string that is the name of the current user authenticated on this environment. View Source def getCurrentUser ( self ) -> str : \"\"\" Returns a string that is the name of the current user authenticated on this environment. \"\"\" currentUsers = self . getUserList () if currentUsers : return currentUsers [ - 1 ] return ''","title":"getCurrentUser"},{"location":"reference/sshChannelEnvironment/#getpasswordfor","text":"def getPasswordFor ( self , name : str ) -> str Gets the current recorded password for the user specified by the 'name' parameter. Parameters: Name Type Description Default name None (str) the name of the user that you are getting a password for. None Returns: Type Description None (str) View Source def getPasswordFor ( self , name : str ) -> str : \"\"\" Gets the current recorded password for the user specified by the ' name ' parameter. :param name: (str) the name of the user that you are getting a password for. :return: (str) \"\"\" def _filterUserByName ( x ) : return name . lower () in str ( x [ 1 ]). lower () if name in self . sshParent . usermap : return self . sshParent . usermap . get ( name , \"\" ) for item in filter ( _filterUserByName , self . consoleStack ) : if item [ - 1 ] is not None : return item [ - 1 ] return \"\"","title":"getPasswordFor"},{"location":"reference/sshChannelEnvironment/#getpreviousescalation","text":"def getPreviousEscalation ( self ) -> tuple View Source def getPreviousEscalation ( self ) -> tuple : return self . peak ()","title":"getPreviousEscalation"},{"location":"reference/sshChannelEnvironment/#getpreviousescalationtype","text":"def getPreviousEscalationType ( self ) -> int View Source def getPreviousEscalationType ( self ) -> int : return self . peak ()[ 0 ]","title":"getPreviousEscalationType"},{"location":"reference/sshChannelEnvironment/#getprompt","text":"def getPrompt ( self , reCapturePrompt : bool = False ) -> Optional [ str ] Wrapper for the getPrompt method on the sshEnvironmentControl View Source def getPrompt ( self , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" Wrapper for the getPrompt method on the sshEnvironmentControl \"\"\" return self . sshParent . getPrompt ( self , reCapturePrompt = reCapturePrompt )","title":"getPrompt"},{"location":"reference/sshChannelEnvironment/#getuserlist","text":"def getUserList ( self ) -> list This returns a list of users that are currently logged into this environment in order of there login. View Source def getUserList ( self ) -> list : \"\"\" This returns a list of users that are currently logged into this environment in order of there login. \"\"\" def _filterUsers ( item ) : return self . __USER_ESCALATION__ == item [ 0 ] def _userGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output if not self . consoleStack : return [] # itemList = list ( filter ( _filterUsers , self . consoleStack )) return _userGenerator ( filter ( _filterUsers , self . consoleStack ))","title":"getUserList"},{"location":"reference/sshChannelEnvironment/#get_id","text":"def get_id ( self ) Return the int ID # for this channel. The channel ID is unique across a .Transport and usually a small number. It's also the number passed to .ServerInterface.check_channel_request when determining whether to accept a channel request in server mode. View Source def get_id ( self ) : \" \"\" Return the `int` ID # for this channel. The channel ID is unique across a `.Transport` and usually a small number. It's also the number passed to `.ServerInterface.check_channel_request` when determining whether to accept a channel request in server mode. \"\" \" return self . chanid","title":"get_id"},{"location":"reference/sshChannelEnvironment/#get_name","text":"def get_name ( self ) Get the name of this channel that was previously set by set_name . View Source def get_name ( self ) : \" \"\" Get the name of this channel that was previously set by `set_name`. \"\" \" return self . _name","title":"get_name"},{"location":"reference/sshChannelEnvironment/#get_pty","text":"def get_pty ( self , term = 'vt100' , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with invoke_shell . It isn't necessary (or desirable) to call this method if you're going to execute a single command with exec_command . Parameters: Name Type Description Default term str the terminal type to emulate (for example, 'vt100' ) None width int width (in characters) of the terminal screen None height int height (in characters) of the terminal screen None width_pixels int width (in pixels) of the terminal screen None height_pixels int height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def get_pty ( self , term = \"vt100\" , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 , ) : \" \"\" Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with `invoke_shell`. It isn't necessary (or desirable) to call this method if you're going to execute a single command with `exec_command`. :param str term: the terminal type to emulate (for example, ``'vt100'``) :param int width: width (in characters) of the terminal screen :param int height: height (in characters) of the terminal screen :param int width_pixels: width (in pixels) of the terminal screen :param int height_pixels: height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"pty-req\" ) m . add_boolean ( True ) m . add_string ( term ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) m . add_string ( bytes ()) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"get_pty"},{"location":"reference/sshChannelEnvironment/#get_transport","text":"def get_transport ( self ) Return the .Transport associated with this channel. View Source def get_transport(self): \"\"\" Return the `.Transport` associated with this channel. \"\"\" return self.transport","title":"get_transport"},{"location":"reference/sshChannelEnvironment/#getpeername","text":"def getpeername ( self ) Return the address of the remote side of this Channel, if possible. This simply wraps .Transport.getpeername , used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call 'getpeername' .) View Source def getpeername ( self ): \"\"\" Return the address of the remote side of this Channel, if possible. This simply wraps `.Transport.getpeername`, used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call ``'getpeername'``.) \"\"\" return self . transport . getpeername ()","title":"getpeername"},{"location":"reference/sshChannelEnvironment/#gettimeout","text":"def gettimeout ( self ) Returns the timeout in seconds (as a float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking or settimeout . View Source def gettimeout ( self ) : \" \"\" Returns the timeout in seconds (as a float) associated with socket operations, or ``None`` if no timeout is set. This reflects the last call to `setblocking` or `settimeout`. \"\" \" return self . timeout","title":"gettimeout"},{"location":"reference/sshChannelEnvironment/#invoke_shell","text":"def invoke_shell ( self ) Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call get_pty before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_shell ( self ) : \" \"\" Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call `get_pty` before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"shell\" ) m . add_boolean ( True ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"invoke_shell"},{"location":"reference/sshChannelEnvironment/#invoke_subsystem","text":"def invoke_subsystem ( self , subsystem ) Request a subsystem on the server (for example, sftp ). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. Parameters: Name Type Description Default subsystem str name of the subsystem being requested. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_subsystem ( self , subsystem ) : \" \"\" Request a subsystem on the server (for example, ``sftp``). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. :param str subsystem: name of the subsystem being requested. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"subsystem\" ) m . add_boolean ( True ) m . add_string ( subsystem ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"invoke_subsystem"},{"location":"reference/sshChannelEnvironment/#ispromptdefault","text":"def isPromptDefault ( self , reCapturePrompt : bool = False ) -> bool Uses getPrompt and attempts to determine if prompt is the default bash prompt ie: bash-5.1$ View Source def isPromptDefault ( self , reCapturePrompt : bool = False ) -> bool : \"\"\" Uses getPrompt and attempts to determine if prompt is the default bash prompt ie: bash-5.1$ \"\"\" return self . _defaultPromptCompileReg . search ( self . getPrompt ( reCapturePrompt )) is not None","title":"isPromptDefault"},{"location":"reference/sshChannelEnvironment/#logoutconsole","text":"def logoutConsole ( self , * args , ** kwargs ) -> bool A override method for logoutConsole on the sshEnvironmentControl class View Source def logoutConsole ( self , * args , ** kwargs ) -> bool : \"\"\" A override method for logoutConsole on the sshEnvironmentControl class \"\"\" kwargs . update ({ 'environment' : self }) return self . sshParent . logoutConsole ( * args , ** kwargs )","title":"logoutConsole"},{"location":"reference/sshChannelEnvironment/#logoutcurrentuser","text":"def logoutCurrentUser ( self ) -> None Wrapper for the logoutCurrentUser method on the sshEnvironmentControl View Source def logoutCurrentUser ( self ) -> None : \"\"\" Wrapper for the logoutCurrentUser method on the sshEnvironmentControl \"\"\" self . sshParent . logoutCurrentUser ( environment = self )","title":"logoutCurrentUser"},{"location":"reference/sshChannelEnvironment/#makefile","text":"def makefile ( self , * params ) Return a file-like object associated with this channel. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. Returns: Type Description None .ChannelFile object which can be used for Python file I/O. View Source def makefile ( self , * params ) : \" \"\" Return a file-like object associated with this channel. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. :return: `.ChannelFile` object which can be used for Python file I/O. \"\" \" return ChannelFile ( * ( [ self ] + list ( params )))","title":"makefile"},{"location":"reference/sshChannelEnvironment/#makefile_stderr","text":"def makefile_stderr ( self , * params ) Return a file-like object associated with this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. Returns: Type Description None .ChannelStderrFile object which can be used for Python file I/O. .. versionadded:: 1.1 View Source def makefile_stderr ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. :returns: `.ChannelStderrFile` object which can be used for Python file I/O. .. versionadded:: 1.1 \"\" \" return ChannelStderrFile ( * ( [ self ] + list ( params )))","title":"makefile_stderr"},{"location":"reference/sshChannelEnvironment/#makefile_stdin","text":"def makefile_stdin ( self , * params ) Return a file-like object associated with this channel's stdin stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. Returns: Type Description None .ChannelStdinFile object which can be used for Python file I/O. .. versionadded:: 2.6 View Source def makefile_stdin ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stdin stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. :returns: `.ChannelStdinFile` object which can be used for Python file I/O. .. versionadded:: 2.6 \"\" \" return ChannelStdinFile ( * ( [ self ] + list ( params )))","title":"makefile_stdin"},{"location":"reference/sshChannelEnvironment/#peak","text":"def peak ( self ) -> tuple Just like a peak it simply returns the last console change without removing it. View Source def peak ( self ) -> tuple : \"\"\" Just like a peak it simply returns the last console change without removing it. \"\"\" if self . consoleStack : return self . consoleStack [ - 1 ]","title":"peak"},{"location":"reference/sshChannelEnvironment/#peer","text":"def peer ( self , num ) -> tuple Just like a peer for a stack this allows one to look at an particular index of the stack. View Source def peer ( self , num ) -> tuple : \"\"\" Just like a peer for a stack this allows one to look at an particular index of the stack. \"\"\" try : return self . consoleStack [ num ] except : return ()","title":"peer"},{"location":"reference/sshChannelEnvironment/#printstack","text":"def printStack ( self ) -> str This returns a string. It is a nicely formatted list of the history of console changes on the Environment View Source def printStack ( self ) -> str : \"\"\" This returns a string. It is a nicely formatted list of the history of console changes on the Environment\"\"\" output = \"\" for item in self . consoleStack : if not item or len ( item ) < 4 : continue typeStr = self . __INVERTED_TYPE_DICT__ . get ( item [ 0 ]) output += f ' { typeStr }: { item [ 1 ]} Using Command : { item [ 2 ]} AdditionalInput : { item [ 3 ]} \\ n ' return output","title":"printStack"},{"location":"reference/sshChannelEnvironment/#pull","text":"def pull ( self ) -> tuple This pulls from the consoleStack removing the item and returning it. Returns: Type Description None (tuple) The escalation information formated as a tuple View Source def pull ( self ) -> tuple : \"\"\" This pulls from the consoleStack removing the item and returning it. :return: (tuple) The escalation information formated as a tuple \"\"\" if len ( self . consoleStack ) >= 1 : return self . consoleStack . pop () return tuple ()","title":"pull"},{"location":"reference/sshChannelEnvironment/#push","text":"def push ( self , item : Union [ tuple , str ], name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool Append a new change to the console. This is to record a change to the environment. Parameters: Name Type Description Default item None (either tuple or str) None name None (str) None escalationType None (int) This should either be ( USER_ESCALATION ) 1, ( CONSOLE_ESCALATION ) 2, ( ENVIRONMENT_CHANGE ) 3 or ( UNKNOWN ) 4. None additionalInput None (str) Optional additional information for example a password. None Returns: Type Description None (bool) View Source def push ( self , item : Union [ tuple, str ] , name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool : \"\"\" Append a new change to the console. This is to record a change to the environment. :param item: (either tuple or str) :param name: (str) :param escalationType: (int) This should either be (__USER_ESCALATION__) 1, (__CONSOLE_ESCALATION__) 2, (__ENVIRONMENT_CHANGE__) 3 or (__UNKNOWN__) 4. :param additionalInput: (str) Optional additional information for example a password. :return: (bool) \"\"\" def _parsePushInput ( _item , _name , _escalationType , _additionalInput ) : if type ( _item ) is not tuple and ( type ( _escalationType ) is int or type ( _escalationType ) is str ) : if type ( _escalationType ) is str : _escalationType = self . __TYPE_DICT__ . get ( _escalationType ) or 4 elif abs ( _escalationType ) > 4 or _escalationType <= 0 : _escalationType = 4 return _escalationType , _name , _item , _additionalInput if type ( _item ) is tuple and len ( _item ) == 4 and type ( _item [ 0 ] is int ) : return _item if type ( _item ) is str or type ( _item ) is dict and _escalationType is None : return self . __USER_ESCALATION__ , _name , _item , _additionalInput return False command = _parsePushInput ( item , name , escalationType , additionalInput ) if command is False : return False self . consoleStack . append ( command ) return True","title":"push"},{"location":"reference/sshChannelEnvironment/#recv","text":"def recv ( self , nbytes ) Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data, as a bytes . Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . View Source def recv ( self , nbytes ) : \" \"\" Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data, as a `bytes`. :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. \"\" \" try : out = self . in_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out","title":"recv"},{"location":"reference/sshChannelEnvironment/#recv_exit_status","text":"def recv_exit_status ( self ) Return the exit status from the process on the server. This is mostly useful for retrieving the results of an exec_command . If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current .Transport or session's window_size (e.g. that set by the default_window_size kwarg for .Transport.__init__ ) will cause .recv_exit_status to hang indefinitely if it is called prior to a sufficiently large .Channel.recv (or if there are no threads calling .Channel.recv in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. Returns: Type Description None the exit code (as an int ) of the process on the server. .. versionadded:: 1.2 View Source def recv_exit_status ( self ) : \" \"\" Return the exit status from the process on the server. This is mostly useful for retrieving the results of an `exec_command`. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current `.Transport` or session's ``window_size`` (e.g. that set by the ``default_window_size`` kwarg for `.Transport.__init__`) will cause `.recv_exit_status` to hang indefinitely if it is called prior to a sufficiently large `.Channel.recv` (or if there are no threads calling `.Channel.recv` in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. :return: the exit code (as an `int`) of the process on the server. .. versionadded:: 1.2 \"\" \" self . status_event . wait () assert self . status_event . is_set () return self . exit_status","title":"recv_exit_status"},{"location":"reference/sshChannelEnvironment/#recv_ready","text":"def recv_ready ( self ) Returns true if data is buffered and ready to be read from this channel. A False result does not mean that the channel has closed; it means you may need to wait before more data arrives. Returns: Type Description None True if a recv call on this channel would immediately return at least one byte; False otherwise. View Source def recv_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel. A ``False`` result does not mean that the channel has closed; it means you may need to wait before more data arrives. :return: ``True`` if a `recv` call on this channel would immediately return at least one byte; ``False`` otherwise. \"\" \" return self . in_buffer . read_ready ()","title":"recv_ready"},{"location":"reference/sshChannelEnvironment/#recv_stderr","text":"def recv_stderr ( self , nbytes ) Receive data from the channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data as a bytes Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . .. versionadded:: 1.1 View Source def recv_stderr ( self , nbytes ) : \" \"\" Receive data from the channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data as a `bytes` :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" try : out = self . in_stderr_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out","title":"recv_stderr"},{"location":"reference/sshChannelEnvironment/#recv_stderr_ready","text":"def recv_stderr_ready ( self ) Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. Returns: Type Description None True if a recv_stderr call on this channel would immediately return at least one byte; False otherwise. .. versionadded:: 1.1 View Source def recv_stderr_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. :return: ``True`` if a `recv_stderr` call on this channel would immediately return at least one byte; ``False`` otherwise. .. versionadded:: 1.1 \"\" \" return self . in_stderr_buffer . read_ready ()","title":"recv_stderr_ready"},{"location":"reference/sshChannelEnvironment/#request_forward_agent","text":"def request_forward_agent ( self , handler ) Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! Parameters: Name Type Description Default handler None a required callable handler to use for incoming SSH Agent connections None Returns: Type Description None True if we are ok, else False (at that time we always return ok) Raises: Type Description None SSHException in case of channel problem. View Source @open_only def request_forward_agent ( self , handler ) : \"\"\" Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! :param handler: a required callable handler to use for incoming SSH Agent connections :return: True if we are ok, else False (at that time we always return ok) :raises: SSHException in case of channel problem. \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"auth-agent-req@openssh.com\" ) m . add_boolean ( False ) self . transport . _send_user_message ( m ) self . transport . _set_forward_agent_handler ( handler ) return True","title":"request_forward_agent"},{"location":"reference/sshChannelEnvironment/#request_x11","text":"def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None ) Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc: 4254 :: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake , random cookie , and that the cookie be checked and replaced by the real cookie when a connection request is received . If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using .Transport.accept . The handler's calling signature is:: handler ( channel : Channel , ( address : str , port : int )) Parameters: Name Type Description Default screen_number int the x11 screen number (0, 10, etc.) None auth_protocol str the name of the X11 authentication method used; if none is given, \"MIT-MAGIC-COOKIE-1\" is used None auth_cookie str hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated None single_connection bool if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) None handler None an optional callable handler to use for incoming X11 connections None Returns: Type Description None the auth_cookie used View Source @ open_only def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None , ): \"\"\" Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc:`4254`:: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake, random cookie, and that the cookie be checked and replaced by the real cookie when a connection request is received. If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using `.Transport.accept`. The handler's calling signature is:: handler(channel: Channel, (address: str, port: int)) :param int screen_number: the x11 screen number (0, 10, etc.) :param str auth_protocol: the name of the X11 authentication method used; if none is given, ``\" MIT - MAGIC - COOKIE - 1 \"`` is used :param str auth_cookie: hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated :param bool single_connection: if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) :param handler: an optional callable handler to use for incoming X11 connections :return: the auth_cookie used \"\"\" if auth_protocol is None : auth_protocol = \"MIT-MAGIC-COOKIE-1\" if auth_cookie is None : auth_cookie = binascii . hexlify ( os . urandom ( 16 )) m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"x11-req\" ) m . add_boolean ( True ) m . add_boolean ( single_connection ) m . add_string ( auth_protocol ) m . add_string ( auth_cookie ) m . add_int ( screen_number ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () self . transport . _set_x11_handler ( handler ) return auth_cookie","title":"request_x11"},{"location":"reference/sshChannelEnvironment/#resetenvironment","text":"def resetEnvironment ( self ) -> None Resets the environment console stack View Source def resetEnvironment ( self ) -> None : \"\"\" Resets the environment console stack \"\"\" numOfPulls = 0 for item in reversed ( self . consoleStack ) : if item [ 0 ] == self . __USER_ESCALATION__ or item [ 0 ] == self . __CONSOLE_ESCALATION__ : break numOfPulls += 1 for x in range ( numOfPulls ) : self . consoleStack . pop ()","title":"resetEnvironment"},{"location":"reference/sshChannelEnvironment/#resize_pty","text":"def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous get_pty call. Parameters: Name Type Description Default width int new width (in characters) of the terminal screen None height int new height (in characters) of the terminal screen None width_pixels int new width (in pixels) of the terminal screen None height_pixels int new height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) : \" \"\" Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous `get_pty` call. :param int width: new width (in characters) of the terminal screen :param int height: new height (in characters) of the terminal screen :param int width_pixels: new width (in pixels) of the terminal screen :param int height_pixels: new height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"window-change\" ) m . add_boolean ( False ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) self . transport . _send_user_message ( m )","title":"resize_pty"},{"location":"reference/sshChannelEnvironment/#send","text":"def send ( self , s ) Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send None Returns: Type Description None number of bytes actually sent, as an int Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . View Source def send ( self , s ) : \" \"\" Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send :return: number of bytes actually sent, as an `int` :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_DATA ) m . add_int ( self . remote_chanid ) return self . _send ( s , m )","title":"send"},{"location":"reference/sshChannelEnvironment/#send_exit_status","text":"def send_exit_status ( self , status ) Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. Parameters: Name Type Description Default status int the exit code of the process .. versionadded:: 1.2 None View Source def send_exit_status(self, status): \"\"\" Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. :param int status: the exit code of the process .. versionadded:: 1.2 \"\"\" # in many cases, the channel will not still be open here. # that's fine. m = Message() m.add_byte(cMSG_CHANNEL_REQUEST) m.add_int(self.remote_chanid) m.add_string(\"exit-status\") m.add_boolean(False) m.add_int(status) self.transport._send_user_message(m)","title":"send_exit_status"},{"location":"reference/sshChannelEnvironment/#send_ready","text":"def send_ready ( self ) Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a send call will succeed immediately and return the number of bytes actually written. Returns: Type Description None True if a send call on this channel would immediately succeed or fail View Source def send_ready ( self ) : \" \"\" Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a `send` call will succeed immediately and return the number of bytes actually written. :return: ``True`` if a `send` call on this channel would immediately succeed or fail \"\" \" self . lock . acquire () try : if self . closed or self . eof_sent : return True return self . out_window_size > 0 finally : self . lock . release ()","title":"send_ready"},{"location":"reference/sshChannelEnvironment/#send_stderr","text":"def send_stderr ( self , s ) Send data to the channel on the \"stderr\" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send. None Returns: Type Description None number of bytes actually sent, as an int . Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . .. versionadded:: 1.1 View Source def send_stderr ( self , s ) : \" \"\" Send data to the channel on the \" stderr \" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send. :return: number of bytes actually sent, as an `int`. :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_EXTENDED_DATA ) m . add_int ( self . remote_chanid ) m . add_int ( 1 ) return self . _send ( s , m )","title":"send_stderr"},{"location":"reference/sshChannelEnvironment/#sendall","text":"def sendall ( self , s ) Send data to the channel, without allowing partial results. Unlike send , this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. View Source def sendall ( self , s ) : \" \"\" Send data to the channel, without allowing partial results. Unlike `send`, this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. \"\" \" while s : sent = self . send ( s ) s = s [ sent : ] return None","title":"sendall"},{"location":"reference/sshChannelEnvironment/#sendall_stderr","text":"def sendall_stderr ( self , s ) Send data to the channel's \"stderr\" stream, without allowing partial results. Unlike send_stderr , this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send to the client as \"stderr\" output. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. versionadded:: 1.1 View Source def sendall_stderr ( self , s ) : \" \"\" Send data to the channel's \" stderr \" stream, without allowing partial results. Unlike `send_stderr`, this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send to the client as \" stderr \" output. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. versionadded:: 1.1 \"\" \" while s : sent = self . send_stderr ( s ) s = s [ sent : ] return None","title":"sendall_stderr"},{"location":"reference/sshChannelEnvironment/#set_combine_stderr","text":"def set_combine_stderr ( self , combine ) Set whether stderr should be combined into stdout on this channel. The default is False , but in some cases it may be convenient to have both streams combined. If this is False , and exec_command is called (or invoke_shell with no pty), output to stderr will not show up through the recv and recv_ready calls. You will have to use recv_stderr and recv_stderr_ready to get stderr output. If this is True , data will never show up via recv_stderr or recv_stderr_ready . Parameters: Name Type Description Default combine bool True if stderr output should be combined into stdout on this channel. None Returns: Type Description None the previous setting (a bool ). .. versionadded:: 1.1 View Source def set _combine_stderr ( self , combine ) : \" \"\" Set whether stderr should be combined into stdout on this channel. The default is ``False``, but in some cases it may be convenient to have both streams combined. If this is ``False``, and `exec_command` is called (or ``invoke_shell`` with no pty), output to stderr will not show up through the `recv` and `recv_ready` calls. You will have to use `recv_stderr` and `recv_stderr_ready` to get stderr output. If this is ``True``, data will never show up via `recv_stderr` or `recv_stderr_ready`. :param bool combine: ``True`` if stderr output should be combined into stdout on this channel. :return: the previous setting (a `bool`). .. versionadded:: 1.1 \"\" \" data = bytes () self . lock . acquire () try : old = self . combine_stderr self . combine_stderr = combine if combine and not old : # copy old stderr buffer into primary buffer data = self . in_stderr_buffer . empty () finally : self . lock . release () if len ( data ) > 0 : self . _feed ( data ) return old","title":"set_combine_stderr"},{"location":"reference/sshChannelEnvironment/#set_environment_variable","text":"def set_environment_variable ( self , name , value ) Set the value of an environment variable. .. warning:: The server may reject this request depending on its AcceptEnv setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! Parameters: Name Type Description Default name str name of the environment variable None value str value of the environment variable None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def set _environment_variable ( self , name , value ) : \" \"\" Set the value of an environment variable. .. warning:: The server may reject this request depending on its ``AcceptEnv`` setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! :param str name: name of the environment variable :param str value: value of the environment variable :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"env\" ) m . add_boolean ( False ) m . add_string ( name ) m . add_string ( value ) self . transport . _send_user_message ( m )","title":"set_environment_variable"},{"location":"reference/sshChannelEnvironment/#set_name","text":"def set_name ( self , name ) Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the get_name method. Parameters: Name Type Description Default name str new channel name None View Source def set _name ( self , name ) : \" \"\" Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the `get_name` method. :param str name: new channel name \"\" \" self . _name = name","title":"set_name"},{"location":"reference/sshChannelEnvironment/#setblocking","text":"def setblocking ( self , blocking ) Set blocking or non-blocking mode of the channel: if blocking is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a recv call doesn't find any data, or if a send call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \"immediate data\" for recv , so if the channel is closed in the read direction, it will never block. chan.setblocking(0) is equivalent to chan.settimeout(0) ; chan.setblocking(1) is equivalent to chan.settimeout(None) . Parameters: Name Type Description Default blocking int 0 to set non-blocking mode; non-0 to set blocking mode. None View Source def set blocking ( self , blocking ) : \" \"\" Set blocking or non-blocking mode of the channel: if ``blocking`` is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a `recv` call doesn't find any data, or if a `send` call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \" immediate data \" for `recv`, so if the channel is closed in the read direction, it will never block. ``chan.setblocking(0)`` is equivalent to ``chan.settimeout(0)``; ``chan.setblocking(1)`` is equivalent to ``chan.settimeout(None)``. :param int blocking: 0 to set non-blocking mode; non-0 to set blocking mode. \"\" \" if blocking : self . set timeout ( None ) else : self . set timeout ( 0.0 )","title":"setblocking"},{"location":"reference/sshChannelEnvironment/#settimeout","text":"def settimeout ( self , timeout ) Set a timeout on blocking read/write operations. The timeout argument can be a nonnegative float expressing seconds, or None . If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. chan.settimeout(0.0) is equivalent to chan.setblocking(0) ; chan.settimeout(None) is equivalent to chan.setblocking(1) . Parameters: Name Type Description Default timeout float seconds to wait for a pending read/write operation before raising socket.timeout , or None for no timeout. None View Source def set timeout ( self , timeout ) : \" \"\" Set a timeout on blocking read/write operations. The ``timeout`` argument can be a nonnegative float expressing seconds, or ``None``. If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of ``None`` disables timeouts on socket operations. ``chan.settimeout(0.0)`` is equivalent to ``chan.setblocking(0)``; ``chan.settimeout(None)`` is equivalent to ``chan.setblocking(1)``. :param float timeout: seconds to wait for a pending read/write operation before raising ``socket.timeout``, or ``None`` for no timeout. \"\" \" self . timeout = timeout","title":"settimeout"},{"location":"reference/sshChannelEnvironment/#shutdown","text":"def shutdown ( self , how ) Shut down one or both halves of the connection. If how is 0, further receives are disallowed. If how is 1, further sends are disallowed. If how is 2, further sends and receives are disallowed. This closes the stream in one or both directions. Parameters: Name Type Description Default how int 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). None View Source def shutdown ( self , how ) : \" \"\" Shut down one or both halves of the connection. If ``how`` is 0, further receives are disallowed. If ``how`` is 1, further sends are disallowed. If ``how`` is 2, further sends and receives are disallowed. This closes the stream in one or both directions. :param int how: 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). \"\" \" if ( how == 0 ) or ( how == 2 ) : # feign \"read\" shutdown self . eof_received = 1 if ( how == 1 ) or ( how == 2 ) : self . lock . acquire () try : m = self . _send_eof () finally : self . lock . release () if m is not None : self . transport . _send_user_message ( m )","title":"shutdown"},{"location":"reference/sshChannelEnvironment/#shutdown_read","text":"def shutdown_read ( self ) Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to shutdown(0) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_read ( self ): \"\"\" Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(0)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 0 )","title":"shutdown_read"},{"location":"reference/sshChannelEnvironment/#shutdown_write","text":"def shutdown_write ( self ) Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to shutdown(1) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_write ( self ): \"\"\" Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(1)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 1 )","title":"shutdown_write"},{"location":"reference/sshChannelEnvironment/#update_environment","text":"def update_environment ( self , environment ) Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in set_environment_variable for details. Parameters: Name Type Description Default environment dict a dictionary containing the name and respective values to set None Raises: Type Description None .SSHException -- if any of the environment variables was rejected by the server or the channel was closed View Source @open_only def update_environment ( self , environment ) : \" \"\" Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in `set_environment_variable` for details. :param dict environment: a dictionary containing the name and respective values to set :raises: `.SSHException` -- if any of the environment variables was rejected by the server or the channel was closed \"\" \" for name , value in environment . items () : try : self . set _environment_variable ( name , value ) except SSHException as e : err = 'Failed to set environment variable \"{}\".' raise SSHException ( err . format ( name ), e )","title":"update_environment"},{"location":"reference/sshChannelEnvironment/#sshchannelwrapper","text":"class sshChannelWrapper ( parentInst : Any , main : bool = False , ** kwargs ) This is a special wrapper class for the Paramiko Channel class. This is designed to store additional information regarding the status of environment associated with the channel. IE: console type, user permissions, PATH and so on.","title":"sshChannelWrapper"},{"location":"reference/sshChannelEnvironment/#ancestors-in-mro_1","text":"paramiko.channel.Channel paramiko.util.ClosingContextManager","title":"Ancestors (in MRO)"},{"location":"reference/sshChannelEnvironment/#descendants","text":"sshChannelEnvironment.sshEnvironment","title":"Descendants"},{"location":"reference/sshChannelEnvironment/#instance-variables_1","text":"isMain","title":"Instance variables"},{"location":"reference/sshChannelEnvironment/#methods_1","text":"","title":"Methods"},{"location":"reference/sshChannelEnvironment/#close_1","text":"def close ( self ) Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their .Transport is closed or when they are garbage collected. View Source def close(self): \"\"\" Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their `.Transport` is closed or when they are garbage collected. \"\"\" self.lock.acquire() try: # only close the pipe when the user explicitly closes the channel. # otherwise they will get unpleasant surprises. (and do it before # checking self.closed, since the remote host may have already # closed the connection.) if self._pipe is not None: self._pipe.close() self._pipe = None if not self.active or self.closed: return msgs = self._close_internal() finally: self.lock.release() for m in msgs: if m is not None: self.transport._send_user_message(m)","title":"close"},{"location":"reference/sshChannelEnvironment/#exec_command_1","text":"def exec_command ( self , command ) Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. Parameters: Name Type Description Default command str a shell command to execute. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def exec_command ( self , command ) : \"\"\" Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. :param str command: a shell command to execute. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"exec\" ) m . add_boolean ( True ) m . add_string ( command ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"exec_command"},{"location":"reference/sshChannelEnvironment/#exit_status_ready_1","text":"def exit_status_ready ( self ) Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in recv_exit_status . Note that the server may not return an exit status in some cases (like bad servers). Returns: Type Description None True if recv_exit_status will return immediately, else False . .. versionadded:: 1.7.3 View Source def exit_status_ready ( self ) : \" \"\" Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in `recv_exit_status`. Note that the server may not return an exit status in some cases (like bad servers). :return: ``True`` if `recv_exit_status` will return immediately, else ``False``. .. versionadded:: 1.7.3 \"\" \" return self . closed or self . status_event . is_set ()","title":"exit_status_ready"},{"location":"reference/sshChannelEnvironment/#fileno_1","text":"def fileno ( self ) Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's select module to work. The first time fileno is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) Returns: Type Description None an OS-level file descriptor ( int ) .. warning:: This method causes channel reads to be slightly less efficient. View Source def fileno ( self ) : \" \"\" Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's ``select`` module to work. The first time ``fileno`` is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) :return: an OS-level file descriptor (`int`) .. warning:: This method causes channel reads to be slightly less efficient. \"\" \" self . lock . acquire () try : if self . _pipe is not None : return self . _pipe . fileno () # create the pipe and feed in any existing data self . _pipe = pipe . make_pipe () p1 , p2 = pipe . make_or_pipe ( self . _pipe ) self . in_buffer . set _event ( p1 ) self . in_stderr_buffer . set _event ( p2 ) return self . _pipe . fileno () finally : self . lock . release ()","title":"fileno"},{"location":"reference/sshChannelEnvironment/#get_id_1","text":"def get_id ( self ) Return the int ID # for this channel. The channel ID is unique across a .Transport and usually a small number. It's also the number passed to .ServerInterface.check_channel_request when determining whether to accept a channel request in server mode. View Source def get_id ( self ) : \" \"\" Return the `int` ID # for this channel. The channel ID is unique across a `.Transport` and usually a small number. It's also the number passed to `.ServerInterface.check_channel_request` when determining whether to accept a channel request in server mode. \"\" \" return self . chanid","title":"get_id"},{"location":"reference/sshChannelEnvironment/#get_name_1","text":"def get_name ( self ) Get the name of this channel that was previously set by set_name . View Source def get_name ( self ) : \" \"\" Get the name of this channel that was previously set by `set_name`. \"\" \" return self . _name","title":"get_name"},{"location":"reference/sshChannelEnvironment/#get_pty_1","text":"def get_pty ( self , term = 'vt100' , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with invoke_shell . It isn't necessary (or desirable) to call this method if you're going to execute a single command with exec_command . Parameters: Name Type Description Default term str the terminal type to emulate (for example, 'vt100' ) None width int width (in characters) of the terminal screen None height int height (in characters) of the terminal screen None width_pixels int width (in pixels) of the terminal screen None height_pixels int height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def get_pty ( self , term = \"vt100\" , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 , ) : \" \"\" Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with `invoke_shell`. It isn't necessary (or desirable) to call this method if you're going to execute a single command with `exec_command`. :param str term: the terminal type to emulate (for example, ``'vt100'``) :param int width: width (in characters) of the terminal screen :param int height: height (in characters) of the terminal screen :param int width_pixels: width (in pixels) of the terminal screen :param int height_pixels: height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"pty-req\" ) m . add_boolean ( True ) m . add_string ( term ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) m . add_string ( bytes ()) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"get_pty"},{"location":"reference/sshChannelEnvironment/#get_transport_1","text":"def get_transport ( self ) Return the .Transport associated with this channel. View Source def get_transport(self): \"\"\" Return the `.Transport` associated with this channel. \"\"\" return self.transport","title":"get_transport"},{"location":"reference/sshChannelEnvironment/#getpeername_1","text":"def getpeername ( self ) Return the address of the remote side of this Channel, if possible. This simply wraps .Transport.getpeername , used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call 'getpeername' .) View Source def getpeername ( self ): \"\"\" Return the address of the remote side of this Channel, if possible. This simply wraps `.Transport.getpeername`, used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call ``'getpeername'``.) \"\"\" return self . transport . getpeername ()","title":"getpeername"},{"location":"reference/sshChannelEnvironment/#gettimeout_1","text":"def gettimeout ( self ) Returns the timeout in seconds (as a float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking or settimeout . View Source def gettimeout ( self ) : \" \"\" Returns the timeout in seconds (as a float) associated with socket operations, or ``None`` if no timeout is set. This reflects the last call to `setblocking` or `settimeout`. \"\" \" return self . timeout","title":"gettimeout"},{"location":"reference/sshChannelEnvironment/#invoke_shell_1","text":"def invoke_shell ( self ) Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call get_pty before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_shell ( self ) : \" \"\" Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call `get_pty` before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"shell\" ) m . add_boolean ( True ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"invoke_shell"},{"location":"reference/sshChannelEnvironment/#invoke_subsystem_1","text":"def invoke_subsystem ( self , subsystem ) Request a subsystem on the server (for example, sftp ). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. Parameters: Name Type Description Default subsystem str name of the subsystem being requested. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_subsystem ( self , subsystem ) : \" \"\" Request a subsystem on the server (for example, ``sftp``). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. :param str subsystem: name of the subsystem being requested. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"subsystem\" ) m . add_boolean ( True ) m . add_string ( subsystem ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"invoke_subsystem"},{"location":"reference/sshChannelEnvironment/#makefile_1","text":"def makefile ( self , * params ) Return a file-like object associated with this channel. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. Returns: Type Description None .ChannelFile object which can be used for Python file I/O. View Source def makefile ( self , * params ) : \" \"\" Return a file-like object associated with this channel. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. :return: `.ChannelFile` object which can be used for Python file I/O. \"\" \" return ChannelFile ( * ( [ self ] + list ( params )))","title":"makefile"},{"location":"reference/sshChannelEnvironment/#makefile_stderr_1","text":"def makefile_stderr ( self , * params ) Return a file-like object associated with this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. Returns: Type Description None .ChannelStderrFile object which can be used for Python file I/O. .. versionadded:: 1.1 View Source def makefile_stderr ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. :returns: `.ChannelStderrFile` object which can be used for Python file I/O. .. versionadded:: 1.1 \"\" \" return ChannelStderrFile ( * ( [ self ] + list ( params )))","title":"makefile_stderr"},{"location":"reference/sshChannelEnvironment/#makefile_stdin_1","text":"def makefile_stdin ( self , * params ) Return a file-like object associated with this channel's stdin stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. Returns: Type Description None .ChannelStdinFile object which can be used for Python file I/O. .. versionadded:: 2.6 View Source def makefile_stdin ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stdin stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. :returns: `.ChannelStdinFile` object which can be used for Python file I/O. .. versionadded:: 2.6 \"\" \" return ChannelStdinFile ( * ( [ self ] + list ( params )))","title":"makefile_stdin"},{"location":"reference/sshChannelEnvironment/#recv_1","text":"def recv ( self , nbytes ) Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data, as a bytes . Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . View Source def recv ( self , nbytes ) : \" \"\" Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data, as a `bytes`. :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. \"\" \" try : out = self . in_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out","title":"recv"},{"location":"reference/sshChannelEnvironment/#recv_exit_status_1","text":"def recv_exit_status ( self ) Return the exit status from the process on the server. This is mostly useful for retrieving the results of an exec_command . If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current .Transport or session's window_size (e.g. that set by the default_window_size kwarg for .Transport.__init__ ) will cause .recv_exit_status to hang indefinitely if it is called prior to a sufficiently large .Channel.recv (or if there are no threads calling .Channel.recv in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. Returns: Type Description None the exit code (as an int ) of the process on the server. .. versionadded:: 1.2 View Source def recv_exit_status ( self ) : \" \"\" Return the exit status from the process on the server. This is mostly useful for retrieving the results of an `exec_command`. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current `.Transport` or session's ``window_size`` (e.g. that set by the ``default_window_size`` kwarg for `.Transport.__init__`) will cause `.recv_exit_status` to hang indefinitely if it is called prior to a sufficiently large `.Channel.recv` (or if there are no threads calling `.Channel.recv` in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. :return: the exit code (as an `int`) of the process on the server. .. versionadded:: 1.2 \"\" \" self . status_event . wait () assert self . status_event . is_set () return self . exit_status","title":"recv_exit_status"},{"location":"reference/sshChannelEnvironment/#recv_ready_1","text":"def recv_ready ( self ) Returns true if data is buffered and ready to be read from this channel. A False result does not mean that the channel has closed; it means you may need to wait before more data arrives. Returns: Type Description None True if a recv call on this channel would immediately return at least one byte; False otherwise. View Source def recv_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel. A ``False`` result does not mean that the channel has closed; it means you may need to wait before more data arrives. :return: ``True`` if a `recv` call on this channel would immediately return at least one byte; ``False`` otherwise. \"\" \" return self . in_buffer . read_ready ()","title":"recv_ready"},{"location":"reference/sshChannelEnvironment/#recv_stderr_1","text":"def recv_stderr ( self , nbytes ) Receive data from the channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data as a bytes Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . .. versionadded:: 1.1 View Source def recv_stderr ( self , nbytes ) : \" \"\" Receive data from the channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data as a `bytes` :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" try : out = self . in_stderr_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out","title":"recv_stderr"},{"location":"reference/sshChannelEnvironment/#recv_stderr_ready_1","text":"def recv_stderr_ready ( self ) Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. Returns: Type Description None True if a recv_stderr call on this channel would immediately return at least one byte; False otherwise. .. versionadded:: 1.1 View Source def recv_stderr_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. :return: ``True`` if a `recv_stderr` call on this channel would immediately return at least one byte; ``False`` otherwise. .. versionadded:: 1.1 \"\" \" return self . in_stderr_buffer . read_ready ()","title":"recv_stderr_ready"},{"location":"reference/sshChannelEnvironment/#request_forward_agent_1","text":"def request_forward_agent ( self , handler ) Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! Parameters: Name Type Description Default handler None a required callable handler to use for incoming SSH Agent connections None Returns: Type Description None True if we are ok, else False (at that time we always return ok) Raises: Type Description None SSHException in case of channel problem. View Source @open_only def request_forward_agent ( self , handler ) : \"\"\" Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! :param handler: a required callable handler to use for incoming SSH Agent connections :return: True if we are ok, else False (at that time we always return ok) :raises: SSHException in case of channel problem. \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"auth-agent-req@openssh.com\" ) m . add_boolean ( False ) self . transport . _send_user_message ( m ) self . transport . _set_forward_agent_handler ( handler ) return True","title":"request_forward_agent"},{"location":"reference/sshChannelEnvironment/#request_x11_1","text":"def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None ) Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc: 4254 :: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake , random cookie , and that the cookie be checked and replaced by the real cookie when a connection request is received . If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using .Transport.accept . The handler's calling signature is:: handler ( channel : Channel , ( address : str , port : int )) Parameters: Name Type Description Default screen_number int the x11 screen number (0, 10, etc.) None auth_protocol str the name of the X11 authentication method used; if none is given, \"MIT-MAGIC-COOKIE-1\" is used None auth_cookie str hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated None single_connection bool if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) None handler None an optional callable handler to use for incoming X11 connections None Returns: Type Description None the auth_cookie used View Source @ open_only def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None , ): \"\"\" Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc:`4254`:: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake, random cookie, and that the cookie be checked and replaced by the real cookie when a connection request is received. If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using `.Transport.accept`. The handler's calling signature is:: handler(channel: Channel, (address: str, port: int)) :param int screen_number: the x11 screen number (0, 10, etc.) :param str auth_protocol: the name of the X11 authentication method used; if none is given, ``\" MIT - MAGIC - COOKIE - 1 \"`` is used :param str auth_cookie: hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated :param bool single_connection: if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) :param handler: an optional callable handler to use for incoming X11 connections :return: the auth_cookie used \"\"\" if auth_protocol is None : auth_protocol = \"MIT-MAGIC-COOKIE-1\" if auth_cookie is None : auth_cookie = binascii . hexlify ( os . urandom ( 16 )) m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"x11-req\" ) m . add_boolean ( True ) m . add_boolean ( single_connection ) m . add_string ( auth_protocol ) m . add_string ( auth_cookie ) m . add_int ( screen_number ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () self . transport . _set_x11_handler ( handler ) return auth_cookie","title":"request_x11"},{"location":"reference/sshChannelEnvironment/#resize_pty_1","text":"def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous get_pty call. Parameters: Name Type Description Default width int new width (in characters) of the terminal screen None height int new height (in characters) of the terminal screen None width_pixels int new width (in pixels) of the terminal screen None height_pixels int new height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) : \" \"\" Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous `get_pty` call. :param int width: new width (in characters) of the terminal screen :param int height: new height (in characters) of the terminal screen :param int width_pixels: new width (in pixels) of the terminal screen :param int height_pixels: new height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"window-change\" ) m . add_boolean ( False ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) self . transport . _send_user_message ( m )","title":"resize_pty"},{"location":"reference/sshChannelEnvironment/#send_1","text":"def send ( self , s ) Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send None Returns: Type Description None number of bytes actually sent, as an int Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . View Source def send ( self , s ) : \" \"\" Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send :return: number of bytes actually sent, as an `int` :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_DATA ) m . add_int ( self . remote_chanid ) return self . _send ( s , m )","title":"send"},{"location":"reference/sshChannelEnvironment/#send_exit_status_1","text":"def send_exit_status ( self , status ) Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. Parameters: Name Type Description Default status int the exit code of the process .. versionadded:: 1.2 None View Source def send_exit_status(self, status): \"\"\" Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. :param int status: the exit code of the process .. versionadded:: 1.2 \"\"\" # in many cases, the channel will not still be open here. # that's fine. m = Message() m.add_byte(cMSG_CHANNEL_REQUEST) m.add_int(self.remote_chanid) m.add_string(\"exit-status\") m.add_boolean(False) m.add_int(status) self.transport._send_user_message(m)","title":"send_exit_status"},{"location":"reference/sshChannelEnvironment/#send_ready_1","text":"def send_ready ( self ) Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a send call will succeed immediately and return the number of bytes actually written. Returns: Type Description None True if a send call on this channel would immediately succeed or fail View Source def send_ready ( self ) : \" \"\" Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a `send` call will succeed immediately and return the number of bytes actually written. :return: ``True`` if a `send` call on this channel would immediately succeed or fail \"\" \" self . lock . acquire () try : if self . closed or self . eof_sent : return True return self . out_window_size > 0 finally : self . lock . release ()","title":"send_ready"},{"location":"reference/sshChannelEnvironment/#send_stderr_1","text":"def send_stderr ( self , s ) Send data to the channel on the \"stderr\" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send. None Returns: Type Description None number of bytes actually sent, as an int . Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . .. versionadded:: 1.1 View Source def send_stderr ( self , s ) : \" \"\" Send data to the channel on the \" stderr \" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send. :return: number of bytes actually sent, as an `int`. :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_EXTENDED_DATA ) m . add_int ( self . remote_chanid ) m . add_int ( 1 ) return self . _send ( s , m )","title":"send_stderr"},{"location":"reference/sshChannelEnvironment/#sendall_1","text":"def sendall ( self , s ) Send data to the channel, without allowing partial results. Unlike send , this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. View Source def sendall ( self , s ) : \" \"\" Send data to the channel, without allowing partial results. Unlike `send`, this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. \"\" \" while s : sent = self . send ( s ) s = s [ sent : ] return None","title":"sendall"},{"location":"reference/sshChannelEnvironment/#sendall_stderr_1","text":"def sendall_stderr ( self , s ) Send data to the channel's \"stderr\" stream, without allowing partial results. Unlike send_stderr , this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send to the client as \"stderr\" output. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. versionadded:: 1.1 View Source def sendall_stderr ( self , s ) : \" \"\" Send data to the channel's \" stderr \" stream, without allowing partial results. Unlike `send_stderr`, this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send to the client as \" stderr \" output. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. versionadded:: 1.1 \"\" \" while s : sent = self . send_stderr ( s ) s = s [ sent : ] return None","title":"sendall_stderr"},{"location":"reference/sshChannelEnvironment/#set_combine_stderr_1","text":"def set_combine_stderr ( self , combine ) Set whether stderr should be combined into stdout on this channel. The default is False , but in some cases it may be convenient to have both streams combined. If this is False , and exec_command is called (or invoke_shell with no pty), output to stderr will not show up through the recv and recv_ready calls. You will have to use recv_stderr and recv_stderr_ready to get stderr output. If this is True , data will never show up via recv_stderr or recv_stderr_ready . Parameters: Name Type Description Default combine bool True if stderr output should be combined into stdout on this channel. None Returns: Type Description None the previous setting (a bool ). .. versionadded:: 1.1 View Source def set _combine_stderr ( self , combine ) : \" \"\" Set whether stderr should be combined into stdout on this channel. The default is ``False``, but in some cases it may be convenient to have both streams combined. If this is ``False``, and `exec_command` is called (or ``invoke_shell`` with no pty), output to stderr will not show up through the `recv` and `recv_ready` calls. You will have to use `recv_stderr` and `recv_stderr_ready` to get stderr output. If this is ``True``, data will never show up via `recv_stderr` or `recv_stderr_ready`. :param bool combine: ``True`` if stderr output should be combined into stdout on this channel. :return: the previous setting (a `bool`). .. versionadded:: 1.1 \"\" \" data = bytes () self . lock . acquire () try : old = self . combine_stderr self . combine_stderr = combine if combine and not old : # copy old stderr buffer into primary buffer data = self . in_stderr_buffer . empty () finally : self . lock . release () if len ( data ) > 0 : self . _feed ( data ) return old","title":"set_combine_stderr"},{"location":"reference/sshChannelEnvironment/#set_environment_variable_1","text":"def set_environment_variable ( self , name , value ) Set the value of an environment variable. .. warning:: The server may reject this request depending on its AcceptEnv setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! Parameters: Name Type Description Default name str name of the environment variable None value str value of the environment variable None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def set _environment_variable ( self , name , value ) : \" \"\" Set the value of an environment variable. .. warning:: The server may reject this request depending on its ``AcceptEnv`` setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! :param str name: name of the environment variable :param str value: value of the environment variable :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"env\" ) m . add_boolean ( False ) m . add_string ( name ) m . add_string ( value ) self . transport . _send_user_message ( m )","title":"set_environment_variable"},{"location":"reference/sshChannelEnvironment/#set_name_1","text":"def set_name ( self , name ) Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the get_name method. Parameters: Name Type Description Default name str new channel name None View Source def set _name ( self , name ) : \" \"\" Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the `get_name` method. :param str name: new channel name \"\" \" self . _name = name","title":"set_name"},{"location":"reference/sshChannelEnvironment/#setblocking_1","text":"def setblocking ( self , blocking ) Set blocking or non-blocking mode of the channel: if blocking is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a recv call doesn't find any data, or if a send call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \"immediate data\" for recv , so if the channel is closed in the read direction, it will never block. chan.setblocking(0) is equivalent to chan.settimeout(0) ; chan.setblocking(1) is equivalent to chan.settimeout(None) . Parameters: Name Type Description Default blocking int 0 to set non-blocking mode; non-0 to set blocking mode. None View Source def set blocking ( self , blocking ) : \" \"\" Set blocking or non-blocking mode of the channel: if ``blocking`` is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a `recv` call doesn't find any data, or if a `send` call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \" immediate data \" for `recv`, so if the channel is closed in the read direction, it will never block. ``chan.setblocking(0)`` is equivalent to ``chan.settimeout(0)``; ``chan.setblocking(1)`` is equivalent to ``chan.settimeout(None)``. :param int blocking: 0 to set non-blocking mode; non-0 to set blocking mode. \"\" \" if blocking : self . set timeout ( None ) else : self . set timeout ( 0.0 )","title":"setblocking"},{"location":"reference/sshChannelEnvironment/#settimeout_1","text":"def settimeout ( self , timeout ) Set a timeout on blocking read/write operations. The timeout argument can be a nonnegative float expressing seconds, or None . If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. chan.settimeout(0.0) is equivalent to chan.setblocking(0) ; chan.settimeout(None) is equivalent to chan.setblocking(1) . Parameters: Name Type Description Default timeout float seconds to wait for a pending read/write operation before raising socket.timeout , or None for no timeout. None View Source def set timeout ( self , timeout ) : \" \"\" Set a timeout on blocking read/write operations. The ``timeout`` argument can be a nonnegative float expressing seconds, or ``None``. If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of ``None`` disables timeouts on socket operations. ``chan.settimeout(0.0)`` is equivalent to ``chan.setblocking(0)``; ``chan.settimeout(None)`` is equivalent to ``chan.setblocking(1)``. :param float timeout: seconds to wait for a pending read/write operation before raising ``socket.timeout``, or ``None`` for no timeout. \"\" \" self . timeout = timeout","title":"settimeout"},{"location":"reference/sshChannelEnvironment/#shutdown_1","text":"def shutdown ( self , how ) Shut down one or both halves of the connection. If how is 0, further receives are disallowed. If how is 1, further sends are disallowed. If how is 2, further sends and receives are disallowed. This closes the stream in one or both directions. Parameters: Name Type Description Default how int 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). None View Source def shutdown ( self , how ) : \" \"\" Shut down one or both halves of the connection. If ``how`` is 0, further receives are disallowed. If ``how`` is 1, further sends are disallowed. If ``how`` is 2, further sends and receives are disallowed. This closes the stream in one or both directions. :param int how: 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). \"\" \" if ( how == 0 ) or ( how == 2 ) : # feign \"read\" shutdown self . eof_received = 1 if ( how == 1 ) or ( how == 2 ) : self . lock . acquire () try : m = self . _send_eof () finally : self . lock . release () if m is not None : self . transport . _send_user_message ( m )","title":"shutdown"},{"location":"reference/sshChannelEnvironment/#shutdown_read_1","text":"def shutdown_read ( self ) Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to shutdown(0) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_read ( self ): \"\"\" Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(0)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 0 )","title":"shutdown_read"},{"location":"reference/sshChannelEnvironment/#shutdown_write_1","text":"def shutdown_write ( self ) Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to shutdown(1) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_write ( self ): \"\"\" Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(1)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 1 )","title":"shutdown_write"},{"location":"reference/sshChannelEnvironment/#update_environment_1","text":"def update_environment ( self , environment ) Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in set_environment_variable for details. Parameters: Name Type Description Default environment dict a dictionary containing the name and respective values to set None Raises: Type Description None .SSHException -- if any of the environment variables was rejected by the server or the channel was closed View Source @open_only def update_environment ( self , environment ) : \" \"\" Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in `set_environment_variable` for details. :param dict environment: a dictionary containing the name and respective values to set :raises: `.SSHException` -- if any of the environment variables was rejected by the server or the channel was closed \"\" \" for name , value in environment . items () : try : self . set _environment_variable ( name , value ) except SSHException as e : err = 'Failed to set environment variable \"{}\".' raise SSHException ( err . format ( name ), e )","title":"update_environment"},{"location":"reference/sshChannelEnvironment/#sshenvironment","text":"class sshEnvironment ( parentInst : Any , ** kwargs ) Uses the sshChannelWrapper and is used by the EnvironmentControls. This handles the state of the ssh Environment it is associated with. Such as the prompt/current user/console and so on.","title":"sshEnvironment"},{"location":"reference/sshChannelEnvironment/#ancestors-in-mro_2","text":"sshChannelEnvironment.sshChannelWrapper paramiko.channel.Channel paramiko.util.ClosingContextManager","title":"Ancestors (in MRO)"},{"location":"reference/sshChannelEnvironment/#descendants_1","text":"sshChannelEnvironment.EnvironmentControls","title":"Descendants"},{"location":"reference/sshChannelEnvironment/#class-variables_1","text":"BASH CSH MYSQL NOSH ORACLE SH ZSH prompt","title":"Class variables"},{"location":"reference/sshChannelEnvironment/#instance-variables_2","text":"console consoleStack isMain numEscalations numUsers userCount userList whoami","title":"Instance variables"},{"location":"reference/sshChannelEnvironment/#methods_2","text":"","title":"Methods"},{"location":"reference/sshChannelEnvironment/#close_2","text":"def close ( self ) Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their .Transport is closed or when they are garbage collected. View Source def close(self): \"\"\" Close the channel. All future read/write operations on the channel will fail. The remote end will receive no more data (after queued data is flushed). Channels are automatically closed when their `.Transport` is closed or when they are garbage collected. \"\"\" self.lock.acquire() try: # only close the pipe when the user explicitly closes the channel. # otherwise they will get unpleasant surprises. (and do it before # checking self.closed, since the remote host may have already # closed the connection.) if self._pipe is not None: self._pipe.close() self._pipe = None if not self.active or self.closed: return msgs = self._close_internal() finally: self.lock.release() for m in msgs: if m is not None: self.transport._send_user_message(m)","title":"close"},{"location":"reference/sshChannelEnvironment/#exec_command_2","text":"def exec_command ( self , command ) Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. Parameters: Name Type Description Default command str a shell command to execute. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def exec_command ( self , command ) : \"\"\" Execute a command on the server. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the command being executed. When the command finishes executing, the channel will be closed and can't be reused. You must open a new channel if you wish to execute another command. :param str command: a shell command to execute. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"exec\" ) m . add_boolean ( True ) m . add_string ( command ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"exec_command"},{"location":"reference/sshChannelEnvironment/#exit_status_ready_2","text":"def exit_status_ready ( self ) Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in recv_exit_status . Note that the server may not return an exit status in some cases (like bad servers). Returns: Type Description None True if recv_exit_status will return immediately, else False . .. versionadded:: 1.7.3 View Source def exit_status_ready ( self ) : \" \"\" Return true if the remote process has exited and returned an exit status. You may use this to poll the process status if you don't want to block in `recv_exit_status`. Note that the server may not return an exit status in some cases (like bad servers). :return: ``True`` if `recv_exit_status` will return immediately, else ``False``. .. versionadded:: 1.7.3 \"\" \" return self . closed or self . status_event . is_set ()","title":"exit_status_ready"},{"location":"reference/sshChannelEnvironment/#fileno_2","text":"def fileno ( self ) Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's select module to work. The first time fileno is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) Returns: Type Description None an OS-level file descriptor ( int ) .. warning:: This method causes channel reads to be slightly less efficient. View Source def fileno ( self ) : \" \"\" Returns an OS-level file descriptor which can be used for polling, but but not for reading or writing. This is primarily to allow Python's ``select`` module to work. The first time ``fileno`` is called on a channel, a pipe is created to simulate real OS-level file descriptor (FD) behavior. Because of this, two OS-level FDs are created, which will use up FDs faster than normal. (You won't notice this effect unless you have hundreds of channels open at the same time.) :return: an OS-level file descriptor (`int`) .. warning:: This method causes channel reads to be slightly less efficient. \"\" \" self . lock . acquire () try : if self . _pipe is not None : return self . _pipe . fileno () # create the pipe and feed in any existing data self . _pipe = pipe . make_pipe () p1 , p2 = pipe . make_or_pipe ( self . _pipe ) self . in_buffer . set _event ( p1 ) self . in_stderr_buffer . set _event ( p2 ) return self . _pipe . fileno () finally : self . lock . release ()","title":"fileno"},{"location":"reference/sshChannelEnvironment/#getconsolelist_1","text":"def getConsoleList ( self ) -> list LIke 'getUserList' but returns a list of the console escalations in order that they happened. View Source def getConsoleList ( self ) -> list : \"\"\" LIke ' getUserList ' but returns a list of the console escalations in order that they happened. \"\"\" def _filterConsoles ( item ) : return self . __CONSOLE_ESCALATION__ == item [ 0 ] def _consoleGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output # itemList = list ( filter ( _filterConsoles , self . consoleStack )) return _consoleGenerator ( filter ( _filterConsoles , self . consoleStack ))","title":"getConsoleList"},{"location":"reference/sshChannelEnvironment/#getcurrentconsole_1","text":"def getCurrentConsole ( self ) -> str Like 'getCurrentUser' but gets what the current console type is. View Source def getCurrentConsole ( self ) -> str : \"\"\" Like 'getCurrentUser' but gets what the current console type is. \"\"\" consoles = self . getConsoleList () if consoles : return consoles [ - 1 ] return \"BASH\"","title":"getCurrentConsole"},{"location":"reference/sshChannelEnvironment/#getcurrentuser_1","text":"def getCurrentUser ( self ) -> str Returns a string that is the name of the current user authenticated on this environment. View Source def getCurrentUser ( self ) -> str : \"\"\" Returns a string that is the name of the current user authenticated on this environment. \"\"\" currentUsers = self . getUserList () if currentUsers : return currentUsers [ - 1 ] return ''","title":"getCurrentUser"},{"location":"reference/sshChannelEnvironment/#getpreviousescalation_1","text":"def getPreviousEscalation ( self ) -> tuple View Source def getPreviousEscalation ( self ) -> tuple : return self . peak ()","title":"getPreviousEscalation"},{"location":"reference/sshChannelEnvironment/#getpreviousescalationtype_1","text":"def getPreviousEscalationType ( self ) -> int View Source def getPreviousEscalationType ( self ) -> int : return self . peak ()[ 0 ]","title":"getPreviousEscalationType"},{"location":"reference/sshChannelEnvironment/#getuserlist_1","text":"def getUserList ( self ) -> list This returns a list of users that are currently logged into this environment in order of there login. View Source def getUserList ( self ) -> list : \"\"\" This returns a list of users that are currently logged into this environment in order of there login. \"\"\" def _filterUsers ( item ) : return self . __USER_ESCALATION__ == item [ 0 ] def _userGenerator ( itemListToGen ) : output = [] for item in itemListToGen : output . append ( item [ 1 ]) return output if not self . consoleStack : return [] # itemList = list ( filter ( _filterUsers , self . consoleStack )) return _userGenerator ( filter ( _filterUsers , self . consoleStack ))","title":"getUserList"},{"location":"reference/sshChannelEnvironment/#get_id_2","text":"def get_id ( self ) Return the int ID # for this channel. The channel ID is unique across a .Transport and usually a small number. It's also the number passed to .ServerInterface.check_channel_request when determining whether to accept a channel request in server mode. View Source def get_id ( self ) : \" \"\" Return the `int` ID # for this channel. The channel ID is unique across a `.Transport` and usually a small number. It's also the number passed to `.ServerInterface.check_channel_request` when determining whether to accept a channel request in server mode. \"\" \" return self . chanid","title":"get_id"},{"location":"reference/sshChannelEnvironment/#get_name_2","text":"def get_name ( self ) Get the name of this channel that was previously set by set_name . View Source def get_name ( self ) : \" \"\" Get the name of this channel that was previously set by `set_name`. \"\" \" return self . _name","title":"get_name"},{"location":"reference/sshChannelEnvironment/#get_pty_2","text":"def get_pty ( self , term = 'vt100' , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with invoke_shell . It isn't necessary (or desirable) to call this method if you're going to execute a single command with exec_command . Parameters: Name Type Description Default term str the terminal type to emulate (for example, 'vt100' ) None width int width (in characters) of the terminal screen None height int height (in characters) of the terminal screen None width_pixels int width (in pixels) of the terminal screen None height_pixels int height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def get_pty ( self , term = \"vt100\" , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 , ) : \" \"\" Request a pseudo-terminal from the server. This is usually used right after creating a client channel, to ask the server to provide some basic terminal semantics for a shell invoked with `invoke_shell`. It isn't necessary (or desirable) to call this method if you're going to execute a single command with `exec_command`. :param str term: the terminal type to emulate (for example, ``'vt100'``) :param int width: width (in characters) of the terminal screen :param int height: height (in characters) of the terminal screen :param int width_pixels: width (in pixels) of the terminal screen :param int height_pixels: height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"pty-req\" ) m . add_boolean ( True ) m . add_string ( term ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) m . add_string ( bytes ()) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"get_pty"},{"location":"reference/sshChannelEnvironment/#get_transport_2","text":"def get_transport ( self ) Return the .Transport associated with this channel. View Source def get_transport(self): \"\"\" Return the `.Transport` associated with this channel. \"\"\" return self.transport","title":"get_transport"},{"location":"reference/sshChannelEnvironment/#getpeername_2","text":"def getpeername ( self ) Return the address of the remote side of this Channel, if possible. This simply wraps .Transport.getpeername , used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call 'getpeername' .) View Source def getpeername ( self ): \"\"\" Return the address of the remote side of this Channel, if possible. This simply wraps `.Transport.getpeername`, used to provide enough of a socket-like interface to allow asyncore to work. (asyncore likes to call ``'getpeername'``.) \"\"\" return self . transport . getpeername ()","title":"getpeername"},{"location":"reference/sshChannelEnvironment/#gettimeout_2","text":"def gettimeout ( self ) Returns the timeout in seconds (as a float) associated with socket operations, or None if no timeout is set. This reflects the last call to setblocking or settimeout . View Source def gettimeout ( self ) : \" \"\" Returns the timeout in seconds (as a float) associated with socket operations, or ``None`` if no timeout is set. This reflects the last call to `setblocking` or `settimeout`. \"\" \" return self . timeout","title":"gettimeout"},{"location":"reference/sshChannelEnvironment/#invoke_shell_2","text":"def invoke_shell ( self ) Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call get_pty before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_shell ( self ) : \" \"\" Request an interactive shell session on this channel. If the server allows it, the channel will then be directly connected to the stdin, stdout, and stderr of the shell. Normally you would call `get_pty` before this, in which case the shell will operate through the pty, and the channel will be connected to the stdin and stdout of the pty. When the shell exits, the channel will be closed and can't be reused. You must open a new channel if you wish to open another shell. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"shell\" ) m . add_boolean ( True ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"invoke_shell"},{"location":"reference/sshChannelEnvironment/#invoke_subsystem_2","text":"def invoke_subsystem ( self , subsystem ) Request a subsystem on the server (for example, sftp ). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. Parameters: Name Type Description Default subsystem str name of the subsystem being requested. None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def invoke_subsystem ( self , subsystem ) : \" \"\" Request a subsystem on the server (for example, ``sftp``). If the server allows it, the channel will then be directly connected to the requested subsystem. When the subsystem finishes, the channel will be closed and can't be reused. :param str subsystem: name of the subsystem being requested. :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"subsystem\" ) m . add_boolean ( True ) m . add_string ( subsystem ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event ()","title":"invoke_subsystem"},{"location":"reference/sshChannelEnvironment/#makefile_2","text":"def makefile ( self , * params ) Return a file-like object associated with this channel. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. Returns: Type Description None .ChannelFile object which can be used for Python file I/O. View Source def makefile ( self , * params ) : \" \"\" Return a file-like object associated with this channel. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. :return: `.ChannelFile` object which can be used for Python file I/O. \"\" \" return ChannelFile ( * ( [ self ] + list ( params )))","title":"makefile"},{"location":"reference/sshChannelEnvironment/#makefile_stderr_2","text":"def makefile_stderr ( self , * params ) Return a file-like object associated with this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. Returns: Type Description None .ChannelStderrFile object which can be used for Python file I/O. .. versionadded:: 1.1 View Source def makefile_stderr ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for reading. For a server, it only makes sense to open this file for writing. :returns: `.ChannelStderrFile` object which can be used for Python file I/O. .. versionadded:: 1.1 \"\" \" return ChannelStderrFile ( * ( [ self ] + list ( params )))","title":"makefile_stderr"},{"location":"reference/sshChannelEnvironment/#makefile_stdin_2","text":"def makefile_stdin ( self , * params ) Return a file-like object associated with this channel's stdin stream. The optional mode and bufsize arguments are interpreted the same way as by the built-in file() function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. Returns: Type Description None .ChannelStdinFile object which can be used for Python file I/O. .. versionadded:: 2.6 View Source def makefile_stdin ( self , * params ) : \" \"\" Return a file-like object associated with this channel's stdin stream. The optional ``mode`` and ``bufsize`` arguments are interpreted the same way as by the built-in ``file()`` function in Python. For a client, it only makes sense to open this file for writing. For a server, it only makes sense to open this file for reading. :returns: `.ChannelStdinFile` object which can be used for Python file I/O. .. versionadded:: 2.6 \"\" \" return ChannelStdinFile ( * ( [ self ] + list ( params )))","title":"makefile_stdin"},{"location":"reference/sshChannelEnvironment/#peak_1","text":"def peak ( self ) -> tuple Just like a peak it simply returns the last console change without removing it. View Source def peak ( self ) -> tuple : \"\"\" Just like a peak it simply returns the last console change without removing it. \"\"\" if self . consoleStack : return self . consoleStack [ - 1 ]","title":"peak"},{"location":"reference/sshChannelEnvironment/#peer_1","text":"def peer ( self , num ) -> tuple Just like a peer for a stack this allows one to look at an particular index of the stack. View Source def peer ( self , num ) -> tuple : \"\"\" Just like a peer for a stack this allows one to look at an particular index of the stack. \"\"\" try : return self . consoleStack [ num ] except : return ()","title":"peer"},{"location":"reference/sshChannelEnvironment/#printstack_1","text":"def printStack ( self ) -> str This returns a string. It is a nicely formatted list of the history of console changes on the Environment View Source def printStack ( self ) -> str : \"\"\" This returns a string. It is a nicely formatted list of the history of console changes on the Environment\"\"\" output = \"\" for item in self . consoleStack : if not item or len ( item ) < 4 : continue typeStr = self . __INVERTED_TYPE_DICT__ . get ( item [ 0 ]) output += f ' { typeStr }: { item [ 1 ]} Using Command : { item [ 2 ]} AdditionalInput : { item [ 3 ]} \\ n ' return output","title":"printStack"},{"location":"reference/sshChannelEnvironment/#pull_1","text":"def pull ( self ) -> tuple This pulls from the consoleStack removing the item and returning it. Returns: Type Description None (tuple) The escalation information formated as a tuple View Source def pull ( self ) -> tuple : \"\"\" This pulls from the consoleStack removing the item and returning it. :return: (tuple) The escalation information formated as a tuple \"\"\" if len ( self . consoleStack ) >= 1 : return self . consoleStack . pop () return tuple ()","title":"pull"},{"location":"reference/sshChannelEnvironment/#push_1","text":"def push ( self , item : Union [ tuple , str ], name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool Append a new change to the console. This is to record a change to the environment. Parameters: Name Type Description Default item None (either tuple or str) None name None (str) None escalationType None (int) This should either be ( USER_ESCALATION ) 1, ( CONSOLE_ESCALATION ) 2, ( ENVIRONMENT_CHANGE ) 3 or ( UNKNOWN ) 4. None additionalInput None (str) Optional additional information for example a password. None Returns: Type Description None (bool) View Source def push ( self , item : Union [ tuple, str ] , name : Optional [ str ] = None , escalationType : Optional [ int ] = None , additionalInput : Optional [ str ] = None ) -> bool : \"\"\" Append a new change to the console. This is to record a change to the environment. :param item: (either tuple or str) :param name: (str) :param escalationType: (int) This should either be (__USER_ESCALATION__) 1, (__CONSOLE_ESCALATION__) 2, (__ENVIRONMENT_CHANGE__) 3 or (__UNKNOWN__) 4. :param additionalInput: (str) Optional additional information for example a password. :return: (bool) \"\"\" def _parsePushInput ( _item , _name , _escalationType , _additionalInput ) : if type ( _item ) is not tuple and ( type ( _escalationType ) is int or type ( _escalationType ) is str ) : if type ( _escalationType ) is str : _escalationType = self . __TYPE_DICT__ . get ( _escalationType ) or 4 elif abs ( _escalationType ) > 4 or _escalationType <= 0 : _escalationType = 4 return _escalationType , _name , _item , _additionalInput if type ( _item ) is tuple and len ( _item ) == 4 and type ( _item [ 0 ] is int ) : return _item if type ( _item ) is str or type ( _item ) is dict and _escalationType is None : return self . __USER_ESCALATION__ , _name , _item , _additionalInput return False command = _parsePushInput ( item , name , escalationType , additionalInput ) if command is False : return False self . consoleStack . append ( command ) return True","title":"push"},{"location":"reference/sshChannelEnvironment/#recv_2","text":"def recv ( self , nbytes ) Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data, as a bytes . Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . View Source def recv ( self , nbytes ) : \" \"\" Receive data from the channel. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data, as a `bytes`. :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. \"\" \" try : out = self . in_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out","title":"recv"},{"location":"reference/sshChannelEnvironment/#recv_exit_status_2","text":"def recv_exit_status ( self ) Return the exit status from the process on the server. This is mostly useful for retrieving the results of an exec_command . If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current .Transport or session's window_size (e.g. that set by the default_window_size kwarg for .Transport.__init__ ) will cause .recv_exit_status to hang indefinitely if it is called prior to a sufficiently large .Channel.recv (or if there are no threads calling .Channel.recv in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. Returns: Type Description None the exit code (as an int ) of the process on the server. .. versionadded:: 1.2 View Source def recv_exit_status ( self ) : \" \"\" Return the exit status from the process on the server. This is mostly useful for retrieving the results of an `exec_command`. If the command hasn't finished yet, this method will wait until it does, or until the channel is closed. If no exit status is provided by the server, -1 is returned. .. warning:: In some situations, receiving remote output larger than the current `.Transport` or session's ``window_size`` (e.g. that set by the ``default_window_size`` kwarg for `.Transport.__init__`) will cause `.recv_exit_status` to hang indefinitely if it is called prior to a sufficiently large `.Channel.recv` (or if there are no threads calling `.Channel.recv` in the background). In these cases, ensuring that `.recv_exit_status` is called *after* `.Channel.recv` (or, again, using threads) can avoid the hang. :return: the exit code (as an `int`) of the process on the server. .. versionadded:: 1.2 \"\" \" self . status_event . wait () assert self . status_event . is_set () return self . exit_status","title":"recv_exit_status"},{"location":"reference/sshChannelEnvironment/#recv_ready_2","text":"def recv_ready ( self ) Returns true if data is buffered and ready to be read from this channel. A False result does not mean that the channel has closed; it means you may need to wait before more data arrives. Returns: Type Description None True if a recv call on this channel would immediately return at least one byte; False otherwise. View Source def recv_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel. A ``False`` result does not mean that the channel has closed; it means you may need to wait before more data arrives. :return: ``True`` if a `recv` call on this channel would immediately return at least one byte; ``False`` otherwise. \"\" \" return self . in_buffer . read_ready ()","title":"recv_ready"},{"location":"reference/sshChannelEnvironment/#recv_stderr_2","text":"def recv_stderr ( self , nbytes ) Receive data from the channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by nbytes . If a string of length zero is returned, the channel stream has closed. Parameters: Name Type Description Default nbytes int maximum number of bytes to read. None Returns: Type Description None received data as a bytes Raises: Type Description socket.timeout if no data is ready before the timeout set by settimeout . .. versionadded:: 1.1 View Source def recv_stderr ( self , nbytes ) : \" \"\" Receive data from the channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. The return value is a string representing the data received. The maximum amount of data to be received at once is specified by ``nbytes``. If a string of length zero is returned, the channel stream has closed. :param int nbytes: maximum number of bytes to read. :return: received data as a `bytes` :raises socket.timeout: if no data is ready before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" try : out = self . in_stderr_buffer . read ( nbytes , self . timeout ) except PipeTimeout : raise socket . timeout () ack = self . _check_add_window ( len ( out )) # no need to hold the channel lock when sending this if ack > 0 : m = Message () m . add_byte ( cMSG_CHANNEL_WINDOW_ADJUST ) m . add_int ( self . remote_chanid ) m . add_int ( ack ) self . transport . _send_user_message ( m ) return out","title":"recv_stderr"},{"location":"reference/sshChannelEnvironment/#recv_stderr_ready_2","text":"def recv_stderr_ready ( self ) Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using exec_command or invoke_shell without a pty will ever have data on the stderr stream. Returns: Type Description None True if a recv_stderr call on this channel would immediately return at least one byte; False otherwise. .. versionadded:: 1.1 View Source def recv_stderr_ready ( self ) : \" \"\" Returns true if data is buffered and ready to be read from this channel's stderr stream. Only channels using `exec_command` or `invoke_shell` without a pty will ever have data on the stderr stream. :return: ``True`` if a `recv_stderr` call on this channel would immediately return at least one byte; ``False`` otherwise. .. versionadded:: 1.1 \"\" \" return self . in_stderr_buffer . read_ready ()","title":"recv_stderr_ready"},{"location":"reference/sshChannelEnvironment/#request_forward_agent_2","text":"def request_forward_agent ( self , handler ) Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! Parameters: Name Type Description Default handler None a required callable handler to use for incoming SSH Agent connections None Returns: Type Description None True if we are ok, else False (at that time we always return ok) Raises: Type Description None SSHException in case of channel problem. View Source @open_only def request_forward_agent ( self , handler ) : \"\"\" Request for a forward SSH Agent on this channel. This is only valid for an ssh-agent from OpenSSH !!! :param handler: a required callable handler to use for incoming SSH Agent connections :return: True if we are ok, else False (at that time we always return ok) :raises: SSHException in case of channel problem. \"\"\" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"auth-agent-req@openssh.com\" ) m . add_boolean ( False ) self . transport . _send_user_message ( m ) self . transport . _set_forward_agent_handler ( handler ) return True","title":"request_forward_agent"},{"location":"reference/sshChannelEnvironment/#request_x11_2","text":"def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None ) Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc: 4254 :: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake , random cookie , and that the cookie be checked and replaced by the real cookie when a connection request is received . If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using .Transport.accept . The handler's calling signature is:: handler ( channel : Channel , ( address : str , port : int )) Parameters: Name Type Description Default screen_number int the x11 screen number (0, 10, etc.) None auth_protocol str the name of the X11 authentication method used; if none is given, \"MIT-MAGIC-COOKIE-1\" is used None auth_cookie str hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated None single_connection bool if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) None handler None an optional callable handler to use for incoming X11 connections None Returns: Type Description None the auth_cookie used View Source @ open_only def request_x11 ( self , screen_number = 0 , auth_protocol = None , auth_cookie = None , single_connection = False , handler = None , ): \"\"\" Request an x11 session on this channel. If the server allows it, further x11 requests can be made from the server to the client, when an x11 application is run in a shell session. From :rfc:`4254`:: It is RECOMMENDED that the 'x11 authentication cookie' that is sent be a fake, random cookie, and that the cookie be checked and replaced by the real cookie when a connection request is received. If you omit the auth_cookie, a new secure random 128-bit value will be generated, used, and returned. You will need to use this value to verify incoming x11 requests and replace them with the actual local x11 cookie (which requires some knowledge of the x11 protocol). If a handler is passed in, the handler is called from another thread whenever a new x11 connection arrives. The default handler queues up incoming x11 connections, which may be retrieved using `.Transport.accept`. The handler's calling signature is:: handler(channel: Channel, (address: str, port: int)) :param int screen_number: the x11 screen number (0, 10, etc.) :param str auth_protocol: the name of the X11 authentication method used; if none is given, ``\" MIT - MAGIC - COOKIE - 1 \"`` is used :param str auth_cookie: hexadecimal string containing the x11 auth cookie; if none is given, a secure random 128-bit value is generated :param bool single_connection: if True, only a single x11 connection will be forwarded (by default, any number of x11 connections can arrive over this session) :param handler: an optional callable handler to use for incoming X11 connections :return: the auth_cookie used \"\"\" if auth_protocol is None : auth_protocol = \"MIT-MAGIC-COOKIE-1\" if auth_cookie is None : auth_cookie = binascii . hexlify ( os . urandom ( 16 )) m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"x11-req\" ) m . add_boolean ( True ) m . add_boolean ( single_connection ) m . add_string ( auth_protocol ) m . add_string ( auth_cookie ) m . add_int ( screen_number ) self . _event_pending () self . transport . _send_user_message ( m ) self . _wait_for_event () self . transport . _set_x11_handler ( handler ) return auth_cookie","title":"request_x11"},{"location":"reference/sshChannelEnvironment/#resetenvironment_1","text":"def resetEnvironment ( self ) -> None Resets the environment console stack View Source def resetEnvironment ( self ) -> None : \"\"\" Resets the environment console stack \"\"\" numOfPulls = 0 for item in reversed ( self . consoleStack ) : if item [ 0 ] == self . __USER_ESCALATION__ or item [ 0 ] == self . __CONSOLE_ESCALATION__ : break numOfPulls += 1 for x in range ( numOfPulls ) : self . consoleStack . pop ()","title":"resetEnvironment"},{"location":"reference/sshChannelEnvironment/#resize_pty_2","text":"def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous get_pty call. Parameters: Name Type Description Default width int new width (in characters) of the terminal screen None height int new height (in characters) of the terminal screen None width_pixels int new width (in pixels) of the terminal screen None height_pixels int new height (in pixels) of the terminal screen None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def resize_pty ( self , width = 80 , height = 24 , width_pixels = 0 , height_pixels = 0 ) : \" \"\" Resize the pseudo-terminal. This can be used to change the width and height of the terminal emulation created in a previous `get_pty` call. :param int width: new width (in characters) of the terminal screen :param int height: new height (in characters) of the terminal screen :param int width_pixels: new width (in pixels) of the terminal screen :param int height_pixels: new height (in pixels) of the terminal screen :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"window-change\" ) m . add_boolean ( False ) m . add_int ( width ) m . add_int ( height ) m . add_int ( width_pixels ) m . add_int ( height_pixels ) self . transport . _send_user_message ( m )","title":"resize_pty"},{"location":"reference/sshChannelEnvironment/#send_2","text":"def send ( self , s ) Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send None Returns: Type Description None number of bytes actually sent, as an int Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . View Source def send ( self , s ) : \" \"\" Send data to the channel. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send :return: number of bytes actually sent, as an `int` :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_DATA ) m . add_int ( self . remote_chanid ) return self . _send ( s , m )","title":"send"},{"location":"reference/sshChannelEnvironment/#send_exit_status_2","text":"def send_exit_status ( self , status ) Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. Parameters: Name Type Description Default status int the exit code of the process .. versionadded:: 1.2 None View Source def send_exit_status(self, status): \"\"\" Send the exit status of an executed command to the client. (This really only makes sense in server mode.) Many clients expect to get some sort of status code back from an executed command after it completes. :param int status: the exit code of the process .. versionadded:: 1.2 \"\"\" # in many cases, the channel will not still be open here. # that's fine. m = Message() m.add_byte(cMSG_CHANNEL_REQUEST) m.add_int(self.remote_chanid) m.add_string(\"exit-status\") m.add_boolean(False) m.add_int(status) self.transport._send_user_message(m)","title":"send_exit_status"},{"location":"reference/sshChannelEnvironment/#send_ready_2","text":"def send_ready ( self ) Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a send call will succeed immediately and return the number of bytes actually written. Returns: Type Description None True if a send call on this channel would immediately succeed or fail View Source def send_ready ( self ) : \" \"\" Returns true if data can be written to this channel without blocking. This means the channel is either closed (so any write attempt would return immediately) or there is at least one byte of space in the outbound buffer. If there is at least one byte of space in the outbound buffer, a `send` call will succeed immediately and return the number of bytes actually written. :return: ``True`` if a `send` call on this channel would immediately succeed or fail \"\" \" self . lock . acquire () try : if self . closed or self . eof_sent : return True return self . out_window_size > 0 finally : self . lock . release ()","title":"send_ready"},{"location":"reference/sshChannelEnvironment/#send_stderr_2","text":"def send_stderr ( self , s ) Send data to the channel on the \"stderr\" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. Parameters: Name Type Description Default s bytes data to send. None Returns: Type Description None number of bytes actually sent, as an int . Raises: Type Description socket.timeout if no data could be sent before the timeout set by settimeout . .. versionadded:: 1.1 View Source def send_stderr ( self , s ) : \" \"\" Send data to the channel on the \" stderr \" stream. This is normally only used by servers to send output from shell commands -- clients won't use this. Returns the number of bytes sent, or 0 if the channel stream is closed. Applications are responsible for checking that all data has been sent: if only some of the data was transmitted, the application needs to attempt delivery of the remaining data. :param bytes s: data to send. :return: number of bytes actually sent, as an `int`. :raises socket.timeout: if no data could be sent before the timeout set by `settimeout`. .. versionadded:: 1.1 \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_EXTENDED_DATA ) m . add_int ( self . remote_chanid ) m . add_int ( 1 ) return self . _send ( s , m )","title":"send_stderr"},{"location":"reference/sshChannelEnvironment/#sendall_2","text":"def sendall ( self , s ) Send data to the channel, without allowing partial results. Unlike send , this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. View Source def sendall ( self , s ) : \" \"\" Send data to the channel, without allowing partial results. Unlike `send`, this method continues to send data from the given string until either all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. note:: If the channel is closed while only part of the data has been sent, there is no way to determine how much data (if any) was sent. This is irritating, but identically follows Python's API. \"\" \" while s : sent = self . send ( s ) s = s [ sent : ] return None","title":"sendall"},{"location":"reference/sshChannelEnvironment/#sendall_stderr_2","text":"def sendall_stderr ( self , s ) Send data to the channel's \"stderr\" stream, without allowing partial results. Unlike send_stderr , this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. Parameters: Name Type Description Default s bytes data to send to the client as \"stderr\" output. None Raises: Type Description socket.timeout if sending stalled for longer than the timeout set by settimeout . socket.error if an error occurred before the entire string was sent. .. versionadded:: 1.1 View Source def sendall_stderr ( self , s ) : \" \"\" Send data to the channel's \" stderr \" stream, without allowing partial results. Unlike `send_stderr`, this method continues to send data from the given bytestring until all data has been sent or an error occurs. Nothing is returned. :param bytes s: data to send to the client as \" stderr \" output. :raises socket.timeout: if sending stalled for longer than the timeout set by `settimeout`. :raises socket.error: if an error occurred before the entire string was sent. .. versionadded:: 1.1 \"\" \" while s : sent = self . send_stderr ( s ) s = s [ sent : ] return None","title":"sendall_stderr"},{"location":"reference/sshChannelEnvironment/#set_combine_stderr_2","text":"def set_combine_stderr ( self , combine ) Set whether stderr should be combined into stdout on this channel. The default is False , but in some cases it may be convenient to have both streams combined. If this is False , and exec_command is called (or invoke_shell with no pty), output to stderr will not show up through the recv and recv_ready calls. You will have to use recv_stderr and recv_stderr_ready to get stderr output. If this is True , data will never show up via recv_stderr or recv_stderr_ready . Parameters: Name Type Description Default combine bool True if stderr output should be combined into stdout on this channel. None Returns: Type Description None the previous setting (a bool ). .. versionadded:: 1.1 View Source def set _combine_stderr ( self , combine ) : \" \"\" Set whether stderr should be combined into stdout on this channel. The default is ``False``, but in some cases it may be convenient to have both streams combined. If this is ``False``, and `exec_command` is called (or ``invoke_shell`` with no pty), output to stderr will not show up through the `recv` and `recv_ready` calls. You will have to use `recv_stderr` and `recv_stderr_ready` to get stderr output. If this is ``True``, data will never show up via `recv_stderr` or `recv_stderr_ready`. :param bool combine: ``True`` if stderr output should be combined into stdout on this channel. :return: the previous setting (a `bool`). .. versionadded:: 1.1 \"\" \" data = bytes () self . lock . acquire () try : old = self . combine_stderr self . combine_stderr = combine if combine and not old : # copy old stderr buffer into primary buffer data = self . in_stderr_buffer . empty () finally : self . lock . release () if len ( data ) > 0 : self . _feed ( data ) return old","title":"set_combine_stderr"},{"location":"reference/sshChannelEnvironment/#set_environment_variable_2","text":"def set_environment_variable ( self , name , value ) Set the value of an environment variable. .. warning:: The server may reject this request depending on its AcceptEnv setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! Parameters: Name Type Description Default name str name of the environment variable None value str value of the environment variable None Raises: Type Description None .SSHException -- if the request was rejected or the channel was closed View Source @open_only def set _environment_variable ( self , name , value ) : \" \"\" Set the value of an environment variable. .. warning:: The server may reject this request depending on its ``AcceptEnv`` setting; such rejections will fail silently (which is common client practice for this particular request type). Make sure you understand your server's configuration before using! :param str name: name of the environment variable :param str value: value of the environment variable :raises: `.SSHException` -- if the request was rejected or the channel was closed \"\" \" m = Message () m . add_byte ( cMSG_CHANNEL_REQUEST ) m . add_int ( self . remote_chanid ) m . add_string ( \"env\" ) m . add_boolean ( False ) m . add_string ( name ) m . add_string ( value ) self . transport . _send_user_message ( m )","title":"set_environment_variable"},{"location":"reference/sshChannelEnvironment/#set_name_2","text":"def set_name ( self , name ) Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the get_name method. Parameters: Name Type Description Default name str new channel name None View Source def set _name ( self , name ) : \" \"\" Set a name for this channel. Currently it's only used to set the name of the channel in logfile entries. The name can be fetched with the `get_name` method. :param str name: new channel name \"\" \" self . _name = name","title":"set_name"},{"location":"reference/sshChannelEnvironment/#setblocking_2","text":"def setblocking ( self , blocking ) Set blocking or non-blocking mode of the channel: if blocking is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a recv call doesn't find any data, or if a send call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \"immediate data\" for recv , so if the channel is closed in the read direction, it will never block. chan.setblocking(0) is equivalent to chan.settimeout(0) ; chan.setblocking(1) is equivalent to chan.settimeout(None) . Parameters: Name Type Description Default blocking int 0 to set non-blocking mode; non-0 to set blocking mode. None View Source def set blocking ( self , blocking ) : \" \"\" Set blocking or non-blocking mode of the channel: if ``blocking`` is 0, the channel is set to non-blocking mode; otherwise it's set to blocking mode. Initially all channels are in blocking mode. In non-blocking mode, if a `recv` call doesn't find any data, or if a `send` call can't immediately dispose of the data, an error exception is raised. In blocking mode, the calls block until they can proceed. An EOF condition is considered \" immediate data \" for `recv`, so if the channel is closed in the read direction, it will never block. ``chan.setblocking(0)`` is equivalent to ``chan.settimeout(0)``; ``chan.setblocking(1)`` is equivalent to ``chan.settimeout(None)``. :param int blocking: 0 to set non-blocking mode; non-0 to set blocking mode. \"\" \" if blocking : self . set timeout ( None ) else : self . set timeout ( 0.0 )","title":"setblocking"},{"location":"reference/sshChannelEnvironment/#settimeout_2","text":"def settimeout ( self , timeout ) Set a timeout on blocking read/write operations. The timeout argument can be a nonnegative float expressing seconds, or None . If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of None disables timeouts on socket operations. chan.settimeout(0.0) is equivalent to chan.setblocking(0) ; chan.settimeout(None) is equivalent to chan.setblocking(1) . Parameters: Name Type Description Default timeout float seconds to wait for a pending read/write operation before raising socket.timeout , or None for no timeout. None View Source def set timeout ( self , timeout ) : \" \"\" Set a timeout on blocking read/write operations. The ``timeout`` argument can be a nonnegative float expressing seconds, or ``None``. If a float is given, subsequent channel read/write operations will raise a timeout exception if the timeout period value has elapsed before the operation has completed. Setting a timeout of ``None`` disables timeouts on socket operations. ``chan.settimeout(0.0)`` is equivalent to ``chan.setblocking(0)``; ``chan.settimeout(None)`` is equivalent to ``chan.setblocking(1)``. :param float timeout: seconds to wait for a pending read/write operation before raising ``socket.timeout``, or ``None`` for no timeout. \"\" \" self . timeout = timeout","title":"settimeout"},{"location":"reference/sshChannelEnvironment/#shutdown_2","text":"def shutdown ( self , how ) Shut down one or both halves of the connection. If how is 0, further receives are disallowed. If how is 1, further sends are disallowed. If how is 2, further sends and receives are disallowed. This closes the stream in one or both directions. Parameters: Name Type Description Default how int 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). None View Source def shutdown ( self , how ) : \" \"\" Shut down one or both halves of the connection. If ``how`` is 0, further receives are disallowed. If ``how`` is 1, further sends are disallowed. If ``how`` is 2, further sends and receives are disallowed. This closes the stream in one or both directions. :param int how: 0 (stop receiving), 1 (stop sending), or 2 (stop receiving and sending). \"\" \" if ( how == 0 ) or ( how == 2 ) : # feign \"read\" shutdown self . eof_received = 1 if ( how == 1 ) or ( how == 2 ) : self . lock . acquire () try : m = self . _send_eof () finally : self . lock . release () if m is not None : self . transport . _send_user_message ( m )","title":"shutdown"},{"location":"reference/sshChannelEnvironment/#shutdown_read_2","text":"def shutdown_read ( self ) Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to shutdown(0) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_read ( self ): \"\"\" Shutdown the receiving side of this socket, closing the stream in the incoming direction. After this call, future reads on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(0)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 0 )","title":"shutdown_read"},{"location":"reference/sshChannelEnvironment/#shutdown_write_2","text":"def shutdown_write ( self ) Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to shutdown(1) , for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 View Source def shutdown_write ( self ): \"\"\" Shutdown the sending side of this socket, closing the stream in the outgoing direction. After this call, future writes on this channel will fail instantly. This is a convenience method, equivalent to ``shutdown(1)``, for people who don't make it a habit to memorize unix constants from the 1970s. .. versionadded:: 1.2 \"\"\" self . shutdown ( 1 )","title":"shutdown_write"},{"location":"reference/sshChannelEnvironment/#update_environment_2","text":"def update_environment ( self , environment ) Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in set_environment_variable for details. Parameters: Name Type Description Default environment dict a dictionary containing the name and respective values to set None Raises: Type Description None .SSHException -- if any of the environment variables was rejected by the server or the channel was closed View Source @open_only def update_environment ( self , environment ) : \" \"\" Updates this channel's remote shell environment. .. note:: This operation is additive - i.e. the current environment is not reset before the given environment variables are set. .. warning:: Servers may silently reject some environment variables; see the warning in `set_environment_variable` for details. :param dict environment: a dictionary containing the name and respective values to set :raises: `.SSHException` -- if any of the environment variables was rejected by the server or the channel was closed \"\" \" for name , value in environment . items () : try : self . set _environment_variable ( name , value ) except SSHException as e : err = 'Failed to set environment variable \"{}\".' raise SSHException ( err . format ( name ), e )","title":"update_environment"},{"location":"reference/sshConnect/","text":"Module sshConnect View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 12/10/14 # Description: This is the base class for sshConnector ToolKit. The sshConnector ToolKit is the backend necessary # for the Linux Diagnostic Tool Kit to allow it to be able to connect via SSH to Linux Machines. # This is the base class inherited by other classes within the sshConnect package. This class servers only one purpose, # too connect to a Linux machine via SSH. import socket import logging import traceback import paramiko from paramiko import PKey , SSHClient , Channel from paramiko.transport import Transport from paramiko.proxy import ProxyCommand from io import StringIO , TextIOWrapper from sshConnector.sshLibs.sshChannelEnvironment import sshChannelWrapper , sshEnvironment , EnvironmentControls from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import LDTKSSHException , SSHExceptionAuth , SSHExceptionConn , \\ SSHExceptionUnknown , SSHExceptionChannel from typing import AnyStr , Optional , Union # turn off debug for paramiko _ptlog = logging . getLogger ( 'paramiko.transport' ) _ptlog . setLevel ( logging . WARNING ) _pclog = logging . getLogger ( 'paramiko.channel' ) _pclog . setLevel ( logging . WARNING ) log = logging . getLogger ( 'sshConnect' ) class sshConnect ( object ): ssh : SSHClient = None _mainEnvironment : Channel = None arguments = None def __init__ ( self , arguments , ** kwargs ): \"\"\" The normal use of this init function is to have args passed and to make a connection. This class should be called around a 'try' block if args are passed. - :param arguments: (NameSpaceDict) - :param kwargs: This is only here to satisfy recommended class inheritance issues. \"\"\" log . debug ( \"Creating the sshConnect class\" ) self . arguments = arguments self . host = arguments . host self . port = arguments . port or 22 self . key = arguments . key self . username = arguments . username self . password = arguments . password self . passphrase = arguments . passphrase if arguments . passphrase else None self . root = arguments . root self . rootLogin = sshConnect . processRootLogin ( arguments . rootLogin ) self . rootpwd = arguments . rootpwd self . connTimeout = arguments . connTimeout self . proxyUser = arguments . proxyUser self . proxyServer = arguments . proxyServer self . runTimeout = arguments . runTimeout self . firstBitTimeout = arguments . firstBitTimeout self . betweenBitTimeout = arguments . betweenBitTimeout self . delay = arguments . delay self . ioTimeout = arguments . ioTimeout self . ssh = self . createConn () self . _mainEnvironment = self . _openChannel ( self . _createTransport ()) self . _mainEnvironment . __MAIN__ = True # noinspection PyTypeChecker def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s : %s ' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s : %s ' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s : %s ' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s : %s ' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s : %s ' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport () . is_active () and not sshChannel . closed def disconnect ( self ) -> None : \"\"\" Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. \"\"\" try : self . mainEnvironment . get_transport () . close () self . ssh . close () except Exception as e : log . error ( f 'Disconnect failed: { e } ' ) log . debug ( f '[DEBUG]: Disconnect failure reason: { traceback . format_exc () } ' ) def _makeSockProxy ( self ) -> Optional [ ProxyCommand ]: \"\"\" Use a proxy to ssh into a server. - :return: (Socket like object) \"\"\" if not self . proxyUser or not self . proxyServer : return None controlPath = '~/.ssh/master- %r @%h:%p' flags = \"-F '/dev/null' -o ControlMaster='auto' -o ControlPath=' %s ' -o TCPKeepAlive='yes' \" \\ \"-o ServerAliveInterval=300\" % controlPath proxycommand = f \"ssh { flags } -A { self . proxyUser } @ { self . proxyServer } 'nc { self . host } { self . port } '\" try : return paramiko . ProxyCommand ( proxycommand ) except Exception as e : log . debug ( f 'Error occurred setting up proxy command: { e } ' ) log . debug ( f \"[DEBUG] for _makeSockProxy: { traceback . format_exc () } \" ) raise SSHExceptionConn ( f 'Failed setting up SSH ProxyCommand: { e } ' ) from e def _createTransport ( self ) -> Optional [ Transport ]: \"\"\" Creates the transport object. \"\"\" if not self . ssh : raise LDTKSSHException ( 'There is not SSH object which implies Paramiko is not connected!' ) try : sshTransport = self . ssh . get_transport () sshTransport . set_keepalive ( 10 ) sshTransport . use_compression () return sshTransport except Exception as e : log . debug ( f 'Error occurred creating transport object: { e } ' ) log . debug ( f \"[DEBUG] for _createTransport: { traceback . format_exc () } \" ) if self . checkConnection (): self . ssh . close () raise SSHExceptionChannel ( f 'Failed create SSH Transport: { e } ' ) from e def _openChannel ( self , sshTransport : Transport , ** kwargs ) -> EnvironmentControls : \"\"\" Creates SSH Channel using existing SSH Transport Object. - :return: (Channel) \"\"\" try : channel = sshTransport . open_session () channel . settimeout ( self . ioTimeout ) channel . get_pty () channel . invoke_shell () kwargs . update ({ 'sshParent' : self }) return EnvironmentControls ( sshEnvironment ( sshChannelWrapper ( channel , ** kwargs ), ** kwargs ), ** kwargs ) except paramiko . ChannelException as e : log . debug ( f 'Error occurred when opening channel: { e } ' ) log . debug ( f \"[DEBUG] for _openChannel: { traceback . format_exc () } \" ) if sshTransport : sshTransport . close () raise SSHExceptionChannel ( f 'Failed to open SSH Channel: { e } ' ) from e @staticmethod def _handleSSHKey ( key : Union [ AnyStr , TextIOWrapper ], passphrase : AnyStr = None ) -> Optional [ PKey ]: \"\"\" Creates ssh key object or returns None. - :param key: (Str/File Like Object) - :param passphrase: (str) default None - :return: (PKey base object) \"\"\" if not key : return None try : sshKeyFile = StringIO () if isinstance ( key , TextIOWrapper ): sshKeyFile . write ( key . read ()) else : sshKeyFile . write ( key ) except Exception : log . debug ( \"There was a failure to read the provied SSH key file!\" ) log . debug ( f \"[DEBUG] for _handleSSHKey: { traceback . format_exc () } \" ) return None def _rsaHelper (): try : sshKeyFile . seek ( 0 ) return paramiko . RSAKey . from_private_key ( sshKeyFile , password = passphrase ) except Exception as e : log . error ( f 'RSA Key failed: { e } ' ) log . debug ( f \"[DEBUG] for _rsaHelper: { traceback . format_exc () } \" ) def _dssKey (): try : sshKeyFile . seek ( 0 ) return paramiko . DSSKey . from_private_key ( sshKeyFile , password = passphrase ) except Exception as e : log . error ( f 'DSS Key failed: { e } ' ) log . debug ( f \"[DEBUG] for _dssKey: { traceback . format_exc () } \" ) def _ECDSAKey (): try : sshKeyFile . seek ( 0 ) return paramiko . ECDSAKey . from_private_key ( sshKeyFile , password = passphrase ) except Exception as e : log . error ( f 'ECDSA Key failed: { e } ' ) log . debug ( f \"[DEBUG] for _ECDSAKey: { traceback . format_exc () } \" ) sshKey = _rsaHelper () if sshKey : return sshKey sshKey = _dssKey () if sshKey : return sshKey sshKey = _ECDSAKey () if sshKey : return sshKey log . warning ( 'Unable to translate SSH private SSH key for use.' ) return None @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' @property def mainEnvironment ( self ): if self . ssh is None : return None if self . _mainEnvironment is None : self . _mainEnvironment = self . _openChannel ( self . _createTransport ()) self . _mainEnvironment . __MAIN__ = True return self . _mainEnvironment Variables log Classes sshConnect class sshConnect ( arguments , ** kwargs ) Class variables arguments ssh Static methods processRootLogin def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' Instance variables mainEnvironment Methods checkConnection def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed createConn def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh disconnect def disconnect ( self ) -> None Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. View Source def disconnect ( self ) -> None : \"\"\" Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. \"\"\" try : self . mainEnvironment . get_transport (). close () self . ssh . close () except Exception as e : log . error ( f 'Disconnect failed: {e}' ) log . debug ( f '[DEBUG]: Disconnect failure reason: {traceback.format_exc()}' )","title":"Sshconnect"},{"location":"reference/sshConnect/#module-sshconnect","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 #!/usr/bin/env python # -*- coding=utf-8 -*- # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 12/10/14 # Description: This is the base class for sshConnector ToolKit. The sshConnector ToolKit is the backend necessary # for the Linux Diagnostic Tool Kit to allow it to be able to connect via SSH to Linux Machines. # This is the base class inherited by other classes within the sshConnect package. This class servers only one purpose, # too connect to a Linux machine via SSH. import socket import logging import traceback import paramiko from paramiko import PKey , SSHClient , Channel from paramiko.transport import Transport from paramiko.proxy import ProxyCommand from io import StringIO , TextIOWrapper from sshConnector.sshLibs.sshChannelEnvironment import sshChannelWrapper , sshEnvironment , EnvironmentControls from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import LDTKSSHException , SSHExceptionAuth , SSHExceptionConn , \\ SSHExceptionUnknown , SSHExceptionChannel from typing import AnyStr , Optional , Union # turn off debug for paramiko _ptlog = logging . getLogger ( 'paramiko.transport' ) _ptlog . setLevel ( logging . WARNING ) _pclog = logging . getLogger ( 'paramiko.channel' ) _pclog . setLevel ( logging . WARNING ) log = logging . getLogger ( 'sshConnect' ) class sshConnect ( object ): ssh : SSHClient = None _mainEnvironment : Channel = None arguments = None def __init__ ( self , arguments , ** kwargs ): \"\"\" The normal use of this init function is to have args passed and to make a connection. This class should be called around a 'try' block if args are passed. - :param arguments: (NameSpaceDict) - :param kwargs: This is only here to satisfy recommended class inheritance issues. \"\"\" log . debug ( \"Creating the sshConnect class\" ) self . arguments = arguments self . host = arguments . host self . port = arguments . port or 22 self . key = arguments . key self . username = arguments . username self . password = arguments . password self . passphrase = arguments . passphrase if arguments . passphrase else None self . root = arguments . root self . rootLogin = sshConnect . processRootLogin ( arguments . rootLogin ) self . rootpwd = arguments . rootpwd self . connTimeout = arguments . connTimeout self . proxyUser = arguments . proxyUser self . proxyServer = arguments . proxyServer self . runTimeout = arguments . runTimeout self . firstBitTimeout = arguments . firstBitTimeout self . betweenBitTimeout = arguments . betweenBitTimeout self . delay = arguments . delay self . ioTimeout = arguments . ioTimeout self . ssh = self . createConn () self . _mainEnvironment = self . _openChannel ( self . _createTransport ()) self . _mainEnvironment . __MAIN__ = True # noinspection PyTypeChecker def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s : %s ' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s : %s ' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s : %s ' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s : %s ' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s : %s ' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport () . is_active () and not sshChannel . closed def disconnect ( self ) -> None : \"\"\" Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. \"\"\" try : self . mainEnvironment . get_transport () . close () self . ssh . close () except Exception as e : log . error ( f 'Disconnect failed: { e } ' ) log . debug ( f '[DEBUG]: Disconnect failure reason: { traceback . format_exc () } ' ) def _makeSockProxy ( self ) -> Optional [ ProxyCommand ]: \"\"\" Use a proxy to ssh into a server. - :return: (Socket like object) \"\"\" if not self . proxyUser or not self . proxyServer : return None controlPath = '~/.ssh/master- %r @%h:%p' flags = \"-F '/dev/null' -o ControlMaster='auto' -o ControlPath=' %s ' -o TCPKeepAlive='yes' \" \\ \"-o ServerAliveInterval=300\" % controlPath proxycommand = f \"ssh { flags } -A { self . proxyUser } @ { self . proxyServer } 'nc { self . host } { self . port } '\" try : return paramiko . ProxyCommand ( proxycommand ) except Exception as e : log . debug ( f 'Error occurred setting up proxy command: { e } ' ) log . debug ( f \"[DEBUG] for _makeSockProxy: { traceback . format_exc () } \" ) raise SSHExceptionConn ( f 'Failed setting up SSH ProxyCommand: { e } ' ) from e def _createTransport ( self ) -> Optional [ Transport ]: \"\"\" Creates the transport object. \"\"\" if not self . ssh : raise LDTKSSHException ( 'There is not SSH object which implies Paramiko is not connected!' ) try : sshTransport = self . ssh . get_transport () sshTransport . set_keepalive ( 10 ) sshTransport . use_compression () return sshTransport except Exception as e : log . debug ( f 'Error occurred creating transport object: { e } ' ) log . debug ( f \"[DEBUG] for _createTransport: { traceback . format_exc () } \" ) if self . checkConnection (): self . ssh . close () raise SSHExceptionChannel ( f 'Failed create SSH Transport: { e } ' ) from e def _openChannel ( self , sshTransport : Transport , ** kwargs ) -> EnvironmentControls : \"\"\" Creates SSH Channel using existing SSH Transport Object. - :return: (Channel) \"\"\" try : channel = sshTransport . open_session () channel . settimeout ( self . ioTimeout ) channel . get_pty () channel . invoke_shell () kwargs . update ({ 'sshParent' : self }) return EnvironmentControls ( sshEnvironment ( sshChannelWrapper ( channel , ** kwargs ), ** kwargs ), ** kwargs ) except paramiko . ChannelException as e : log . debug ( f 'Error occurred when opening channel: { e } ' ) log . debug ( f \"[DEBUG] for _openChannel: { traceback . format_exc () } \" ) if sshTransport : sshTransport . close () raise SSHExceptionChannel ( f 'Failed to open SSH Channel: { e } ' ) from e @staticmethod def _handleSSHKey ( key : Union [ AnyStr , TextIOWrapper ], passphrase : AnyStr = None ) -> Optional [ PKey ]: \"\"\" Creates ssh key object or returns None. - :param key: (Str/File Like Object) - :param passphrase: (str) default None - :return: (PKey base object) \"\"\" if not key : return None try : sshKeyFile = StringIO () if isinstance ( key , TextIOWrapper ): sshKeyFile . write ( key . read ()) else : sshKeyFile . write ( key ) except Exception : log . debug ( \"There was a failure to read the provied SSH key file!\" ) log . debug ( f \"[DEBUG] for _handleSSHKey: { traceback . format_exc () } \" ) return None def _rsaHelper (): try : sshKeyFile . seek ( 0 ) return paramiko . RSAKey . from_private_key ( sshKeyFile , password = passphrase ) except Exception as e : log . error ( f 'RSA Key failed: { e } ' ) log . debug ( f \"[DEBUG] for _rsaHelper: { traceback . format_exc () } \" ) def _dssKey (): try : sshKeyFile . seek ( 0 ) return paramiko . DSSKey . from_private_key ( sshKeyFile , password = passphrase ) except Exception as e : log . error ( f 'DSS Key failed: { e } ' ) log . debug ( f \"[DEBUG] for _dssKey: { traceback . format_exc () } \" ) def _ECDSAKey (): try : sshKeyFile . seek ( 0 ) return paramiko . ECDSAKey . from_private_key ( sshKeyFile , password = passphrase ) except Exception as e : log . error ( f 'ECDSA Key failed: { e } ' ) log . debug ( f \"[DEBUG] for _ECDSAKey: { traceback . format_exc () } \" ) sshKey = _rsaHelper () if sshKey : return sshKey sshKey = _dssKey () if sshKey : return sshKey sshKey = _ECDSAKey () if sshKey : return sshKey log . warning ( 'Unable to translate SSH private SSH key for use.' ) return None @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' @property def mainEnvironment ( self ): if self . ssh is None : return None if self . _mainEnvironment is None : self . _mainEnvironment = self . _openChannel ( self . _createTransport ()) self . _mainEnvironment . __MAIN__ = True return self . _mainEnvironment","title":"Module sshConnect"},{"location":"reference/sshConnect/#variables","text":"log","title":"Variables"},{"location":"reference/sshConnect/#classes","text":"","title":"Classes"},{"location":"reference/sshConnect/#sshconnect","text":"class sshConnect ( arguments , ** kwargs )","title":"sshConnect"},{"location":"reference/sshConnect/#class-variables","text":"arguments ssh","title":"Class variables"},{"location":"reference/sshConnect/#static-methods","text":"","title":"Static methods"},{"location":"reference/sshConnect/#processrootlogin","text":"def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -'","title":"processRootLogin"},{"location":"reference/sshConnect/#instance-variables","text":"mainEnvironment","title":"Instance variables"},{"location":"reference/sshConnect/#methods","text":"","title":"Methods"},{"location":"reference/sshConnect/#checkconnection","text":"def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed","title":"checkConnection"},{"location":"reference/sshConnect/#createconn","text":"def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh","title":"createConn"},{"location":"reference/sshConnect/#disconnect","text":"def disconnect ( self ) -> None Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. View Source def disconnect ( self ) -> None : \"\"\" Get the underlying transport for the active channel and close it out, thereby closing the channel and all associated channels to that transport. \"\"\" try : self . mainEnvironment . get_transport (). close () self . ssh . close () except Exception as e : log . error ( f 'Disconnect failed: {e}' ) log . debug ( f '[DEBUG]: Disconnect failure reason: {traceback.format_exc()}' )","title":"disconnect"},{"location":"reference/sshEnvironmentControl/","text":"Module sshEnvironmentControl View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 10/13/14 # Description: This is the 4th class in the sshConnector. This is a focus on changing users in a persistent ssh # connection. It allows someone to change the user after logging in and keeps track to what user you are and have # been. import re import traceback import logging from time import sleep from io import StringIO from typing import Callable , Optional , Union from PyLinuxDiagnosticToolKit.libs import dummy_func from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import BecomeUserException , SSHExceptionChannel from sshConnector.sshBufferControl import sshBufferControl from sshConnector.sshLibs.sshChannelEnvironment import sshEnvironment log = logging . getLogger ( 'sshEnvironmentControl' ) class sshEnvironmentControl ( sshBufferControl ): # Regex's used to pull command tags. matchRe = re . compile ( r '(?<=^CMDSTART).+' , flags = re . MULTILINE | re . DOTALL ) # clean up any errors or other data that may appear before the start tag startSubRe = re . compile ( r '.*?(?=^CMDSTART)' , flags = re . MULTILINE | re . DOTALL ) # clean up all data after the end tag endSubRe = re . compile ( r 'CMDEND.*' , flags = re . MULTILINE | re . DOTALL ) def __init__ ( self , arguments , ** kwargs ): \"\"\" init function for sshEnvironmentControl. This class has methods that control the state of a shell environment that the Paramiko Channel object is connected too. It can do things such as user escalation, change shell type, export variables and so on. - :param arguments: If this is not passed then sshUserControl simply moves along to its super class sshCommand. - :param kwargs: Exists to help safely deal with inheritance. - :return: This is a __init__ class and doesn't have a return. \"\"\" super ( sshEnvironmentControl , self ) . __init__ ( arguments = arguments , ** kwargs ) self . usermap = arguments . usermap if self . checkConnection (): self . mainEnvironment . push ( \"su -\" , name = arguments . username , additionalInput = arguments . password ) self . _promptWait ( self . mainEnvironment , StringIO (), timeout = 10 , iotime = 2 ) if arguments . root : self . becomeRoot () else : self . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True ) def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( 'environment' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: { environment . _id } - Prompt: { environment . prompt } - Whoami: { environment . whoami } \" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: { environment . _id } - Prompt: { environment . prompt } - Whoami: { environment . whoami } \" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment , bool ]: \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ): # log.debug(\"The connection is closed!\") return False # Checks to see if you are attempting to become a user you already are. if userName is environment . whoami : # log.debug(\"You are attempting to escalate to the user currently logged in as. Skipping\") return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too. We will only deescalate if the 'userEscalation' flag is False which is default. If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user. if userName in environment . userList : # log.debug(\"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\") if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache. This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts. loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport () . close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user. We 'may' attempt to retry using a # different login command. This retry depends on the \"verifyUser\" variable. try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: { e } \" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: { userName } with command: { loginCmd } . Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: { userName } with command: { loginCmd } . \" f \"Trying command: { newLoginCmd } \" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: { e } \" ) log . debug ( f \"[DEBUG]: { traceback . format_exc () } \" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ): if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment.getPrompt(reCapturePrompt=reCapturePrompt) return channel or environment def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \"console\" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport () . close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs ) def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )() def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment , bool ]: environment = environment or self . mainEnvironment if not self . checkConnection ( environment ): return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ): log . info ( f \"Connection still valid on: { environment . _id } - Num Escalations: { environment . numEscalations } \" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: { environment . _id } \" ) return environment def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection () def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment , bool ]: \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ): return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ - 2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser (): break return environment def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ): self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ) . disconnect () def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' ) def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ) . strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: { e } ' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: { traceback . format_exc () } ' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' )) def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ]: \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log.debug(f\"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\") if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt def _escalateUser ( self , loginCmd : str , userName : str , loginPasswd : str , environment : sshEnvironment , verifyUser : bool , buffer : StringIO , unsafe : bool , ** kwargs ) -> sshEnvironment : \"\"\" Used as a helper function for becomeUser - :param loginCmd: (str) - :param userName: (str) - :param loginPasswd: (str) - :param environment: (sshEnvironment) - :param verifyUser: (bool) - :param buffer: (StringIO) - :param unsafe: (bool) - :param kwargs: gets passed along - :return: sshEnvironment \"\"\" kwargs . update ({ 'noUserPrompt' : self . _noUserPromptParser ( environment , ** kwargs )}) environment = self . _performEscalation ( environment , loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , buffer = buffer , unsafe = unsafe , ** kwargs ) if verifyUser : if not self . _verifyLogin ( environment , userName , buffer ): raise BecomeUserException ( f 'Unable to become user { userName } ' ) environment . push ( loginCmd , name = userName , additionalInput = loginPasswd , escalationType = 'user' ) return environment def _becomePreviousUser ( self , userName : str , buffer : StringIO , environment : sshEnvironment ) -> sshEnvironment : \"\"\" Used as a helper function for becomeUser - :param userName: (str) - :param buffer: (StringIO) - :param environment: (sshEnvironment) - :return: (sshEnvironment) \"\"\" environment = self . logoutCurrentUser ( environment , junkOut = buffer ) if userName == environment . whoami : if not self . _verifyLogin ( environment , userName = userName , out = buffer ): log . debug ( \"Failed to de-escalate to the correct user\" ) self . checkConnection ( environment ) elif userName != environment . whoami and userName in environment . userList : self . _becomePreviousUser ( userName , buffer , environment ) return environment def _performEscalation ( self , environment : sshEnvironment , loginCmd : str , loginPasswd : str , userName : str , buffer : StringIO , ** kwargs ) -> sshEnvironment : \"\"\" Used as a helper function for multiple methods within sshEnvironmentControl - :param environment: (sshEnvironment) - :param loginCmd: (str) - :param loginPasswd: (str) - :param userName: (str) - :param buffer: (StringIO) - :param kwargs: gets passed along - :return: (sshEnvironment) \"\"\" console = kwargs . get ( 'console' , False ) escalationHook = kwargs . get ( 'escalationHook' , None ) cmd = loginCmd + \" \" + userName if isinstance ( escalationHook , Callable ): self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , False ), prompt = kwargs . get ( 'prompt' , None )) escalationHook ( self , cmd , loginPasswd , environment , userName , buffer , console ) elif console is True : self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , False ), prompt = kwargs . get ( 'prompt' , None )) if loginPasswd : self . _bufferControl ( environment , loginPasswd , buffer , unsafe = True ) elif loginPasswd or 'sudo' in cmd : self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , True )) self . _insertPassword ( cmd , loginPasswd , environment , buffer , prompt = kwargs . get ( 'noUserPrompt' , None )) else : self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , False )) return environment def _insertPassword ( self , cmd : str , loginPasswd : str , environment : sshEnvironment , out : StringIO , prompt : str ) -> None : \"\"\" Used as a helper function for multiple methods within sshEnvironmentControl - :param cmd: (str) - :param loginPasswd: (str) - :param environment: (sshEnvironment) - :param out: (StringIO) - :param prompt: (str) - :return: None \"\"\" if environment . whoami != 'root' : wait = self . _passwdWait ( environment , out , cmd ) lastline = sshBufferControl . _processString ( out . getvalue () . splitlines ()[ - 1 ] . strip ()) if 'assword' not in lastline and lastline . endswith ( self . promptTextTuple ): log . debug ( \"Found a prompt skipping inserting password\" ) return None if \"sudo\" in cmd : if self . arguments . password : loginPasswd = self . arguments . password if 'assword for root' in lastline : wait = True loginPasswd = self . arguments . rootpwd elif 'assword for' in lastline : wait = True requestedName = re . search ( 'assword for(.*):' , lastline ) if requestedName : requestedName = requestedName . group ( 1 ) . strip () loginPasswd = environment . getPasswordFor ( requestedName ) elif prompt in lastline or lastline . endswith ( self . promptTextTuple ): return None if wait is not False : self . _bufferControl ( environment , loginPasswd , out , unsafe = True ) self . _promptWait ( environment , out , cmd , insertNewLine = 1 ) def _verifyLogin ( self , environment : sshEnvironment , userName : str , out : StringIO ) -> bool : \"\"\" Used as a helper function for multiple methods within sshEnvironmentControl - :param environment: (sshEnvironment) - :param userName: (str) - :param out: (StringIO) - :return: bool \"\"\" if len ( out . getvalue ()) > 0 and 'assword' in out . getvalue () . splitlines ()[ - 1 ]: self . _promptWait ( environment , out , insertNewLine = 3 , timeout = 30 ) results = self . checkWhoAmI ( environment = environment ) if results is not None and userName in results : return True return False def _clearLoginAttempt ( self , environment : sshEnvironment ) -> bool : \"\"\" Used by becomeUser method - :param environment: - :return: (bool) \"\"\" try : prompt = self . _noUserPromptParser ( environment , prompt = environment . prompt , currentUser = environment . whoami ) lastline = \"\" for i in range ( 5 ): lastline = self . _noUserPromptParser ( environment , prompt = str ( self . _capturePrompt ( environment , StringIO ())), currentUser = environment . whoami ) if lastline and prompt in lastline : return True sleep ( 1 ) if lastline . strip () . endswith ( self . promptTextTuple ): return True return False except Exception as e : log . error ( f 'error in _clearLoginAttempt: { e } ' ) log . debug ( f '[DEBUG] for _clearLoginAttempt: { traceback . format_exc () } ' ) return False def _noUserPromptParser ( self , environment : sshEnvironment , prompt : Optional [ str ] = None , ** kwargs ) -> Optional [ str ]: \"\"\" Used by multiple different private helper methods. - :param environment: (sshEnvironmnet) - :param prompt: (str) default None - :param kwargs: possibly contains 'currentUser' - :return: (str/None) \"\"\" if not prompt : prompt = self . getPrompt ( environment , reCapturePrompt = False ) if not prompt : return None currentUser = kwargs . get ( 'currentUser' , environment . whoami ) or '' return str ( prompt ) . replace ( currentUser , '' ) . strip () Variables log Classes sshEnvironmentControl class sshEnvironmentControl ( arguments , ** kwargs ) Ancestors (in MRO) sshConnector.sshBufferControl.sshBufferControl sshConnector.sshConnect.sshConnect Class variables arguments endSubRe escapeChars matchRe promptTextTuple ssh startSubRe Static methods processRootLogin def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' Instance variables mainEnvironment Methods becomeRoot def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment = None , ** kwargs ) -> bool Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. :param kwargs: passed on to the escalate command. :return: (bool) View Source def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False becomeUser def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This manages the current user and will either escalate or de-escalate to the requested user. :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. :param userName: (str) - This is appended with a space after the 'loginCmd' param. :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. :return: Either 'sshEnvironment' (success) or False (Failure) View Source def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : # log . debug ( \"The connection is closed!\" ) return False # Checks to see if you are attempting to become a user you already are . if userName is environment . whoami : # log . debug ( \"You are attempting to escalate to the user currently logged in as. Skipping\" ) return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too . We will only deescalate if the 'userEscalation' flag is False which is default . If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user . if userName in environment . userList : # log . debug ( \"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\" ) if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache . This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts . loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user . We 'may' attempt to retry using a # different login command . This retry depends on the \"verifyUser\" variable . try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: {e}\" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. \" f \"Trying command: {newLoginCmd}\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: {e}\" ) log . debug ( f \"[DEBUG]: {traceback.format_exc()}\" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ) : if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment . getPrompt ( reCapturePrompt = reCapturePrompt ) return channel or environment checkConnection def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed checkWhoAmI def checkWhoAmI ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. :param environment: (sshEnvironment) default None - :return: (str) View Source def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ). strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: {e}' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: {traceback.format_exc()}' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' )) consoleEscalation def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = '' , escalationInput : Optional [ str ] = None , escalationType : str = 'console' , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. Parameters: Name Type Description Default escalationCmd None (str) - The command such as sqlpluss or zsh None escalationArgs None (str) default \"\" - Additional args such as '-h localhost'. None escalationInput None (str) default None - This is used if the command will require input such as a password. None escalationType None (str) default \"console\" - This is used to record the escalation type in sshEnvironment. None escalationHook None (Callable) default None - a method to call instead of the default escalation method. None name None (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. None environment None sshEnvironment object None Returns: Type Description None Either 'sshEnvironment' (success) or False (Failure) View Source def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \" console \" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment createConn def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh disconnect def disconnect ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. :param environment: (sshEnvironment) default None - :return: None View Source def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ) : self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ). disconnect () environmentChange def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. :param: args - Passed to 'consoleEscalation' :param: kwargs - Passed to 'consoleEscalation' :return: Either 'sshEnvironment' (success) or False (Failure) View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs ) escalate def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. :param args: (tuple) - passed on :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. :param kwargs: (dict) - passed on :return: Either 'sshEnvironment' (success) or False (Failure) View Source def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( ' environment ' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False executeOnEnvironment def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output getPrompt def getPrompt ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] This captures the current prompt which is used to improve the performance of the buffer. :param environment: sshEnvironment object :return: str or None View Source def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log . debug ( f \"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\" ) if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt logoutConsole def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> bool This reverses through past environment changes until it undoes the previous console escalation. Parameters: Name Type Description Default logoutCmd None (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. None environment None (sshEnvironment/Paramiko Channel) None Returns: Type Description None View Source def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection () logoutCurrentEscalation def logoutCurrentEscalation ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] View Source def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment, bool ] : environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ) : log . info ( f \"Connection still valid on: {environment._id} - Num Escalations: {environment.numEscalations}\" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: {environment._id}\" ) return environment logoutCurrentUser def logoutCurrentUser ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. :param environment: (sshEnvironment) default None - :param junkOut: (StringIO) default None - :param reCapturePrompt: (bool) default True - :return: Either 'sshEnvironment' (success) or False (Failure) View Source def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ -2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser () : break return environment resetEnvironment def resetEnvironment ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None As noted by the name this resets the values for the sshEnvironment class. BE CAREFUL this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. Parameters: Name Type Description Default environment None (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. None Returns: Type Description None None View Source def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )() whoami def whoami ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. :param environment: (sshEnvironment) default None - :return (str) View Source def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' )","title":"Sshenvironmentcontrol"},{"location":"reference/sshEnvironmentControl/#module-sshenvironmentcontrol","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 10/13/14 # Description: This is the 4th class in the sshConnector. This is a focus on changing users in a persistent ssh # connection. It allows someone to change the user after logging in and keeps track to what user you are and have # been. import re import traceback import logging from time import sleep from io import StringIO from typing import Callable , Optional , Union from PyLinuxDiagnosticToolKit.libs import dummy_func from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import BecomeUserException , SSHExceptionChannel from sshConnector.sshBufferControl import sshBufferControl from sshConnector.sshLibs.sshChannelEnvironment import sshEnvironment log = logging . getLogger ( 'sshEnvironmentControl' ) class sshEnvironmentControl ( sshBufferControl ): # Regex's used to pull command tags. matchRe = re . compile ( r '(?<=^CMDSTART).+' , flags = re . MULTILINE | re . DOTALL ) # clean up any errors or other data that may appear before the start tag startSubRe = re . compile ( r '.*?(?=^CMDSTART)' , flags = re . MULTILINE | re . DOTALL ) # clean up all data after the end tag endSubRe = re . compile ( r 'CMDEND.*' , flags = re . MULTILINE | re . DOTALL ) def __init__ ( self , arguments , ** kwargs ): \"\"\" init function for sshEnvironmentControl. This class has methods that control the state of a shell environment that the Paramiko Channel object is connected too. It can do things such as user escalation, change shell type, export variables and so on. - :param arguments: If this is not passed then sshUserControl simply moves along to its super class sshCommand. - :param kwargs: Exists to help safely deal with inheritance. - :return: This is a __init__ class and doesn't have a return. \"\"\" super ( sshEnvironmentControl , self ) . __init__ ( arguments = arguments , ** kwargs ) self . usermap = arguments . usermap if self . checkConnection (): self . mainEnvironment . push ( \"su -\" , name = arguments . username , additionalInput = arguments . password ) self . _promptWait ( self . mainEnvironment , StringIO (), timeout = 10 , iotime = 2 ) if arguments . root : self . becomeRoot () else : self . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True ) def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( 'environment' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: { environment . _id } - Prompt: { environment . prompt } - Whoami: { environment . whoami } \" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: { environment . _id } - Prompt: { environment . prompt } - Whoami: { environment . whoami } \" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment , bool ]: \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ): # log.debug(\"The connection is closed!\") return False # Checks to see if you are attempting to become a user you already are. if userName is environment . whoami : # log.debug(\"You are attempting to escalate to the user currently logged in as. Skipping\") return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too. We will only deescalate if the 'userEscalation' flag is False which is default. If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user. if userName in environment . userList : # log.debug(\"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\") if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache. This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts. loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport () . close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user. We 'may' attempt to retry using a # different login command. This retry depends on the \"verifyUser\" variable. try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: { e } \" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: { userName } with command: { loginCmd } . Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: { userName } with command: { loginCmd } . \" f \"Trying command: { newLoginCmd } \" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: { e } \" ) log . debug ( f \"[DEBUG]: { traceback . format_exc () } \" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ): if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment.getPrompt(reCapturePrompt=reCapturePrompt) return channel or environment def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \"console\" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport () . close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs ) def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )() def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment , bool ]: environment = environment or self . mainEnvironment if not self . checkConnection ( environment ): return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ): log . info ( f \"Connection still valid on: { environment . _id } - Num Escalations: { environment . numEscalations } \" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: { environment . _id } \" ) return environment def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection () def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment , bool ]: \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ): return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ - 2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser (): break return environment def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ): self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ) . disconnect () def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' ) def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ) . strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: { e } ' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: { traceback . format_exc () } ' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' )) def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ]: \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log.debug(f\"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\") if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt def _escalateUser ( self , loginCmd : str , userName : str , loginPasswd : str , environment : sshEnvironment , verifyUser : bool , buffer : StringIO , unsafe : bool , ** kwargs ) -> sshEnvironment : \"\"\" Used as a helper function for becomeUser - :param loginCmd: (str) - :param userName: (str) - :param loginPasswd: (str) - :param environment: (sshEnvironment) - :param verifyUser: (bool) - :param buffer: (StringIO) - :param unsafe: (bool) - :param kwargs: gets passed along - :return: sshEnvironment \"\"\" kwargs . update ({ 'noUserPrompt' : self . _noUserPromptParser ( environment , ** kwargs )}) environment = self . _performEscalation ( environment , loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , buffer = buffer , unsafe = unsafe , ** kwargs ) if verifyUser : if not self . _verifyLogin ( environment , userName , buffer ): raise BecomeUserException ( f 'Unable to become user { userName } ' ) environment . push ( loginCmd , name = userName , additionalInput = loginPasswd , escalationType = 'user' ) return environment def _becomePreviousUser ( self , userName : str , buffer : StringIO , environment : sshEnvironment ) -> sshEnvironment : \"\"\" Used as a helper function for becomeUser - :param userName: (str) - :param buffer: (StringIO) - :param environment: (sshEnvironment) - :return: (sshEnvironment) \"\"\" environment = self . logoutCurrentUser ( environment , junkOut = buffer ) if userName == environment . whoami : if not self . _verifyLogin ( environment , userName = userName , out = buffer ): log . debug ( \"Failed to de-escalate to the correct user\" ) self . checkConnection ( environment ) elif userName != environment . whoami and userName in environment . userList : self . _becomePreviousUser ( userName , buffer , environment ) return environment def _performEscalation ( self , environment : sshEnvironment , loginCmd : str , loginPasswd : str , userName : str , buffer : StringIO , ** kwargs ) -> sshEnvironment : \"\"\" Used as a helper function for multiple methods within sshEnvironmentControl - :param environment: (sshEnvironment) - :param loginCmd: (str) - :param loginPasswd: (str) - :param userName: (str) - :param buffer: (StringIO) - :param kwargs: gets passed along - :return: (sshEnvironment) \"\"\" console = kwargs . get ( 'console' , False ) escalationHook = kwargs . get ( 'escalationHook' , None ) cmd = loginCmd + \" \" + userName if isinstance ( escalationHook , Callable ): self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , False ), prompt = kwargs . get ( 'prompt' , None )) escalationHook ( self , cmd , loginPasswd , environment , userName , buffer , console ) elif console is True : self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , False ), prompt = kwargs . get ( 'prompt' , None )) if loginPasswd : self . _bufferControl ( environment , loginPasswd , buffer , unsafe = True ) elif loginPasswd or 'sudo' in cmd : self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , True )) self . _insertPassword ( cmd , loginPasswd , environment , buffer , prompt = kwargs . get ( 'noUserPrompt' , None )) else : self . _bufferControl ( environment , cmd , buffer , unsafe = kwargs . get ( 'unsafe' , False )) return environment def _insertPassword ( self , cmd : str , loginPasswd : str , environment : sshEnvironment , out : StringIO , prompt : str ) -> None : \"\"\" Used as a helper function for multiple methods within sshEnvironmentControl - :param cmd: (str) - :param loginPasswd: (str) - :param environment: (sshEnvironment) - :param out: (StringIO) - :param prompt: (str) - :return: None \"\"\" if environment . whoami != 'root' : wait = self . _passwdWait ( environment , out , cmd ) lastline = sshBufferControl . _processString ( out . getvalue () . splitlines ()[ - 1 ] . strip ()) if 'assword' not in lastline and lastline . endswith ( self . promptTextTuple ): log . debug ( \"Found a prompt skipping inserting password\" ) return None if \"sudo\" in cmd : if self . arguments . password : loginPasswd = self . arguments . password if 'assword for root' in lastline : wait = True loginPasswd = self . arguments . rootpwd elif 'assword for' in lastline : wait = True requestedName = re . search ( 'assword for(.*):' , lastline ) if requestedName : requestedName = requestedName . group ( 1 ) . strip () loginPasswd = environment . getPasswordFor ( requestedName ) elif prompt in lastline or lastline . endswith ( self . promptTextTuple ): return None if wait is not False : self . _bufferControl ( environment , loginPasswd , out , unsafe = True ) self . _promptWait ( environment , out , cmd , insertNewLine = 1 ) def _verifyLogin ( self , environment : sshEnvironment , userName : str , out : StringIO ) -> bool : \"\"\" Used as a helper function for multiple methods within sshEnvironmentControl - :param environment: (sshEnvironment) - :param userName: (str) - :param out: (StringIO) - :return: bool \"\"\" if len ( out . getvalue ()) > 0 and 'assword' in out . getvalue () . splitlines ()[ - 1 ]: self . _promptWait ( environment , out , insertNewLine = 3 , timeout = 30 ) results = self . checkWhoAmI ( environment = environment ) if results is not None and userName in results : return True return False def _clearLoginAttempt ( self , environment : sshEnvironment ) -> bool : \"\"\" Used by becomeUser method - :param environment: - :return: (bool) \"\"\" try : prompt = self . _noUserPromptParser ( environment , prompt = environment . prompt , currentUser = environment . whoami ) lastline = \"\" for i in range ( 5 ): lastline = self . _noUserPromptParser ( environment , prompt = str ( self . _capturePrompt ( environment , StringIO ())), currentUser = environment . whoami ) if lastline and prompt in lastline : return True sleep ( 1 ) if lastline . strip () . endswith ( self . promptTextTuple ): return True return False except Exception as e : log . error ( f 'error in _clearLoginAttempt: { e } ' ) log . debug ( f '[DEBUG] for _clearLoginAttempt: { traceback . format_exc () } ' ) return False def _noUserPromptParser ( self , environment : sshEnvironment , prompt : Optional [ str ] = None , ** kwargs ) -> Optional [ str ]: \"\"\" Used by multiple different private helper methods. - :param environment: (sshEnvironmnet) - :param prompt: (str) default None - :param kwargs: possibly contains 'currentUser' - :return: (str/None) \"\"\" if not prompt : prompt = self . getPrompt ( environment , reCapturePrompt = False ) if not prompt : return None currentUser = kwargs . get ( 'currentUser' , environment . whoami ) or '' return str ( prompt ) . replace ( currentUser , '' ) . strip ()","title":"Module sshEnvironmentControl"},{"location":"reference/sshEnvironmentControl/#variables","text":"log","title":"Variables"},{"location":"reference/sshEnvironmentControl/#classes","text":"","title":"Classes"},{"location":"reference/sshEnvironmentControl/#sshenvironmentcontrol","text":"class sshEnvironmentControl ( arguments , ** kwargs )","title":"sshEnvironmentControl"},{"location":"reference/sshEnvironmentControl/#ancestors-in-mro","text":"sshConnector.sshBufferControl.sshBufferControl sshConnector.sshConnect.sshConnect","title":"Ancestors (in MRO)"},{"location":"reference/sshEnvironmentControl/#class-variables","text":"arguments endSubRe escapeChars matchRe promptTextTuple ssh startSubRe","title":"Class variables"},{"location":"reference/sshEnvironmentControl/#static-methods","text":"","title":"Static methods"},{"location":"reference/sshEnvironmentControl/#processrootlogin","text":"def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -'","title":"processRootLogin"},{"location":"reference/sshEnvironmentControl/#instance-variables","text":"mainEnvironment","title":"Instance variables"},{"location":"reference/sshEnvironmentControl/#methods","text":"","title":"Methods"},{"location":"reference/sshEnvironmentControl/#becomeroot","text":"def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment = None , ** kwargs ) -> bool Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. :param kwargs: passed on to the escalate command. :return: (bool) View Source def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False","title":"becomeRoot"},{"location":"reference/sshEnvironmentControl/#becomeuser","text":"def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This manages the current user and will either escalate or de-escalate to the requested user. :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. :param userName: (str) - This is appended with a space after the 'loginCmd' param. :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. :return: Either 'sshEnvironment' (success) or False (Failure) View Source def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : # log . debug ( \"The connection is closed!\" ) return False # Checks to see if you are attempting to become a user you already are . if userName is environment . whoami : # log . debug ( \"You are attempting to escalate to the user currently logged in as. Skipping\" ) return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too . We will only deescalate if the 'userEscalation' flag is False which is default . If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user . if userName in environment . userList : # log . debug ( \"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\" ) if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache . This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts . loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user . We 'may' attempt to retry using a # different login command . This retry depends on the \"verifyUser\" variable . try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: {e}\" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. \" f \"Trying command: {newLoginCmd}\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: {e}\" ) log . debug ( f \"[DEBUG]: {traceback.format_exc()}\" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ) : if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment . getPrompt ( reCapturePrompt = reCapturePrompt ) return channel or environment","title":"becomeUser"},{"location":"reference/sshEnvironmentControl/#checkconnection","text":"def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed","title":"checkConnection"},{"location":"reference/sshEnvironmentControl/#checkwhoami","text":"def checkWhoAmI ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. :param environment: (sshEnvironment) default None - :return: (str) View Source def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ). strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: {e}' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: {traceback.format_exc()}' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' ))","title":"checkWhoAmI"},{"location":"reference/sshEnvironmentControl/#consoleescalation","text":"def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = '' , escalationInput : Optional [ str ] = None , escalationType : str = 'console' , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. Parameters: Name Type Description Default escalationCmd None (str) - The command such as sqlpluss or zsh None escalationArgs None (str) default \"\" - Additional args such as '-h localhost'. None escalationInput None (str) default None - This is used if the command will require input such as a password. None escalationType None (str) default \"console\" - This is used to record the escalation type in sshEnvironment. None escalationHook None (Callable) default None - a method to call instead of the default escalation method. None name None (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. None environment None sshEnvironment object None Returns: Type Description None Either 'sshEnvironment' (success) or False (Failure) View Source def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \" console \" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment","title":"consoleEscalation"},{"location":"reference/sshEnvironmentControl/#createconn","text":"def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh","title":"createConn"},{"location":"reference/sshEnvironmentControl/#disconnect","text":"def disconnect ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. :param environment: (sshEnvironment) default None - :return: None View Source def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ) : self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ). disconnect ()","title":"disconnect"},{"location":"reference/sshEnvironmentControl/#environmentchange","text":"def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. :param: args - Passed to 'consoleEscalation' :param: kwargs - Passed to 'consoleEscalation' :return: Either 'sshEnvironment' (success) or False (Failure) View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs )","title":"environmentChange"},{"location":"reference/sshEnvironmentControl/#escalate","text":"def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. :param args: (tuple) - passed on :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. :param kwargs: (dict) - passed on :return: Either 'sshEnvironment' (success) or False (Failure) View Source def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( ' environment ' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False","title":"escalate"},{"location":"reference/sshEnvironmentControl/#executeonenvironment","text":"def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output","title":"executeOnEnvironment"},{"location":"reference/sshEnvironmentControl/#getprompt","text":"def getPrompt ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] This captures the current prompt which is used to improve the performance of the buffer. :param environment: sshEnvironment object :return: str or None View Source def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log . debug ( f \"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\" ) if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt","title":"getPrompt"},{"location":"reference/sshEnvironmentControl/#logoutconsole","text":"def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> bool This reverses through past environment changes until it undoes the previous console escalation. Parameters: Name Type Description Default logoutCmd None (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. None environment None (sshEnvironment/Paramiko Channel) None Returns: Type Description None View Source def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection ()","title":"logoutConsole"},{"location":"reference/sshEnvironmentControl/#logoutcurrentescalation","text":"def logoutCurrentEscalation ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] View Source def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment, bool ] : environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ) : log . info ( f \"Connection still valid on: {environment._id} - Num Escalations: {environment.numEscalations}\" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: {environment._id}\" ) return environment","title":"logoutCurrentEscalation"},{"location":"reference/sshEnvironmentControl/#logoutcurrentuser","text":"def logoutCurrentUser ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. :param environment: (sshEnvironment) default None - :param junkOut: (StringIO) default None - :param reCapturePrompt: (bool) default True - :return: Either 'sshEnvironment' (success) or False (Failure) View Source def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ -2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser () : break return environment","title":"logoutCurrentUser"},{"location":"reference/sshEnvironmentControl/#resetenvironment","text":"def resetEnvironment ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None As noted by the name this resets the values for the sshEnvironment class. BE CAREFUL this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. Parameters: Name Type Description Default environment None (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. None Returns: Type Description None None View Source def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )()","title":"resetEnvironment"},{"location":"reference/sshEnvironmentControl/#whoami","text":"def whoami ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. :param environment: (sshEnvironment) default None - :return (str) View Source def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' )","title":"whoami"},{"location":"reference/sshEnvironmentManager/","text":"Module sshEnvironmentManager View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 11/10/15 # Description: This is the 5th class in the sshConnector. This is to focus on creating and handling custom channels. # This file also the home of the _ChannelContainer and manages when and how to make new channels. import logging import time import traceback from threading import RLock from sshConnector.sshEnvironmentControl import sshEnvironmentControl from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from typing import Optional , Union log = logging . getLogger ( 'sshChannelManager' ) class sshEnvironmentManager ( sshEnvironmentControl ): _EnvironmentList = None _ENVIRONMENT_LIST_LOCK = None _MAX_SESSIONS = None _DEFAULT_MAX_SESSIONS = 8 _MaxSessionsString = \"if [ -f /etc/ssh/sshd_config ]; then output=$(grep -v '^#' /etc/ssh/sshd_config 2>&1 | awk \" \\ \"'/MaxSessions/ {print $2}'); if [ -z \\\" $output \\\" ]; then output=' %s '; fi; else output=' %s ';\" \\ \"fi; echo $output\" def __init__ ( self , arguments , ** kwargs ): self . _ENVIRONMENT_LIST_LOCK = RLock () super ( sshEnvironmentManager , self ) . __init__ ( arguments = arguments , ** kwargs ) self . _MAX_SESSIONS = self . getMaxSessionsValue ( maxChannels = arguments . maxChannels ) self . _EnvironmentList = [] self . addEnvironment ( self . mainEnvironment ) def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int : \"\"\" This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. - :param maxChannels: - :return: \"\"\" try : if type ( maxChannels ) is int and ( 10 >= maxChannels > 0 ): return maxChannels output = self . executeOnEnvironment ( self . mainEnvironment , self . _MaxSessionsString % ( self . _DEFAULT_MAX_SESSIONS , self . _DEFAULT_MAX_SESSIONS ), self . mainEnvironment . prompt , runTimeout = 15 ) if not output : return self . _DEFAULT_MAX_SESSIONS return int ( output . strip () . splitlines ()[ - 1 ] . strip ()) - 1 except Exception as e : log . error ( f \"error in getMaxSessionsValue: { e } \" ) log . debug ( f \"[DEBUG] for getMaxSessionsValue: { traceback . format_exc () } \" ) return self . _DEFAULT_MAX_SESSIONS def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) \\ -> Union [ bool , EnvironmentControls ]: \"\"\" This grabs the next available EnvironmentControls object or creates one. - :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. - :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. - :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False - :param wait: (int) default 60. Tells how long to wait for a channel to become available. - :param delay: (float) default 0.1. Tells how long to pause between waiting. - :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: \"\"\" try : start_time = time . time () while time . time () < start_time + wait : channelObj = self . _checkEnvironments ( autoCreate , label , EnvironmentID ) if channelObj is True : channelObj = self . createEnvironment ( label = label , ** kwargs ) if channelObj is False : time . sleep ( delay ) continue if channelObj is not None : channelObj . active = True return channelObj return False except Exception as e : log . error ( f \"ERROR in getEnvironment: There was a failure getting Channel: { e } \" ) log . debug ( f \"[DEBUG] for getEnvironment: { traceback . format_exc () } \" ) def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Used to create a new channel. - :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. - :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel - :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. - :param kwargs: - :return: \"\"\" if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be made as there already are too many channels\" ) return False autoAdd = kwargs . pop ( 'autoAdd' , True ) EnvObj = self . _openChannel ( self . mainEnvironment . get_transport ()) EnvObj . label = kwargs . get ( 'label' , '' ) EnvObj . push ( \"su -\" , name = self . arguments . username , additionalInput = self . arguments . password ) if self . arguments . root : EnvObj . becomeRoot () else : EnvObj . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) if autoAdd : self . addEnvironment ( EnvObj ) return EnvObj def addEnvironment ( self , channel : EnvironmentControls , ** kwargs ) -> bool : \"\"\" Adds a provided channel to the channel manager. - :param channel: (Channel) default None. - :param kwargs: passed into a new _ChannelObject if one is created. - :return: (bool) \"\"\" try : if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be added as there already are too many channels\" ) return False self . EnvironmentList . append ( channel ) return True except Exception as e : log . error ( f \"ERROR: There was a failure in addEnvironment: { e } \" ) log . debug ( f \"[DEBUG] for addEnvironment: { traceback . format_exc () } \" ) return False def removeEnvironment ( self , channel : EnvironmentControls ) -> Optional [ bool ]: \"\"\" Removed the provided object. - :param channel: (_ChannelObject) - :return: \"\"\" try : if channel in self . _EnvironmentList : self . _EnvironmentList . remove ( channel ) return True else : log . debug ( \"Channel %s appears to have already been removed!\" % channel . EnvironmentID ) return None except Exception as e : log . error ( \"ERROR: There was a failure in removeEnvironment: %s \" % e ) log . error ( \"The failure is associated with channel: %s \" % channel . EnvironmentID ) return False def disconnectEnvironments ( self ) -> None : \"\"\" Disconnects all Environments. Used as a single thread alternative to 'threadedDisconnect' from 'sshThreader' - :return: \"\"\" with self . _ENVIRONMENT_LIST_LOCK : for environment in [ env for env in self . EnvironmentList if not env . isMain ]: environment . disconnectEnvironment () self . mainEnvironment . disconnectEnvironment () def _checkMaxSessions ( self , ** kwargs ) -> bool : \"\"\" This parses maxChannels out of kwargs for some methods. - :param kwargs: - :return: \"\"\" maxChannels = kwargs . pop ( 'maxChannels' , self . _MAX_SESSIONS ) or self . _MAX_SESSIONS return not self . EnvironmentCount >= maxChannels def _checkEnvironments ( self , autoCreate : Optional [ bool ] = True , label : Optional [ str ] = None , EnvironmentID : Optional [ str ] = None ) -> Optional [ Union [ bool , EnvironmentControls ]]: \"\"\" This is the work horse of this class. This finds what is available. - :param autoCreate: (bool) default True. This is parsed based on label and channelID. It is set to False if either label or channelID are not None. Then this is variable is returned if this method cannot find a _ChannelContainer. - :param label: (str) default None. If label is found then this will look exclusively for a _ChannelContainer with that label. - :param EnvironmentID: (str) default None. If EnvironmentID is found then this will look exclusively for a EnvironmentControls with that EnvironmentID. - :return: either a EnvironmentControls or autoCreate \"\"\" autoCreate = autoCreate and ( EnvironmentID is None ) def labelFilter ( envObj ): return label == envObj . label def EnvironmentIDFilter ( envObj ): return EnvironmentID == envObj . EnvironmentID def activeCustomFilter ( envObj ): return not envObj . active and not envObj . customChannel def justActiveFilter ( envObj ): return not envObj . active def popChannel ( envObj ) -> Optional [ Union [ bool , EnvironmentControls ]]: if len ( envObj ) < 1 : return autoCreate envObj = envObj [ 0 ] envObj . active = True return envObj with self . _ENVIRONMENT_LIST_LOCK : if label is not None or EnvironmentID is not None : if EnvironmentID : envObject = list ( filter ( EnvironmentIDFilter , self . _EnvironmentList )) else : envObject = list ( filter ( labelFilter , self . _EnvironmentList )) if not envObject : return autoCreate or None return popChannel ( list ( filter ( justActiveFilter , envObject ))) return popChannel ( list ( filter ( activeCustomFilter , self . _EnvironmentList ))) @property def EnvironmentCount ( self ): with self . _ENVIRONMENT_LIST_LOCK : return len ( self . _EnvironmentList ) @property def EnvironmentList ( self ): with self . _ENVIRONMENT_LIST_LOCK : return self . _EnvironmentList Variables log Classes sshEnvironmentManager class sshEnvironmentManager ( arguments , ** kwargs ) Ancestors (in MRO) sshConnector.sshEnvironmentControl.sshEnvironmentControl sshConnector.sshBufferControl.sshBufferControl sshConnector.sshConnect.sshConnect Class variables arguments endSubRe escapeChars matchRe promptTextTuple ssh startSubRe Static methods processRootLogin def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' Instance variables EnvironmentCount EnvironmentList mainEnvironment Methods addEnvironment def addEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , ** kwargs ) -> bool Adds a provided channel to the channel manager. :param channel: (Channel) default None. :param kwargs: passed into a new _ChannelObject if one is created. :return: (bool) View Source def addEnvironment ( self , channel : EnvironmentControls , ** kwargs ) -> bool : \"\"\" Adds a provided channel to the channel manager. - :param channel: (Channel) default None. - :param kwargs: passed into a new _ChannelObject if one is created. - :return: (bool) \"\"\" try : if not self . _checkMaxSessions ( ** kwargs ) : log . debug ( \"A new channel cannot be added as there already are too many channels\" ) return False self . EnvironmentList . append ( channel ) return True except Exception as e : log . error ( f \"ERROR: There was a failure in addEnvironment: {e}\" ) log . debug ( f \"[DEBUG] for addEnvironment: {traceback.format_exc()}\" ) return False becomeRoot def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment = None , ** kwargs ) -> bool Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. :param kwargs: passed on to the escalate command. :return: (bool) View Source def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False becomeUser def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This manages the current user and will either escalate or de-escalate to the requested user. :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. :param userName: (str) - This is appended with a space after the 'loginCmd' param. :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. :return: Either 'sshEnvironment' (success) or False (Failure) View Source def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : # log . debug ( \"The connection is closed!\" ) return False # Checks to see if you are attempting to become a user you already are . if userName is environment . whoami : # log . debug ( \"You are attempting to escalate to the user currently logged in as. Skipping\" ) return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too . We will only deescalate if the 'userEscalation' flag is False which is default . If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user . if userName in environment . userList : # log . debug ( \"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\" ) if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache . This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts . loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user . We 'may' attempt to retry using a # different login command . This retry depends on the \"verifyUser\" variable . try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: {e}\" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. \" f \"Trying command: {newLoginCmd}\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: {e}\" ) log . debug ( f \"[DEBUG]: {traceback.format_exc()}\" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ) : if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment . getPrompt ( reCapturePrompt = reCapturePrompt ) return channel or environment checkConnection def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed checkWhoAmI def checkWhoAmI ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. :param environment: (sshEnvironment) default None - :return: (str) View Source def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ). strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: {e}' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: {traceback.format_exc()}' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' )) consoleEscalation def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = '' , escalationInput : Optional [ str ] = None , escalationType : str = 'console' , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. Parameters: Name Type Description Default escalationCmd None (str) - The command such as sqlpluss or zsh None escalationArgs None (str) default \"\" - Additional args such as '-h localhost'. None escalationInput None (str) default None - This is used if the command will require input such as a password. None escalationType None (str) default \"console\" - This is used to record the escalation type in sshEnvironment. None escalationHook None (Callable) default None - a method to call instead of the default escalation method. None name None (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. None environment None sshEnvironment object None Returns: Type Description None Either 'sshEnvironment' (success) or False (Failure) View Source def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \" console \" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment createConn def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh createEnvironment def createEnvironment ( self , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Used to create a new channel. :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. :param kwargs: :return: View Source def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Used to create a new channel. - :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. - :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel - :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. - :param kwargs: - :return: \"\"\" if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be made as there already are too many channels\" ) return False autoAdd = kwargs . pop ( 'autoAdd' , True ) EnvObj = self . _openChannel ( self . mainEnvironment . get_transport ()) EnvObj . label = kwargs . get ( 'label' , '' ) EnvObj . push ( \"su -\" , name = self . arguments . username , additionalInput = self . arguments . password ) if self . arguments . root : EnvObj . becomeRoot () else : EnvObj . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) if autoAdd : self . addEnvironment ( EnvObj ) return EnvObj disconnect def disconnect ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. :param environment: (sshEnvironment) default None - :return: None View Source def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ) : self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ). disconnect () disconnectEnvironments def disconnectEnvironments ( self ) -> None Disconnects all Environments. Used as a single thread alternative to 'threadedDisconnect' from 'sshThreader' :return: View Source def disconnectEnvironments ( self ) -> None : \"\"\" Disconnects all Environments. Used as a single thread alternative to ' threadedDisconnect ' from ' sshThreader ' - :return: \"\"\" with self . _ENVIRONMENT_LIST_LOCK : for environment in [ env for env in self . EnvironmentList if not env . isMain ] : environment . disconnectEnvironment () self . mainEnvironment . disconnectEnvironment () environmentChange def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. :param: args - Passed to 'consoleEscalation' :param: kwargs - Passed to 'consoleEscalation' :return: Either 'sshEnvironment' (success) or False (Failure) View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs ) escalate def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. :param args: (tuple) - passed on :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. :param kwargs: (dict) - passed on :return: Either 'sshEnvironment' (success) or False (Failure) View Source def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( ' environment ' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False executeOnEnvironment def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output getEnvironment def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] This grabs the next available EnvironmentControls object or creates one. :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False :param wait: (int) default 60. Tells how long to wait for a channel to become available. :param delay: (float) default 0.1. Tells how long to pause between waiting. :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: View Source def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) \\ -> Union [ bool, EnvironmentControls ] : \"\"\" This grabs the next available EnvironmentControls object or creates one. - :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. - :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. - :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False - :param wait: (int) default 60. Tells how long to wait for a channel to become available. - :param delay: (float) default 0.1. Tells how long to pause between waiting. - :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: \"\"\" try : start_time = time . time () while time . time () < start_time + wait : channelObj = self . _checkEnvironments ( autoCreate , label , EnvironmentID ) if channelObj is True : channelObj = self . createEnvironment ( label = label , ** kwargs ) if channelObj is False : time . sleep ( delay ) continue if channelObj is not None : channelObj . active = True return channelObj return False except Exception as e : log . error ( f \"ERROR in getEnvironment: There was a failure getting Channel: {e}\" ) log . debug ( f \"[DEBUG] for getEnvironment: {traceback.format_exc()}\" ) getMaxSessionsValue def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. :param maxChannels: :return: View Source def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int : \"\"\" This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. - :param maxChannels: - :return: \"\"\" try : if type ( maxChannels ) is int and ( 10 >= maxChannels > 0 ) : return maxChannels output = self . executeOnEnvironment ( self . mainEnvironment , self . _MaxSessionsString % ( self . _DEFAULT_MAX_SESSIONS , self . _DEFAULT_MAX_SESSIONS ), self . mainEnvironment . prompt , runTimeout = 15 ) if not output : return self . _DEFAULT_MAX_SESSIONS return int ( output . strip (). splitlines () [ -1 ] . strip ()) - 1 except Exception as e : log . error ( f \"error in getMaxSessionsValue: {e}\" ) log . debug ( f \"[DEBUG] for getMaxSessionsValue: {traceback.format_exc()}\" ) return self . _DEFAULT_MAX_SESSIONS getPrompt def getPrompt ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] This captures the current prompt which is used to improve the performance of the buffer. :param environment: sshEnvironment object :return: str or None View Source def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log . debug ( f \"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\" ) if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt logoutConsole def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> bool This reverses through past environment changes until it undoes the previous console escalation. Parameters: Name Type Description Default logoutCmd None (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. None environment None (sshEnvironment/Paramiko Channel) None Returns: Type Description None View Source def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection () logoutCurrentEscalation def logoutCurrentEscalation ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] View Source def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment, bool ] : environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ) : log . info ( f \"Connection still valid on: {environment._id} - Num Escalations: {environment.numEscalations}\" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: {environment._id}\" ) return environment logoutCurrentUser def logoutCurrentUser ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. :param environment: (sshEnvironment) default None - :param junkOut: (StringIO) default None - :param reCapturePrompt: (bool) default True - :return: Either 'sshEnvironment' (success) or False (Failure) View Source def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ -2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser () : break return environment removeEnvironment def removeEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ) -> Optional [ bool ] Removed the provided object. :param channel: (_ChannelObject) :return: View Source def removeEnvironment ( self , channel : EnvironmentControls ) -> Optional [ bool ] : \"\"\" Removed the provided object. - :param channel: (_ChannelObject) - :return: \"\"\" try : if channel in self . _EnvironmentList : self . _EnvironmentList . remove ( channel ) return True else : log . debug ( \"Channel %s appears to have already been removed!\" % channel . EnvironmentID ) return None except Exception as e : log . error ( \"ERROR: There was a failure in removeEnvironment: %s\" % e ) log . error ( \"The failure is associated with channel: %s\" % channel . EnvironmentID ) return False resetEnvironment def resetEnvironment ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None As noted by the name this resets the values for the sshEnvironment class. BE CAREFUL this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. Parameters: Name Type Description Default environment None (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. None Returns: Type Description None None View Source def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )() whoami def whoami ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. :param environment: (sshEnvironment) default None - :return (str) View Source def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' )","title":"Sshenvironmentmanager"},{"location":"reference/sshEnvironmentManager/#module-sshenvironmentmanager","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 11/10/15 # Description: This is the 5th class in the sshConnector. This is to focus on creating and handling custom channels. # This file also the home of the _ChannelContainer and manages when and how to make new channels. import logging import time import traceback from threading import RLock from sshConnector.sshEnvironmentControl import sshEnvironmentControl from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from typing import Optional , Union log = logging . getLogger ( 'sshChannelManager' ) class sshEnvironmentManager ( sshEnvironmentControl ): _EnvironmentList = None _ENVIRONMENT_LIST_LOCK = None _MAX_SESSIONS = None _DEFAULT_MAX_SESSIONS = 8 _MaxSessionsString = \"if [ -f /etc/ssh/sshd_config ]; then output=$(grep -v '^#' /etc/ssh/sshd_config 2>&1 | awk \" \\ \"'/MaxSessions/ {print $2}'); if [ -z \\\" $output \\\" ]; then output=' %s '; fi; else output=' %s ';\" \\ \"fi; echo $output\" def __init__ ( self , arguments , ** kwargs ): self . _ENVIRONMENT_LIST_LOCK = RLock () super ( sshEnvironmentManager , self ) . __init__ ( arguments = arguments , ** kwargs ) self . _MAX_SESSIONS = self . getMaxSessionsValue ( maxChannels = arguments . maxChannels ) self . _EnvironmentList = [] self . addEnvironment ( self . mainEnvironment ) def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int : \"\"\" This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. - :param maxChannels: - :return: \"\"\" try : if type ( maxChannels ) is int and ( 10 >= maxChannels > 0 ): return maxChannels output = self . executeOnEnvironment ( self . mainEnvironment , self . _MaxSessionsString % ( self . _DEFAULT_MAX_SESSIONS , self . _DEFAULT_MAX_SESSIONS ), self . mainEnvironment . prompt , runTimeout = 15 ) if not output : return self . _DEFAULT_MAX_SESSIONS return int ( output . strip () . splitlines ()[ - 1 ] . strip ()) - 1 except Exception as e : log . error ( f \"error in getMaxSessionsValue: { e } \" ) log . debug ( f \"[DEBUG] for getMaxSessionsValue: { traceback . format_exc () } \" ) return self . _DEFAULT_MAX_SESSIONS def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) \\ -> Union [ bool , EnvironmentControls ]: \"\"\" This grabs the next available EnvironmentControls object or creates one. - :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. - :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. - :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False - :param wait: (int) default 60. Tells how long to wait for a channel to become available. - :param delay: (float) default 0.1. Tells how long to pause between waiting. - :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: \"\"\" try : start_time = time . time () while time . time () < start_time + wait : channelObj = self . _checkEnvironments ( autoCreate , label , EnvironmentID ) if channelObj is True : channelObj = self . createEnvironment ( label = label , ** kwargs ) if channelObj is False : time . sleep ( delay ) continue if channelObj is not None : channelObj . active = True return channelObj return False except Exception as e : log . error ( f \"ERROR in getEnvironment: There was a failure getting Channel: { e } \" ) log . debug ( f \"[DEBUG] for getEnvironment: { traceback . format_exc () } \" ) def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Used to create a new channel. - :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. - :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel - :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. - :param kwargs: - :return: \"\"\" if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be made as there already are too many channels\" ) return False autoAdd = kwargs . pop ( 'autoAdd' , True ) EnvObj = self . _openChannel ( self . mainEnvironment . get_transport ()) EnvObj . label = kwargs . get ( 'label' , '' ) EnvObj . push ( \"su -\" , name = self . arguments . username , additionalInput = self . arguments . password ) if self . arguments . root : EnvObj . becomeRoot () else : EnvObj . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) if autoAdd : self . addEnvironment ( EnvObj ) return EnvObj def addEnvironment ( self , channel : EnvironmentControls , ** kwargs ) -> bool : \"\"\" Adds a provided channel to the channel manager. - :param channel: (Channel) default None. - :param kwargs: passed into a new _ChannelObject if one is created. - :return: (bool) \"\"\" try : if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be added as there already are too many channels\" ) return False self . EnvironmentList . append ( channel ) return True except Exception as e : log . error ( f \"ERROR: There was a failure in addEnvironment: { e } \" ) log . debug ( f \"[DEBUG] for addEnvironment: { traceback . format_exc () } \" ) return False def removeEnvironment ( self , channel : EnvironmentControls ) -> Optional [ bool ]: \"\"\" Removed the provided object. - :param channel: (_ChannelObject) - :return: \"\"\" try : if channel in self . _EnvironmentList : self . _EnvironmentList . remove ( channel ) return True else : log . debug ( \"Channel %s appears to have already been removed!\" % channel . EnvironmentID ) return None except Exception as e : log . error ( \"ERROR: There was a failure in removeEnvironment: %s \" % e ) log . error ( \"The failure is associated with channel: %s \" % channel . EnvironmentID ) return False def disconnectEnvironments ( self ) -> None : \"\"\" Disconnects all Environments. Used as a single thread alternative to 'threadedDisconnect' from 'sshThreader' - :return: \"\"\" with self . _ENVIRONMENT_LIST_LOCK : for environment in [ env for env in self . EnvironmentList if not env . isMain ]: environment . disconnectEnvironment () self . mainEnvironment . disconnectEnvironment () def _checkMaxSessions ( self , ** kwargs ) -> bool : \"\"\" This parses maxChannels out of kwargs for some methods. - :param kwargs: - :return: \"\"\" maxChannels = kwargs . pop ( 'maxChannels' , self . _MAX_SESSIONS ) or self . _MAX_SESSIONS return not self . EnvironmentCount >= maxChannels def _checkEnvironments ( self , autoCreate : Optional [ bool ] = True , label : Optional [ str ] = None , EnvironmentID : Optional [ str ] = None ) -> Optional [ Union [ bool , EnvironmentControls ]]: \"\"\" This is the work horse of this class. This finds what is available. - :param autoCreate: (bool) default True. This is parsed based on label and channelID. It is set to False if either label or channelID are not None. Then this is variable is returned if this method cannot find a _ChannelContainer. - :param label: (str) default None. If label is found then this will look exclusively for a _ChannelContainer with that label. - :param EnvironmentID: (str) default None. If EnvironmentID is found then this will look exclusively for a EnvironmentControls with that EnvironmentID. - :return: either a EnvironmentControls or autoCreate \"\"\" autoCreate = autoCreate and ( EnvironmentID is None ) def labelFilter ( envObj ): return label == envObj . label def EnvironmentIDFilter ( envObj ): return EnvironmentID == envObj . EnvironmentID def activeCustomFilter ( envObj ): return not envObj . active and not envObj . customChannel def justActiveFilter ( envObj ): return not envObj . active def popChannel ( envObj ) -> Optional [ Union [ bool , EnvironmentControls ]]: if len ( envObj ) < 1 : return autoCreate envObj = envObj [ 0 ] envObj . active = True return envObj with self . _ENVIRONMENT_LIST_LOCK : if label is not None or EnvironmentID is not None : if EnvironmentID : envObject = list ( filter ( EnvironmentIDFilter , self . _EnvironmentList )) else : envObject = list ( filter ( labelFilter , self . _EnvironmentList )) if not envObject : return autoCreate or None return popChannel ( list ( filter ( justActiveFilter , envObject ))) return popChannel ( list ( filter ( activeCustomFilter , self . _EnvironmentList ))) @property def EnvironmentCount ( self ): with self . _ENVIRONMENT_LIST_LOCK : return len ( self . _EnvironmentList ) @property def EnvironmentList ( self ): with self . _ENVIRONMENT_LIST_LOCK : return self . _EnvironmentList","title":"Module sshEnvironmentManager"},{"location":"reference/sshEnvironmentManager/#variables","text":"log","title":"Variables"},{"location":"reference/sshEnvironmentManager/#classes","text":"","title":"Classes"},{"location":"reference/sshEnvironmentManager/#sshenvironmentmanager","text":"class sshEnvironmentManager ( arguments , ** kwargs )","title":"sshEnvironmentManager"},{"location":"reference/sshEnvironmentManager/#ancestors-in-mro","text":"sshConnector.sshEnvironmentControl.sshEnvironmentControl sshConnector.sshBufferControl.sshBufferControl sshConnector.sshConnect.sshConnect","title":"Ancestors (in MRO)"},{"location":"reference/sshEnvironmentManager/#class-variables","text":"arguments endSubRe escapeChars matchRe promptTextTuple ssh startSubRe","title":"Class variables"},{"location":"reference/sshEnvironmentManager/#static-methods","text":"","title":"Static methods"},{"location":"reference/sshEnvironmentManager/#processrootlogin","text":"def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -'","title":"processRootLogin"},{"location":"reference/sshEnvironmentManager/#instance-variables","text":"EnvironmentCount EnvironmentList mainEnvironment","title":"Instance variables"},{"location":"reference/sshEnvironmentManager/#methods","text":"","title":"Methods"},{"location":"reference/sshEnvironmentManager/#addenvironment","text":"def addEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , ** kwargs ) -> bool Adds a provided channel to the channel manager. :param channel: (Channel) default None. :param kwargs: passed into a new _ChannelObject if one is created. :return: (bool) View Source def addEnvironment ( self , channel : EnvironmentControls , ** kwargs ) -> bool : \"\"\" Adds a provided channel to the channel manager. - :param channel: (Channel) default None. - :param kwargs: passed into a new _ChannelObject if one is created. - :return: (bool) \"\"\" try : if not self . _checkMaxSessions ( ** kwargs ) : log . debug ( \"A new channel cannot be added as there already are too many channels\" ) return False self . EnvironmentList . append ( channel ) return True except Exception as e : log . error ( f \"ERROR: There was a failure in addEnvironment: {e}\" ) log . debug ( f \"[DEBUG] for addEnvironment: {traceback.format_exc()}\" ) return False","title":"addEnvironment"},{"location":"reference/sshEnvironmentManager/#becomeroot","text":"def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment = None , ** kwargs ) -> bool Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. :param kwargs: passed on to the escalate command. :return: (bool) View Source def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False","title":"becomeRoot"},{"location":"reference/sshEnvironmentManager/#becomeuser","text":"def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This manages the current user and will either escalate or de-escalate to the requested user. :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. :param userName: (str) - This is appended with a space after the 'loginCmd' param. :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. :return: Either 'sshEnvironment' (success) or False (Failure) View Source def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : # log . debug ( \"The connection is closed!\" ) return False # Checks to see if you are attempting to become a user you already are . if userName is environment . whoami : # log . debug ( \"You are attempting to escalate to the user currently logged in as. Skipping\" ) return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too . We will only deescalate if the 'userEscalation' flag is False which is default . If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user . if userName in environment . userList : # log . debug ( \"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\" ) if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache . This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts . loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user . We 'may' attempt to retry using a # different login command . This retry depends on the \"verifyUser\" variable . try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: {e}\" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. \" f \"Trying command: {newLoginCmd}\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: {e}\" ) log . debug ( f \"[DEBUG]: {traceback.format_exc()}\" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ) : if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment . getPrompt ( reCapturePrompt = reCapturePrompt ) return channel or environment","title":"becomeUser"},{"location":"reference/sshEnvironmentManager/#checkconnection","text":"def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed","title":"checkConnection"},{"location":"reference/sshEnvironmentManager/#checkwhoami","text":"def checkWhoAmI ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. :param environment: (sshEnvironment) default None - :return: (str) View Source def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ). strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: {e}' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: {traceback.format_exc()}' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' ))","title":"checkWhoAmI"},{"location":"reference/sshEnvironmentManager/#consoleescalation","text":"def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = '' , escalationInput : Optional [ str ] = None , escalationType : str = 'console' , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. Parameters: Name Type Description Default escalationCmd None (str) - The command such as sqlpluss or zsh None escalationArgs None (str) default \"\" - Additional args such as '-h localhost'. None escalationInput None (str) default None - This is used if the command will require input such as a password. None escalationType None (str) default \"console\" - This is used to record the escalation type in sshEnvironment. None escalationHook None (Callable) default None - a method to call instead of the default escalation method. None name None (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. None environment None sshEnvironment object None Returns: Type Description None Either 'sshEnvironment' (success) or False (Failure) View Source def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \" console \" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment","title":"consoleEscalation"},{"location":"reference/sshEnvironmentManager/#createconn","text":"def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh","title":"createConn"},{"location":"reference/sshEnvironmentManager/#createenvironment","text":"def createEnvironment ( self , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Used to create a new channel. :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. :param kwargs: :return: View Source def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Used to create a new channel. - :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. - :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel - :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. - :param kwargs: - :return: \"\"\" if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be made as there already are too many channels\" ) return False autoAdd = kwargs . pop ( 'autoAdd' , True ) EnvObj = self . _openChannel ( self . mainEnvironment . get_transport ()) EnvObj . label = kwargs . get ( 'label' , '' ) EnvObj . push ( \"su -\" , name = self . arguments . username , additionalInput = self . arguments . password ) if self . arguments . root : EnvObj . becomeRoot () else : EnvObj . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) if autoAdd : self . addEnvironment ( EnvObj ) return EnvObj","title":"createEnvironment"},{"location":"reference/sshEnvironmentManager/#disconnect","text":"def disconnect ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. :param environment: (sshEnvironment) default None - :return: None View Source def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ) : self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ). disconnect ()","title":"disconnect"},{"location":"reference/sshEnvironmentManager/#disconnectenvironments","text":"def disconnectEnvironments ( self ) -> None Disconnects all Environments. Used as a single thread alternative to 'threadedDisconnect' from 'sshThreader' :return: View Source def disconnectEnvironments ( self ) -> None : \"\"\" Disconnects all Environments. Used as a single thread alternative to ' threadedDisconnect ' from ' sshThreader ' - :return: \"\"\" with self . _ENVIRONMENT_LIST_LOCK : for environment in [ env for env in self . EnvironmentList if not env . isMain ] : environment . disconnectEnvironment () self . mainEnvironment . disconnectEnvironment ()","title":"disconnectEnvironments"},{"location":"reference/sshEnvironmentManager/#environmentchange","text":"def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. :param: args - Passed to 'consoleEscalation' :param: kwargs - Passed to 'consoleEscalation' :return: Either 'sshEnvironment' (success) or False (Failure) View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs )","title":"environmentChange"},{"location":"reference/sshEnvironmentManager/#escalate","text":"def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. :param args: (tuple) - passed on :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. :param kwargs: (dict) - passed on :return: Either 'sshEnvironment' (success) or False (Failure) View Source def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( ' environment ' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False","title":"escalate"},{"location":"reference/sshEnvironmentManager/#executeonenvironment","text":"def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output","title":"executeOnEnvironment"},{"location":"reference/sshEnvironmentManager/#getenvironment","text":"def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] This grabs the next available EnvironmentControls object or creates one. :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False :param wait: (int) default 60. Tells how long to wait for a channel to become available. :param delay: (float) default 0.1. Tells how long to pause between waiting. :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: View Source def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) \\ -> Union [ bool, EnvironmentControls ] : \"\"\" This grabs the next available EnvironmentControls object or creates one. - :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. - :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. - :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False - :param wait: (int) default 60. Tells how long to wait for a channel to become available. - :param delay: (float) default 0.1. Tells how long to pause between waiting. - :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: \"\"\" try : start_time = time . time () while time . time () < start_time + wait : channelObj = self . _checkEnvironments ( autoCreate , label , EnvironmentID ) if channelObj is True : channelObj = self . createEnvironment ( label = label , ** kwargs ) if channelObj is False : time . sleep ( delay ) continue if channelObj is not None : channelObj . active = True return channelObj return False except Exception as e : log . error ( f \"ERROR in getEnvironment: There was a failure getting Channel: {e}\" ) log . debug ( f \"[DEBUG] for getEnvironment: {traceback.format_exc()}\" )","title":"getEnvironment"},{"location":"reference/sshEnvironmentManager/#getmaxsessionsvalue","text":"def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. :param maxChannels: :return: View Source def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int : \"\"\" This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. - :param maxChannels: - :return: \"\"\" try : if type ( maxChannels ) is int and ( 10 >= maxChannels > 0 ) : return maxChannels output = self . executeOnEnvironment ( self . mainEnvironment , self . _MaxSessionsString % ( self . _DEFAULT_MAX_SESSIONS , self . _DEFAULT_MAX_SESSIONS ), self . mainEnvironment . prompt , runTimeout = 15 ) if not output : return self . _DEFAULT_MAX_SESSIONS return int ( output . strip (). splitlines () [ -1 ] . strip ()) - 1 except Exception as e : log . error ( f \"error in getMaxSessionsValue: {e}\" ) log . debug ( f \"[DEBUG] for getMaxSessionsValue: {traceback.format_exc()}\" ) return self . _DEFAULT_MAX_SESSIONS","title":"getMaxSessionsValue"},{"location":"reference/sshEnvironmentManager/#getprompt","text":"def getPrompt ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] This captures the current prompt which is used to improve the performance of the buffer. :param environment: sshEnvironment object :return: str or None View Source def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log . debug ( f \"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\" ) if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt","title":"getPrompt"},{"location":"reference/sshEnvironmentManager/#logoutconsole","text":"def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> bool This reverses through past environment changes until it undoes the previous console escalation. Parameters: Name Type Description Default logoutCmd None (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. None environment None (sshEnvironment/Paramiko Channel) None Returns: Type Description None View Source def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection ()","title":"logoutConsole"},{"location":"reference/sshEnvironmentManager/#logoutcurrentescalation","text":"def logoutCurrentEscalation ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] View Source def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment, bool ] : environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ) : log . info ( f \"Connection still valid on: {environment._id} - Num Escalations: {environment.numEscalations}\" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: {environment._id}\" ) return environment","title":"logoutCurrentEscalation"},{"location":"reference/sshEnvironmentManager/#logoutcurrentuser","text":"def logoutCurrentUser ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. :param environment: (sshEnvironment) default None - :param junkOut: (StringIO) default None - :param reCapturePrompt: (bool) default True - :return: Either 'sshEnvironment' (success) or False (Failure) View Source def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ -2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser () : break return environment","title":"logoutCurrentUser"},{"location":"reference/sshEnvironmentManager/#removeenvironment","text":"def removeEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ) -> Optional [ bool ] Removed the provided object. :param channel: (_ChannelObject) :return: View Source def removeEnvironment ( self , channel : EnvironmentControls ) -> Optional [ bool ] : \"\"\" Removed the provided object. - :param channel: (_ChannelObject) - :return: \"\"\" try : if channel in self . _EnvironmentList : self . _EnvironmentList . remove ( channel ) return True else : log . debug ( \"Channel %s appears to have already been removed!\" % channel . EnvironmentID ) return None except Exception as e : log . error ( \"ERROR: There was a failure in removeEnvironment: %s\" % e ) log . error ( \"The failure is associated with channel: %s\" % channel . EnvironmentID ) return False","title":"removeEnvironment"},{"location":"reference/sshEnvironmentManager/#resetenvironment","text":"def resetEnvironment ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None As noted by the name this resets the values for the sshEnvironment class. BE CAREFUL this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. Parameters: Name Type Description Default environment None (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. None Returns: Type Description None None View Source def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )()","title":"resetEnvironment"},{"location":"reference/sshEnvironmentManager/#whoami","text":"def whoami ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. :param environment: (sshEnvironment) default None - :return (str) View Source def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' )","title":"whoami"},{"location":"reference/sshThreader/","text":"Module sshThreader View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 02/19/15 # Description: This is the 6th class in the sshConnect chain. Technically the last in this change. The next class to # inherent this class should be CommandRunner which no longer focuses on anything regarding SSH. This file has two # classes. The public class 'sshThreader' and a private class '_createThread'. The sshThreader should be the only # class called. # A requirement for portray # import sys # sys.path.append('/home/rye/PycharmProjects/PyCustomCollections') # sys.path.append('/home/rye/PycharmProjects/PyCustomParsers') # sys.path.append('/home/rye/PycharmProjects/PyMultiTasking') import logging import traceback from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import SSHExceptionChannel # A requirement for portray try : from LinuxModules.CommandContainers import CommandContainer except : from ldtk import CommandContainer from sshConnector.sshEnvironmentManager import sshEnvironmentManager from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from PyMultiTasking.ThreadingUtils import ThreadPool as Pool from typing import Optional , Union , Any from time import time # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.INFO) log = logging . getLogger ( 'SSHThreader' ) class sshThreader ( sshEnvironmentManager ): threadDict = {} tPool = None tki = None def __init__ ( self , arguments , ** kwargs ): \"\"\" This class is designed to managed another private class that inherits from Thread. The __init__ only job is to build and pass info along to the rest of the chain while overriding the root flag in args to avoid unnecessary work. - :param arguments: Passed along super to sshEnvironmentManager's construct. - :param kwargs: A placeholder for inheritance. \"\"\" super ( sshThreader , self ) . __init__ ( arguments = arguments , ** kwargs ) self . tki = kwargs . pop ( 'tki' , None ) self . tPool = Pool ( maxWorkers = self . _MAX_SESSIONS * 2 , workerAutoKill = False ) def isIdle ( self ) -> bool : \"\"\" This checks the 'ThreadPool' class's 'isIdle()' function and returns the results. - :return: bool \"\"\" return self . tPool . is_idle def waitForIdle ( self , ** kwargs ) -> bool : \"\"\" This is a wrapper for the 'waitCompletion' method in ThreadingPool. - :param kwargs: Review the 'waitCompletion' method in ThreadingPool for all the arguments. - :return: (bool) \"\"\" return self . tPool . wait_completion ( ** kwargs ) def executeOnThread ( self , cmd : Union [ CommandContainer , Any ], EnvObj : Optional [ EnvironmentControls ] = None , ** kwargs ) -> CommandContainer : \"\"\" Submits a new command to be executed via the 'submit' method in Pool. All commands ran should be within a CommandContainer. So the method first checks to see if the command is already a Container or not. - :param CC: [Either a CommandContainer or Any other datatype] - :param EnvObj: (EnvironmentControls) default None. This specifies a Channel to run the command on. This bypasses using a Thread and instead expects that the channelObject is already 'active' or 'taken' by the thread currently calling this method. - :param kwargs: used to create a new CommandContainer is 'cmd' is not a CommandContainer - :return: CommandContainer (The same container that either was submitted as the cmd or the one created) \"\"\" def _preparserCmd ( commands , ** kwargs ): if isinstance ( commands , CommandContainer ): return commands if 'commandKey' not in kwargs : kwargs [ 'commandKey' ] = None if 'tki' not in kwargs and self . tki is not None : kwargs [ 'tki' ] = self . tki return CommandContainer ( commands , ** kwargs ) CC = _preparserCmd ( cmd , ** kwargs ) if EnvObj is None : self . tPool . submit ( fn = self . _exeThread , CC = CC , submit_task_priority = CC . __PRIORITY__ ) return CC else : if not EnvObj . active : log . warning ( \"This channel is not active and it has been manually requested for use by the executor!\" ) with CC : return CC . executor ( EnvironmentObject = EnvObj ) def threadedDisconnect ( self , wait : int = 90 ) -> None : \"\"\" This does what it says. It disconnects the SSH connection to a server using a thread for each Environment. This is not necessary faster. In fact it is often slower. This is designed if there are many connections open that have many user and environment escalations. In that situation this becomes faster then 'disconnectEnvironments'. However, this is necessary to ensure that the logout commands are not given until all other threaded commands have finished. NOTE: If disconnect is called and then later another connection is established the ThreadPool will not work! The function: 'setActiveThreads' will have to be called again in order for Threading to work. The var '_MAX_CHANNELS' must be passed to 'setActiveThreads' as the Parm 'maxThreads'. - :param wait: (int) default 90 - How long the method is will too wait until all login commands are finished. - :return: \"\"\" log . info ( ' === Disconnecting the SSH connection' ) current_time = time () def _parseWait ( w ): w = w - ( time () - current_time ) if w < 10 : w = 10 return w try : if not self . tPool : super ( sshThreader , self ) . disconnectEnvironments () else : with self . tPool : self . tPool . wait_completion ( timeout = wait ) for env in [ envs for envs in self . EnvironmentList if not envs . isMain ]: self . tPool . submit ( env . disconnectEnvironment ) self . tPool . join ( _parseWait ( wait )) super ( sshThreader , self ) . disconnect ( self . mainEnvironment ) except Exception as e : log . error ( f \"Error in threadedDisconnect: { e } \" ) log . debug ( f \"[DEBUG] for threadedDisconnect: { traceback . format_exc () } \" ) finally : if self . checkConnection (): super ( sshThreader , self ) . disconnect () def _exeThread ( self , CC : CommandContainer , ** kwargs ) -> CommandContainer : \"\"\" The method that is passed to the Pool via the 'submit' method. This method is the connection between the CommandContainer (which holds the command and manages the output) and the Environment that will be used to execute the command. This is ran on the Pool in a thread. It will also respond with the CC it was given. - :param CC: (CommandContainer) - :param kwargs: (Passed into the 'getEnvironment' method) - :return: (CommandContainer) The same as the 'CC' parameter \"\"\" log . info ( f 'running _exeThread for: { CC . command } ' ) if not self . checkConnection (): log . debug ( \"The SSH Connection is closed!\" ) raise SSHExceptionChannel ( \"While running a thread it was found that the SSH Channel is closed!\" ) def setupParams ( otherObject : CommandContainer ) -> tuple : if otherObject is None : return None , None , None return otherObject . kwargs . pop ( 'label' , None ), \\ otherObject . kwargs . get ( 'EnvironmentID' , None ), otherObject . timeout log . debug ( \"About to with CC\" ) with CC : log . debug ( \"Successful with of CC\" ) if CC . children : log . debug ( \"I have children... \" ) return CC . executor () log . debug ( \"About too get environment and with it\" ) with self . getEnvironment ( True , * setupParams ( CC ), ** kwargs ) as EnvObj : log . debug ( \"Got environment and executing with environment\" ) return CC . executor ( EnvironmentObject = EnvObj ) Variables log Classes sshThreader class sshThreader ( arguments , ** kwargs ) Ancestors (in MRO) sshConnector.sshEnvironmentManager.sshEnvironmentManager sshConnector.sshEnvironmentControl.sshEnvironmentControl sshConnector.sshBufferControl.sshBufferControl sshConnector.sshConnect.sshConnect Class variables arguments endSubRe escapeChars matchRe promptTextTuple ssh startSubRe tPool threadDict tki Static methods processRootLogin def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -' Instance variables EnvironmentCount EnvironmentList mainEnvironment Methods addEnvironment def addEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , ** kwargs ) -> bool Adds a provided channel to the channel manager. :param channel: (Channel) default None. :param kwargs: passed into a new _ChannelObject if one is created. :return: (bool) View Source def addEnvironment ( self , channel : EnvironmentControls , ** kwargs ) -> bool : \"\"\" Adds a provided channel to the channel manager. - :param channel: (Channel) default None. - :param kwargs: passed into a new _ChannelObject if one is created. - :return: (bool) \"\"\" try : if not self . _checkMaxSessions ( ** kwargs ) : log . debug ( \"A new channel cannot be added as there already are too many channels\" ) return False self . EnvironmentList . append ( channel ) return True except Exception as e : log . error ( f \"ERROR: There was a failure in addEnvironment: {e}\" ) log . debug ( f \"[DEBUG] for addEnvironment: {traceback.format_exc()}\" ) return False becomeRoot def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment = None , ** kwargs ) -> bool Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. :param kwargs: passed on to the escalate command. :return: (bool) View Source def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False becomeUser def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This manages the current user and will either escalate or de-escalate to the requested user. :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. :param userName: (str) - This is appended with a space after the 'loginCmd' param. :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. :return: Either 'sshEnvironment' (success) or False (Failure) View Source def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : # log . debug ( \"The connection is closed!\" ) return False # Checks to see if you are attempting to become a user you already are . if userName is environment . whoami : # log . debug ( \"You are attempting to escalate to the user currently logged in as. Skipping\" ) return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too . We will only deescalate if the 'userEscalation' flag is False which is default . If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user . if userName in environment . userList : # log . debug ( \"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\" ) if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache . This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts . loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user . We 'may' attempt to retry using a # different login command . This retry depends on the \"verifyUser\" variable . try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: {e}\" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. \" f \"Trying command: {newLoginCmd}\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: {e}\" ) log . debug ( f \"[DEBUG]: {traceback.format_exc()}\" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ) : if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment . getPrompt ( reCapturePrompt = reCapturePrompt ) return channel or environment checkConnection def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed checkWhoAmI def checkWhoAmI ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. :param environment: (sshEnvironment) default None - :return: (str) View Source def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ). strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: {e}' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: {traceback.format_exc()}' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' )) consoleEscalation def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = '' , escalationInput : Optional [ str ] = None , escalationType : str = 'console' , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. Parameters: Name Type Description Default escalationCmd None (str) - The command such as sqlpluss or zsh None escalationArgs None (str) default \"\" - Additional args such as '-h localhost'. None escalationInput None (str) default None - This is used if the command will require input such as a password. None escalationType None (str) default \"console\" - This is used to record the escalation type in sshEnvironment. None escalationHook None (Callable) default None - a method to call instead of the default escalation method. None name None (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. None environment None sshEnvironment object None Returns: Type Description None Either 'sshEnvironment' (success) or False (Failure) View Source def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \" console \" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment createConn def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh createEnvironment def createEnvironment ( self , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Used to create a new channel. :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. :param kwargs: :return: View Source def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Used to create a new channel. - :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. - :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel - :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. - :param kwargs: - :return: \"\"\" if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be made as there already are too many channels\" ) return False autoAdd = kwargs . pop ( 'autoAdd' , True ) EnvObj = self . _openChannel ( self . mainEnvironment . get_transport ()) EnvObj . label = kwargs . get ( 'label' , '' ) EnvObj . push ( \"su -\" , name = self . arguments . username , additionalInput = self . arguments . password ) if self . arguments . root : EnvObj . becomeRoot () else : EnvObj . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) if autoAdd : self . addEnvironment ( EnvObj ) return EnvObj disconnect def disconnect ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. :param environment: (sshEnvironment) default None - :return: None View Source def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ) : self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ). disconnect () disconnectEnvironments def disconnectEnvironments ( self ) -> None Disconnects all Environments. Used as a single thread alternative to 'threadedDisconnect' from 'sshThreader' :return: View Source def disconnectEnvironments ( self ) -> None : \"\"\" Disconnects all Environments. Used as a single thread alternative to ' threadedDisconnect ' from ' sshThreader ' - :return: \"\"\" with self . _ENVIRONMENT_LIST_LOCK : for environment in [ env for env in self . EnvironmentList if not env . isMain ] : environment . disconnectEnvironment () self . mainEnvironment . disconnectEnvironment () environmentChange def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. :param: args - Passed to 'consoleEscalation' :param: kwargs - Passed to 'consoleEscalation' :return: Either 'sshEnvironment' (success) or False (Failure) View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs ) escalate def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. :param args: (tuple) - passed on :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. :param kwargs: (dict) - passed on :return: Either 'sshEnvironment' (success) or False (Failure) View Source def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( ' environment ' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False executeOnEnvironment def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output executeOnThread def executeOnThread ( self , cmd : Union [ LinuxModules . CommandContainers . CommandContainer , Any ], EnvObj : Optional [ sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] = None , ** kwargs ) -> LinuxModules . CommandContainers . CommandContainer Submits a new command to be executed via the 'submit' method in Pool. All commands ran should be within a CommandContainer. So the method first checks to see if the command is already a Container or not. :param CC: [Either a CommandContainer or Any other datatype] :param EnvObj: (EnvironmentControls) default None. This specifies a Channel to run the command on. This bypasses using a Thread and instead expects that the channelObject is already 'active' or 'taken' by the thread currently calling this method. :param kwargs: used to create a new CommandContainer is 'cmd' is not a CommandContainer :return: CommandContainer (The same container that either was submitted as the cmd or the one created) View Source def executeOnThread ( self , cmd : Union [ CommandContainer, Any ] , EnvObj : Optional [ EnvironmentControls ] = None , ** kwargs ) -> CommandContainer : \"\"\" Submits a new command to be executed via the 'submit' method in Pool. All commands ran should be within a CommandContainer. So the method first checks to see if the command is already a Container or not. - :param CC: [Either a CommandContainer or Any other datatype] - :param EnvObj: (EnvironmentControls) default None. This specifies a Channel to run the command on. This bypasses using a Thread and instead expects that the channelObject is already 'active' or 'taken' by the thread currently calling this method. - :param kwargs: used to create a new CommandContainer is 'cmd' is not a CommandContainer - :return: CommandContainer (The same container that either was submitted as the cmd or the one created) \"\"\" def _preparserCmd ( commands , ** kwargs ) : if isinstance ( commands , CommandContainer ) : return commands if 'commandKey' not in kwargs : kwargs [ 'commandKey' ] = None if 'tki' not in kwargs and self . tki is not None : kwargs [ 'tki' ] = self . tki return CommandContainer ( commands , ** kwargs ) CC = _preparserCmd ( cmd , ** kwargs ) if EnvObj is None : self . tPool . submit ( fn = self . _exeThread , CC = CC , submit_task_priority = CC . __PRIORITY__ ) return CC else : if not EnvObj . active : log . warning ( \"This channel is not active and it has been manually requested for use by the executor!\" ) with CC : return CC . executor ( EnvironmentObject = EnvObj ) getEnvironment def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] This grabs the next available EnvironmentControls object or creates one. :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False :param wait: (int) default 60. Tells how long to wait for a channel to become available. :param delay: (float) default 0.1. Tells how long to pause between waiting. :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: View Source def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) \\ -> Union [ bool, EnvironmentControls ] : \"\"\" This grabs the next available EnvironmentControls object or creates one. - :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. - :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. - :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False - :param wait: (int) default 60. Tells how long to wait for a channel to become available. - :param delay: (float) default 0.1. Tells how long to pause between waiting. - :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: \"\"\" try : start_time = time . time () while time . time () < start_time + wait : channelObj = self . _checkEnvironments ( autoCreate , label , EnvironmentID ) if channelObj is True : channelObj = self . createEnvironment ( label = label , ** kwargs ) if channelObj is False : time . sleep ( delay ) continue if channelObj is not None : channelObj . active = True return channelObj return False except Exception as e : log . error ( f \"ERROR in getEnvironment: There was a failure getting Channel: {e}\" ) log . debug ( f \"[DEBUG] for getEnvironment: {traceback.format_exc()}\" ) getMaxSessionsValue def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. :param maxChannels: :return: View Source def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int : \"\"\" This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. - :param maxChannels: - :return: \"\"\" try : if type ( maxChannels ) is int and ( 10 >= maxChannels > 0 ) : return maxChannels output = self . executeOnEnvironment ( self . mainEnvironment , self . _MaxSessionsString % ( self . _DEFAULT_MAX_SESSIONS , self . _DEFAULT_MAX_SESSIONS ), self . mainEnvironment . prompt , runTimeout = 15 ) if not output : return self . _DEFAULT_MAX_SESSIONS return int ( output . strip (). splitlines () [ -1 ] . strip ()) - 1 except Exception as e : log . error ( f \"error in getMaxSessionsValue: {e}\" ) log . debug ( f \"[DEBUG] for getMaxSessionsValue: {traceback.format_exc()}\" ) return self . _DEFAULT_MAX_SESSIONS getPrompt def getPrompt ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] This captures the current prompt which is used to improve the performance of the buffer. :param environment: sshEnvironment object :return: str or None View Source def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log . debug ( f \"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\" ) if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt isIdle def isIdle ( self ) -> bool This checks the 'ThreadPool' class's 'isIdle()' function and returns the results. :return: bool View Source def isIdle ( self ) -> bool : \"\"\" This checks the ' ThreadPool ' class' s 'isIdle()' function and returns the results . - : return : bool \"\"\" return self.tPool.is_idle logoutConsole def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> bool This reverses through past environment changes until it undoes the previous console escalation. Parameters: Name Type Description Default logoutCmd None (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. None environment None (sshEnvironment/Paramiko Channel) None Returns: Type Description None View Source def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection () logoutCurrentEscalation def logoutCurrentEscalation ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] View Source def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment, bool ] : environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ) : log . info ( f \"Connection still valid on: {environment._id} - Num Escalations: {environment.numEscalations}\" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: {environment._id}\" ) return environment logoutCurrentUser def logoutCurrentUser ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. :param environment: (sshEnvironment) default None - :param junkOut: (StringIO) default None - :param reCapturePrompt: (bool) default True - :return: Either 'sshEnvironment' (success) or False (Failure) View Source def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ -2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser () : break return environment removeEnvironment def removeEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ) -> Optional [ bool ] Removed the provided object. :param channel: (_ChannelObject) :return: View Source def removeEnvironment ( self , channel : EnvironmentControls ) -> Optional [ bool ] : \"\"\" Removed the provided object. - :param channel: (_ChannelObject) - :return: \"\"\" try : if channel in self . _EnvironmentList : self . _EnvironmentList . remove ( channel ) return True else : log . debug ( \"Channel %s appears to have already been removed!\" % channel . EnvironmentID ) return None except Exception as e : log . error ( \"ERROR: There was a failure in removeEnvironment: %s\" % e ) log . error ( \"The failure is associated with channel: %s\" % channel . EnvironmentID ) return False resetEnvironment def resetEnvironment ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None As noted by the name this resets the values for the sshEnvironment class. BE CAREFUL this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. Parameters: Name Type Description Default environment None (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. None Returns: Type Description None None View Source def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )() threadedDisconnect def threadedDisconnect ( self , wait : int = 90 ) -> None This does what it says. It disconnects the SSH connection to a server using a thread for each Environment. This is not necessary faster. In fact it is often slower. This is designed if there are many connections open that have many user and environment escalations. In that situation this becomes faster then 'disconnectEnvironments'. However, this is necessary to ensure that the logout commands are not given until all other threaded commands have finished. NOTE : If disconnect is called and then later another connection is established the ThreadPool will not work ! The function : 'setActiveThreads' will have to be called again in order for Threading to work . The var '_MAX_CHANNELS' must be passed to 'setActiveThreads' as the Parm 'maxThreads' . :param wait: (int) default 90 - How long the method is will too wait until all login commands are finished. :return: View Source def threadedDisconnect ( self , wait : int = 90 ) -> None : \"\"\" This does what it says. It disconnects the SSH connection to a server using a thread for each Environment. This is not necessary faster. In fact it is often slower. This is designed if there are many connections open that have many user and environment escalations. In that situation this becomes faster then 'disconnectEnvironments'. However, this is necessary to ensure that the logout commands are not given until all other threaded commands have finished. NOTE: If disconnect is called and then later another connection is established the ThreadPool will not work! The function: 'setActiveThreads' will have to be called again in order for Threading to work. The var '_MAX_CHANNELS' must be passed to 'setActiveThreads' as the Parm 'maxThreads'. - :param wait: (int) default 90 - How long the method is will too wait until all login commands are finished. - :return: \"\"\" log . info ( ' === Disconnecting the SSH connection' ) current_time = time () def _parseWait ( w ) : w = w - ( time () - current_time ) if w < 10 : w = 10 return w try : if not self . tPool : super ( sshThreader , self ). disconnectEnvironments () else : with self . tPool : self . tPool . wait_completion ( timeout = wait ) for env in [ envs for envs in self.EnvironmentList if not envs.isMain ] : self . tPool . submit ( env . disconnectEnvironment ) self . tPool . join ( _parseWait ( wait )) super ( sshThreader , self ). disconnect ( self . mainEnvironment ) except Exception as e : log . error ( f \"Error in threadedDisconnect: {e}\" ) log . debug ( f \"[DEBUG] for threadedDisconnect: {traceback.format_exc()}\" ) finally : if self . checkConnection () : super ( sshThreader , self ). disconnect () waitForIdle def waitForIdle ( self , ** kwargs ) -> bool This is a wrapper for the 'waitCompletion' method in ThreadingPool. :param kwargs: Review the 'waitCompletion' method in ThreadingPool for all the arguments. :return: (bool) View Source def waitForIdle(self, **kwargs) -> bool: \"\"\" This is a wrapper for the 'waitCompletion' method in ThreadingPool. - :param kwargs: Review the 'waitCompletion' method in ThreadingPool for all the arguments. - :return: (bool) \"\"\" return self.tPool.wait_completion(**kwargs) whoami def whoami ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. :param environment: (sshEnvironment) default None - :return (str) View Source def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' )","title":"Sshthreader"},{"location":"reference/sshThreader/#module-sshthreader","text":"View Source 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 #!/usr/bin/env python # -*- coding=utf-8 -*- # # Author: Timothy Nodine, Ryan Henrichson # Version: 0.5.0 # Date: 02/19/15 # Description: This is the 6th class in the sshConnect chain. Technically the last in this change. The next class to # inherent this class should be CommandRunner which no longer focuses on anything regarding SSH. This file has two # classes. The public class 'sshThreader' and a private class '_createThread'. The sshThreader should be the only # class called. # A requirement for portray # import sys # sys.path.append('/home/rye/PycharmProjects/PyCustomCollections') # sys.path.append('/home/rye/PycharmProjects/PyCustomParsers') # sys.path.append('/home/rye/PycharmProjects/PyMultiTasking') import logging import traceback from PyLinuxDiagnosticToolKit.libs.LDTKExceptions import SSHExceptionChannel # A requirement for portray try : from LinuxModules.CommandContainers import CommandContainer except : from ldtk import CommandContainer from sshConnector.sshEnvironmentManager import sshEnvironmentManager from sshConnector.sshLibs.sshChannelEnvironment import EnvironmentControls from PyMultiTasking.ThreadingUtils import ThreadPool as Pool from typing import Optional , Union , Any from time import time # logging.basicConfig(format='%(asctime)s %(levelname)s %(name)s %(funcName)s %(lineno)s %(message)s', # level=logging.INFO) log = logging . getLogger ( 'SSHThreader' ) class sshThreader ( sshEnvironmentManager ): threadDict = {} tPool = None tki = None def __init__ ( self , arguments , ** kwargs ): \"\"\" This class is designed to managed another private class that inherits from Thread. The __init__ only job is to build and pass info along to the rest of the chain while overriding the root flag in args to avoid unnecessary work. - :param arguments: Passed along super to sshEnvironmentManager's construct. - :param kwargs: A placeholder for inheritance. \"\"\" super ( sshThreader , self ) . __init__ ( arguments = arguments , ** kwargs ) self . tki = kwargs . pop ( 'tki' , None ) self . tPool = Pool ( maxWorkers = self . _MAX_SESSIONS * 2 , workerAutoKill = False ) def isIdle ( self ) -> bool : \"\"\" This checks the 'ThreadPool' class's 'isIdle()' function and returns the results. - :return: bool \"\"\" return self . tPool . is_idle def waitForIdle ( self , ** kwargs ) -> bool : \"\"\" This is a wrapper for the 'waitCompletion' method in ThreadingPool. - :param kwargs: Review the 'waitCompletion' method in ThreadingPool for all the arguments. - :return: (bool) \"\"\" return self . tPool . wait_completion ( ** kwargs ) def executeOnThread ( self , cmd : Union [ CommandContainer , Any ], EnvObj : Optional [ EnvironmentControls ] = None , ** kwargs ) -> CommandContainer : \"\"\" Submits a new command to be executed via the 'submit' method in Pool. All commands ran should be within a CommandContainer. So the method first checks to see if the command is already a Container or not. - :param CC: [Either a CommandContainer or Any other datatype] - :param EnvObj: (EnvironmentControls) default None. This specifies a Channel to run the command on. This bypasses using a Thread and instead expects that the channelObject is already 'active' or 'taken' by the thread currently calling this method. - :param kwargs: used to create a new CommandContainer is 'cmd' is not a CommandContainer - :return: CommandContainer (The same container that either was submitted as the cmd or the one created) \"\"\" def _preparserCmd ( commands , ** kwargs ): if isinstance ( commands , CommandContainer ): return commands if 'commandKey' not in kwargs : kwargs [ 'commandKey' ] = None if 'tki' not in kwargs and self . tki is not None : kwargs [ 'tki' ] = self . tki return CommandContainer ( commands , ** kwargs ) CC = _preparserCmd ( cmd , ** kwargs ) if EnvObj is None : self . tPool . submit ( fn = self . _exeThread , CC = CC , submit_task_priority = CC . __PRIORITY__ ) return CC else : if not EnvObj . active : log . warning ( \"This channel is not active and it has been manually requested for use by the executor!\" ) with CC : return CC . executor ( EnvironmentObject = EnvObj ) def threadedDisconnect ( self , wait : int = 90 ) -> None : \"\"\" This does what it says. It disconnects the SSH connection to a server using a thread for each Environment. This is not necessary faster. In fact it is often slower. This is designed if there are many connections open that have many user and environment escalations. In that situation this becomes faster then 'disconnectEnvironments'. However, this is necessary to ensure that the logout commands are not given until all other threaded commands have finished. NOTE: If disconnect is called and then later another connection is established the ThreadPool will not work! The function: 'setActiveThreads' will have to be called again in order for Threading to work. The var '_MAX_CHANNELS' must be passed to 'setActiveThreads' as the Parm 'maxThreads'. - :param wait: (int) default 90 - How long the method is will too wait until all login commands are finished. - :return: \"\"\" log . info ( ' === Disconnecting the SSH connection' ) current_time = time () def _parseWait ( w ): w = w - ( time () - current_time ) if w < 10 : w = 10 return w try : if not self . tPool : super ( sshThreader , self ) . disconnectEnvironments () else : with self . tPool : self . tPool . wait_completion ( timeout = wait ) for env in [ envs for envs in self . EnvironmentList if not envs . isMain ]: self . tPool . submit ( env . disconnectEnvironment ) self . tPool . join ( _parseWait ( wait )) super ( sshThreader , self ) . disconnect ( self . mainEnvironment ) except Exception as e : log . error ( f \"Error in threadedDisconnect: { e } \" ) log . debug ( f \"[DEBUG] for threadedDisconnect: { traceback . format_exc () } \" ) finally : if self . checkConnection (): super ( sshThreader , self ) . disconnect () def _exeThread ( self , CC : CommandContainer , ** kwargs ) -> CommandContainer : \"\"\" The method that is passed to the Pool via the 'submit' method. This method is the connection between the CommandContainer (which holds the command and manages the output) and the Environment that will be used to execute the command. This is ran on the Pool in a thread. It will also respond with the CC it was given. - :param CC: (CommandContainer) - :param kwargs: (Passed into the 'getEnvironment' method) - :return: (CommandContainer) The same as the 'CC' parameter \"\"\" log . info ( f 'running _exeThread for: { CC . command } ' ) if not self . checkConnection (): log . debug ( \"The SSH Connection is closed!\" ) raise SSHExceptionChannel ( \"While running a thread it was found that the SSH Channel is closed!\" ) def setupParams ( otherObject : CommandContainer ) -> tuple : if otherObject is None : return None , None , None return otherObject . kwargs . pop ( 'label' , None ), \\ otherObject . kwargs . get ( 'EnvironmentID' , None ), otherObject . timeout log . debug ( \"About to with CC\" ) with CC : log . debug ( \"Successful with of CC\" ) if CC . children : log . debug ( \"I have children... \" ) return CC . executor () log . debug ( \"About too get environment and with it\" ) with self . getEnvironment ( True , * setupParams ( CC ), ** kwargs ) as EnvObj : log . debug ( \"Got environment and executing with environment\" ) return CC . executor ( EnvironmentObject = EnvObj )","title":"Module sshThreader"},{"location":"reference/sshThreader/#variables","text":"log","title":"Variables"},{"location":"reference/sshThreader/#classes","text":"","title":"Classes"},{"location":"reference/sshThreader/#sshthreader","text":"class sshThreader ( arguments , ** kwargs )","title":"sshThreader"},{"location":"reference/sshThreader/#ancestors-in-mro","text":"sshConnector.sshEnvironmentManager.sshEnvironmentManager sshConnector.sshEnvironmentControl.sshEnvironmentControl sshConnector.sshBufferControl.sshBufferControl sshConnector.sshConnect.sshConnect","title":"Ancestors (in MRO)"},{"location":"reference/sshThreader/#class-variables","text":"arguments endSubRe escapeChars matchRe promptTextTuple ssh startSubRe tPool threadDict tki","title":"Class variables"},{"location":"reference/sshThreader/#static-methods","text":"","title":"Static methods"},{"location":"reference/sshThreader/#processrootlogin","text":"def processRootLogin ( loginMethod : str ) -> str View Source @staticmethod def processRootLogin ( loginMethod : str ) -> str : if 'sudo' in loginMethod : return '/usr/bin/sudo -k; /usr/bin/sudo su -' return 'su -'","title":"processRootLogin"},{"location":"reference/sshThreader/#instance-variables","text":"EnvironmentCount EnvironmentList mainEnvironment","title":"Instance variables"},{"location":"reference/sshThreader/#methods","text":"","title":"Methods"},{"location":"reference/sshThreader/#addenvironment","text":"def addEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , ** kwargs ) -> bool Adds a provided channel to the channel manager. :param channel: (Channel) default None. :param kwargs: passed into a new _ChannelObject if one is created. :return: (bool) View Source def addEnvironment ( self , channel : EnvironmentControls , ** kwargs ) -> bool : \"\"\" Adds a provided channel to the channel manager. - :param channel: (Channel) default None. - :param kwargs: passed into a new _ChannelObject if one is created. - :return: (bool) \"\"\" try : if not self . _checkMaxSessions ( ** kwargs ) : log . debug ( \"A new channel cannot be added as there already are too many channels\" ) return False self . EnvironmentList . append ( channel ) return True except Exception as e : log . error ( f \"ERROR: There was a failure in addEnvironment: {e}\" ) log . debug ( f \"[DEBUG] for addEnvironment: {traceback.format_exc()}\" ) return False","title":"addEnvironment"},{"location":"reference/sshThreader/#becomeroot","text":"def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment = None , ** kwargs ) -> bool Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. :param kwargs: passed on to the escalate command. :return: (bool) View Source def becomeRoot ( self , loginCmd : Optional [ str ] = None , password : Optional [ str ] = None , verifyUser : bool = True , environment : sshEnvironment = None , ** kwargs ) -> bool : \"\"\" Helpful tool for quickly escalating to the root user. This method can be called without any use of it's parameters as it can get these from 'self'. However, passing a specific environment is necessary to escalate to root on that environment. - :param loginCmd: (str) default None - This is usually 'su -' or 'sudo'. - :param password: (str) default None - This can be filled by 'self.rootpwd' which is itself is populated by the value of the argument '--rootpwd'. - :param verifyUser: (bool) default True - This will run a whoami check after escalation to make sure the environment has been escalated to root. It will return False if the user escalation too root failed. - :param environment: (sshEnvironment) default None - replaced with 'self.mainEnvironment' if left empty. - :param kwargs: passed on to the escalate command. - :return: (bool) \"\"\" environment = environment or self . mainEnvironment if loginCmd is None : loginCmd = self . rootLogin if password is None : password = self . rootpwd kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , True ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) self . becomeUser ( loginCmd , 'root' , loginPasswd = password , verifyUser = verifyUser , environment = environment , ** kwargs ) log . debug ( f \"Env ID: {environment._id} - Prompt: {environment.prompt} - Whoami: {environment.whoami}\" ) if verifyUser : return True if self . whoami ( environment = environment ) == 'root' : return True environment . getPrompt ( reCapturePrompt = True ) return False","title":"becomeRoot"},{"location":"reference/sshThreader/#becomeuser","text":"def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This manages the current user and will either escalate or de-escalate to the requested user. :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. :param userName: (str) - This is appended with a space after the 'loginCmd' param. :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. :return: Either 'sshEnvironment' (success) or False (Failure) View Source def becomeUser ( self , loginCmd : str , userName : str , loginPasswd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , userEscalation : bool = False , verifyUser : bool = True , reCapturePrompt : bool = True , unsafe : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" This manages the current user and will either escalate or de-escalate to the requested user. - :param loginCmd: (str) - This is typically 'su -' or 'sudo su -'. Do NOT add the username to this, since it will automatically be appended via the 'userName' parameter. - :param userName: (str) - This is appended with a space after the 'loginCmd' param. - :param loginPasswd: (str) default None - If not passed the login password will attempt to be populated using existing authentication information. - :param environment: (sshEnvironment) default None - The sshEnvironment that this method will act on. - :param userEscalation: This is a boolean that will change the behavior of becomeUser. If you want to be a user that you already are, the default behavior is to de-escalate to that user. This states that no de-escalation will occur if you want to become a user, rather it will attempt to escalate again. IE: login as default user ie: 'server', then escalate to root, then become 'server' again by logging out as root. However, if userEscalation is True it would look like server -> root -> server. - :param verifyUser: (bool) default True - Effects the behavior of becomeUser by deciding whether or not to check and see if the loginCmd was or was not successful when becoming the user in question. It does this by running the 'whoami' command and comparing the output to the 'userName' variable. - :param reCapturePrompt: (bool) default True - This will re-populate the 'prompt' variable in the sshEnvironment class with the new prompt after the escalation is complete. - :param unsafe: (bool) default False - This tells the sshBufferControl to run in 'unsafe' mode. This changes how to tell when to stop reading the buffer. It is necessary for most user escalation methods. - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : # log . debug ( \"The connection is closed!\" ) return False # Checks to see if you are attempting to become a user you already are . if userName is environment . whoami : # log . debug ( \"You are attempting to escalate to the user currently logged in as. Skipping\" ) return False # Checks to see if you are attempting to become a user that you have already been and could simple deescalate # too . We will only deescalate if the 'userEscalation' flag is False which is default . If true this logic will # not run and the function will simply proceed as normal and attempt to login as the new user . if userName in environment . userList : # log . debug ( \"You are attempting to escalate to a user you already have logged in as in the past. \" # \"This is just a warning\" ) if not userEscalation : return self . _becomePreviousUser ( userName , strBuffer , environment ) # We need to us the '-k' flag in order to clear previous uses of sudo from the cache . This fixes issues with # capturing password prompts as it makes sudo ignore previous successful attempts . loginCmd = self . processRootLogin ( loginCmd ) while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) channel = False # We handle logging into root differently then logging in as any other user . We 'may' attempt to retry using a # different login command . This retry depends on the \"verifyUser\" variable . try : if not environment . prompt : environment . getPrompt ( reCapturePrompt = True ) channel = self . _escalateUser ( loginCmd = loginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe ) except BecomeUserException as e : if self . arguments . rootLoginExplicit : raise e log . warning ( f \"Unable to become user will try again: {e}\" ) if 'sudo' in loginCmd : log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. Trying command: 'su -'\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = 'su -' , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) elif 'su -' in loginCmd : newLoginCmd = '/usr/bin/sudo -k; /usr/bin/sudo su -' log . info ( f \"Failed to escalate to user: {userName} with command: {loginCmd}. \" f \"Trying command: {newLoginCmd}\" ) self . _clearLoginAttempt ( environment ) channel = self . _escalateUser ( loginCmd = newLoginCmd , loginPasswd = loginPasswd , userName = userName , environment = environment , verifyUser = verifyUser , buffer = strBuffer , unsafe = unsafe , prompt = environment . prompt ) except Exception as e : log . error ( f \"Unknown ERROR while user escalation: {e}\" ) log . debug ( f \"[DEBUG]: {traceback.format_exc()}\" ) finally : if not environment . isPromptDefault ( reCapturePrompt = reCapturePrompt ) : if reCapturePrompt and self . arguments . useBashnorc : self . escalate ( environment = environment , escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) # environment . getPrompt ( reCapturePrompt = reCapturePrompt ) return channel or environment","title":"becomeUser"},{"location":"reference/sshThreader/#checkconnection","text":"def checkConnection ( self , sshChannel : Optional [ paramiko . channel . Channel ] = None ) -> bool Creates ssh key object or returns None. :param: (Channel): None or Paramiko channel :return: (bool) View Source def checkConnection ( self , sshChannel : Optional [ Channel ] = None ) -> bool : \"\"\" Creates ssh key object or returns None. - :param: (Channel): None or Paramiko channel - :return: (bool) \"\"\" if sshChannel is None : sshChannel = self . mainEnvironment if self . ssh is None : return False if not sshChannel : return False return sshChannel . get_transport (). is_active () and not sshChannel . closed","title":"checkConnection"},{"location":"reference/sshThreader/#checkwhoami","text":"def checkWhoAmI ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. :param environment: (sshEnvironment) default None - :return: (str) View Source def checkWhoAmI ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This is the slow but sure fire way to find out what the current user is. This function can be called with a custom channel to determine the user of that channel. If calling from a thread it is required that you pass the channel or else you will get the whoami information for the master channel. Note: When called from a thread this function runs the command directly on the sshCommand buffer. This means that the calling thread has to wait until this is complete. Keep that in mind when using this function. - :param environment: (sshEnvironment) default None - - :return: (str) \"\"\" def _checkWhoAmIHelper ( cmdResults ) -> str : try : cmdOutputRe = sshEnvironmentControl . matchRe . search ( sshEnvironmentControl . startSubRe . sub ( '' , cmdResults , count = 1 )) if cmdOutputRe : return sshEnvironmentControl . endSubRe . sub ( '' , cmdOutputRe . group (), count = 1 ). strip () or '' return '' except Exception as e : log . error ( f 'error in _checkWhoAmIHelper: {e}' ) log . debug ( f '[DEBUG] for _checkWhoAmIHelper: {traceback.format_exc()}' ) return '' return _checkWhoAmIHelper ( self . executeOnEnvironment ( environment = environment or self . mainEnvironment , cmd = 'echo CMDSTART; whoami; echo CMDEND' , prompt = '' ))","title":"checkWhoAmI"},{"location":"reference/sshThreader/#consoleescalation","text":"def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = '' , escalationInput : Optional [ str ] = None , escalationType : str = 'console' , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. Parameters: Name Type Description Default escalationCmd None (str) - The command such as sqlpluss or zsh None escalationArgs None (str) default \"\" - Additional args such as '-h localhost'. None escalationInput None (str) default None - This is used if the command will require input such as a password. None escalationType None (str) default \"console\" - This is used to record the escalation type in sshEnvironment. None escalationHook None (Callable) default None - a method to call instead of the default escalation method. None name None (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. None environment None sshEnvironment object None Returns: Type Description None Either 'sshEnvironment' (success) or False (Failure) View Source def consoleEscalation ( self , escalationCmd : str , escalationArgs : str = \"\" , escalationInput : Optional [ str ] = None , escalationType : str = \"console\" , escalationHook : Optional [ Callable ] = None , name : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None , ** kwargs ) -> Union [ sshEnvironment, bool ] : \"\"\" This function differs from 'becomeUser' as it designed to change the environment from BASH to for example mysql shell or a sqlpluss shell. :param escalationCmd: (str) - The command such as sqlpluss or zsh :param escalationArgs: (str) default \"\" - Additional args such as '-h localhost'. :param escalationInput: (str) default None - This is used if the command will require input such as a password. :param escalationType: (str) default \" console \" - This is used to record the escalation type in sshEnvironment. :param escalationHook: (Callable) default None - a method to call instead of the default escalation method. :param name: (str) defualt None - What to call this console change. This can be useful when searching if a sshEnvironment has already escalated to a specific environment. :param environment: sshEnvironment object :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" reCapturePrompt = kwargs . get ( 'reCapturePrompt' , True ) strBuffer : StringIO = StringIO () environment = environment or self . mainEnvironment while environment . recv_ready () is not True and environment . send_ready () is not True : if environment . closed : environment . get_transport (). close () raise SSHExceptionChannel ( 'Unable to create SSH channel...' ) sleep ( .5 ) if name is None : name = escalationCmd environment = self . _performEscalation ( environment , loginCmd = escalationCmd , loginPasswd = escalationInput , userName = escalationArgs , buffer = strBuffer , console = True , escalationHook = escalationHook , ** kwargs ) environment . getPrompt ( reCapturePrompt = reCapturePrompt ) environment . push ( escalationCmd + escalationArgs , name = name , additionalInput = escalationInput , escalationType = escalationType ) return environment","title":"consoleEscalation"},{"location":"reference/sshThreader/#createconn","text":"def createConn ( self , host : Optional [ ~ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ ~ AnyStr ] = None , password : Optional [ ~ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> paramiko . client . SSHClient Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. :param host: (str) - Optional hostname/ip address of the box. :param port: (int) - Optional port to attempt to make the tcp connection. :param username: (str) - Optional and will use the class stored variable if not passed. :param password: (str) - Optional and will use the class stored variable if not passed. :param connTimeout: (float) - Optional and will use the class stored variable if not passed. :return: Paramiko SSHClient object. Otherwise known as SSH Connection. View Source def createConn ( self , host : Optional [ AnyStr ] = None , port : Optional [ int ] = None , username : Optional [ AnyStr ] = None , password : Optional [ AnyStr ] = None , connTimeout : Optional [ float ] = None ) -> SSHClient : \"\"\" Creates SSH Object and Opens Connection To Server All the parameters are optional. If a parameter isn't passed it will pull from the Class variable of the same name. If the parameter is passed it will override the class variable before connecting. - :param host: (str) - Optional hostname/ip address of the box. - :param port: (int) - Optional port to attempt to make the tcp connection. - :param username: (str) - Optional and will use the class stored variable if not passed. - :param password: (str) - Optional and will use the class stored variable if not passed. - :param connTimeout: (float) - Optional and will use the class stored variable if not passed. - :return: Paramiko SSHClient object. Otherwise known as SSH Connection. \"\"\" ssh = None try : ssh = paramiko . SSHClient () ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ()) if host : self . host = host if port : self . port = port if username : self . username = username if password : self . password = password if connTimeout : self . connTimeout = connTimeout ssh . connect ( self . host , port = int ( self . port ), pkey = self . _handleSSHKey ( self . key , self . passphrase ), username = self . username , password = self . password , timeout = float ( self . connTimeout ), look_for_keys = False , allow_agent = False , banner_timeout = 60.0 , sock = self . _makeSockProxy ()) except socket . error as e : if ssh : ssh . close () raise LDTKSSHException ( 'Connection Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . AuthenticationException , paramiko . BadAuthenticationType , paramiko . BadHostKeyException , paramiko . PasswordRequiredException , paramiko . ssh_exception . PartialAuthentication ) as e : if ssh : ssh . close () raise SSHExceptionAuth ( 'Authentication Error for User %s: %s' % ( self . username , e )) from e except ( paramiko . ssh_exception . ConfigParseError , paramiko . ProxyCommandFailure , paramiko . ssh_exception . CouldNotCanonicalize , paramiko . ssh_exception . NoValidConnectionsError ) as e : raise SSHExceptionConn ( 'Could not connect to remove machine for User %s: %s' % ( self . username , e )) from e except paramiko . SSHException as e : if ssh : ssh . close () raise SSHExceptionUnknown ( 'Generic Paramiko Exception for User %s: %s' % ( self . username , e )) from e except Exception as e : if ssh : ssh . close () raise LDTKSSHException ( 'Unknown Error for User %s: %s' % ( self . username , e )) from e else : self . ssh = ssh return self . ssh","title":"createConn"},{"location":"reference/sshThreader/#createenvironment","text":"def createEnvironment ( self , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] Used to create a new channel. :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. :param kwargs: :return: View Source def createEnvironment ( self , ** kwargs ) -> Union [ bool , EnvironmentControls ]: \"\"\" Used to create a new channel. - :param maxChannels: (int) default (whatever the _MAX_CHANNEL class variable is set to). This is passed directly to '_checkMaxChannels'. This can temporarily override the _MAX_CHANNEL setting. - :param autoAdd: (bool) default True: determines if the 'addChannel' method will be called to add the new channel - :param toBeUsed: (bool) default True: This is actually a _ChannelContainer object param but it is important here as it can be sued to control weather or not the new object will be available for use by the calling thread or can immediately be available for other threads to use. - :param kwargs: - :return: \"\"\" if not self . _checkMaxSessions ( ** kwargs ): log . debug ( \"A new channel cannot be made as there already are too many channels\" ) return False autoAdd = kwargs . pop ( 'autoAdd' , True ) EnvObj = self . _openChannel ( self . mainEnvironment . get_transport ()) EnvObj . label = kwargs . get ( 'label' , '' ) EnvObj . push ( \"su -\" , name = self . arguments . username , additionalInput = self . arguments . password ) if self . arguments . root : EnvObj . becomeRoot () else : EnvObj . escalate ( escalationCmd = 'bash' , escalationArgs = '-norc' , name = 'BASH' , console = True , unsafe = True , reCapturePrompt = True ) if autoAdd : self . addEnvironment ( EnvObj ) return EnvObj","title":"createEnvironment"},{"location":"reference/sshThreader/#disconnect","text":"def disconnect ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. :param environment: (sshEnvironment) default None - :return: None View Source def disconnect ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" This attempts to graceful log out by exiting/de-escalating through all previous console escalations on a given sshEnvironment. - :param environment: (sshEnvironment) default None - - :return: None \"\"\" environment = environment or self . mainEnvironment for x in range ( environment . numUsers ) : self . logoutCurrentUser ( environment , reCapturePrompt = False ) if environment . isMain : super ( sshEnvironmentControl , self ). disconnect ()","title":"disconnect"},{"location":"reference/sshThreader/#disconnectenvironments","text":"def disconnectEnvironments ( self ) -> None Disconnects all Environments. Used as a single thread alternative to 'threadedDisconnect' from 'sshThreader' :return: View Source def disconnectEnvironments ( self ) -> None : \"\"\" Disconnects all Environments. Used as a single thread alternative to ' threadedDisconnect ' from ' sshThreader ' - :return: \"\"\" with self . _ENVIRONMENT_LIST_LOCK : for environment in [ env for env in self . EnvironmentList if not env . isMain ] : environment . disconnectEnvironment () self . mainEnvironment . disconnectEnvironment ()","title":"disconnectEnvironments"},{"location":"reference/sshThreader/#environmentchange","text":"def environmentChange ( self , * args , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. :param: args - Passed to 'consoleEscalation' :param: kwargs - Passed to 'consoleEscalation' :return: Either 'sshEnvironment' (success) or False (Failure) View Source def environmentChange ( self , * args , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" Changes the state of the environment in some way other then user or console escalation. This method depends on 'consoleEscalation'. It simply adjusted the 'escalationType' and 'reCapturePrompt' parameters to work for changing the environment. This method is helpful if you want to record the fact that this sshEnvironment has special variables/settings set. Such as editing its PATH or the use of export. That way it is easy to run future commands on that particular environment. - :param: args - Passed to 'consoleEscalation' - :param: kwargs - Passed to 'consoleEscalation' - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" kwargs [ 'escalationType' ] = 'env' kwargs [ 'reCapturePrompt' ] = kwargs . get ( 'reCapturePrompt' , False ) return self . consoleEscalation ( * args , ** kwargs )","title":"environmentChange"},{"location":"reference/sshThreader/#escalate","text":"def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. :param args: (tuple) - passed on :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. :param kwargs: (dict) - passed on :return: Either 'sshEnvironment' (success) or False (Failure) View Source def escalate ( self , * args , env : bool = False , console : bool = False , ** kwargs ) -> Union [ sshEnvironment , bool ]: \"\"\" The default escalation method. This can handle console or environment changes. It uses the console and env bool parameters to control what type of console change will happen. If both are false the method will call the 'becomeUser' method. - :param args: (tuple) - passed on - :param env: (bool) default False - This will be checked first and will call 'environmentChange' method. - :param console: (bool) default False - This will be checked second and will call 'consoleEscalation' method. - :param kwargs: (dict) - passed on - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" if kwargs . get ( ' environment ' , self . mainEnvironment ): if env : return self . environmentChange ( * args , ** kwargs ) elif console : return self . consoleEscalation ( * args , ** kwargs ) else : return self . becomeUser ( * args , ** kwargs ) return False","title":"escalate"},{"location":"reference/sshThreader/#executeonenvironment","text":"def executeOnEnvironment ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls , cmd : ~ AnyStr , prompt : Union [ ~ AnyStr , Tuple , NoneType ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> ~ AnyStr This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. :param channel: (Paramiko Channel/sshEnvironment) - :param cmd: (str) - :param prompt: (tuple or str) - :param unsafe: (bool) default False - :param kwargs: :return: (str) View Source def executeOnEnvironment ( self , environment : EnvironmentControls , cmd : AnyStr , prompt : Optional [ Union[AnyStr, Tuple ] ] = None , unsafe : bool = False , reCapturePrompt : bool = False , ** kwargs ) -> AnyStr : \"\"\" This injects the string into the buffer while trying to ensure there is a prompt. As the prompt is used to quickly determine the end of the buffer. The prompt can be a string or it can be a tuple of strings that attempt to match the end of the line. Unsafe ignores the prompt and simply executes the command and only waits a short time before leaving not caring if it got output of the command. This is unsafe as it can leave a buffer open ready to dump more output. This method also takes the output from the command and attempts to decode it to utf-8 while removing all null and escape characters. - :param channel: (Paramiko Channel/sshEnvironment) - - :param cmd: (str) - - :param prompt: (tuple or str) - - :param unsafe: (bool) default False - - :param kwargs: - :return: (str) \"\"\" def _parseOutput ( tmpOut , tmpPrompt ) : try : # print ( f '=== parseOutput in executeOnEnvironment\\n{tmpOut}\\n' ) tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : log . error ( f 'ERROR: for method _parseOutput: {e}' ) log . debug ( f \"[DEBUG] for _parseOutput: {traceback.format_exc()}\" ) try : tmpOut = sshBufferControl . _decodeStringEscape ( tmpOut , encoding = 'latin1' ) except ( UnicodeDecodeError , UnicodeEncodeError ) as e : if 'CMDSTART' in tmpOut and 'CMDEND' in tmpOut : log . debug ( 'Another parse failure within _parseOutput method. However, ignoring sense string' 'contains CMDSTART and CMDEND this may be parsed successfully by CC' ) else : raise e tmpOut = sshBufferControl . escapeChars . sub ( '' , tmpOut ). strip () return tmpOut . replace ( tmpPrompt , '' ). replace ( cmd , '' ). strip () if not super ( sshBufferControl , self ). checkConnection ( sshChannel = environment ) : log . error ( \"There is not a valid connection.\" ) return '' log . debug ( f \"Attempting to exec command[s]: {cmd}\" ) out = StringIO () output = \"\" if isinstance ( prompt , str ) : prompt = sshBufferControl . _decodeStringEscape ( prompt ) if prompt is None and unsafe is False : prompt = environment . getPrompt ( reCapturePrompt = reCapturePrompt ) try : self . _bufferControl ( environment , cmd , out , prompt = prompt , unsafe = unsafe , ** kwargs ) output = _parseOutput ( out . getvalue (), prompt ) except RecvReady : log . error ( f \"The timeout of {self.runTimeout} was reached while waiting for prompt on buffer.\" ) log . debug ( f \"[DEBUG] for executeOnEnvironment: {traceback.format_exc()}\" ) output = _parseOutput ( out . getvalue (), prompt ) environment . close () except socket . timeout : log . error ( \"Timeout exception found.\" ) output = '[COMMAND_IO_LIMIT_TIMED_OUT]' environment . close () except Exception as e : log . error ( f 'ERROR: generic Exception for method executeOnEnvironment: {e}' ) log . info ( 'This error will be passed onto the Command Container' ) log . debug ( f 'This error occurred while executing: {cmd} on: {environment}' ) log . debug ( f '[DEBUG] for method executeOnEnvironment: {traceback.format_exc()}' ) raise e finally : out . truncate ( 0 ) del out # log . debug ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) # print ( f \"The output of the cmd: {cmd} is: \\n===\\n{output}\\n===\" ) return output","title":"executeOnEnvironment"},{"location":"reference/sshThreader/#executeonthread","text":"def executeOnThread ( self , cmd : Union [ LinuxModules . CommandContainers . CommandContainer , Any ], EnvObj : Optional [ sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] = None , ** kwargs ) -> LinuxModules . CommandContainers . CommandContainer Submits a new command to be executed via the 'submit' method in Pool. All commands ran should be within a CommandContainer. So the method first checks to see if the command is already a Container or not. :param CC: [Either a CommandContainer or Any other datatype] :param EnvObj: (EnvironmentControls) default None. This specifies a Channel to run the command on. This bypasses using a Thread and instead expects that the channelObject is already 'active' or 'taken' by the thread currently calling this method. :param kwargs: used to create a new CommandContainer is 'cmd' is not a CommandContainer :return: CommandContainer (The same container that either was submitted as the cmd or the one created) View Source def executeOnThread ( self , cmd : Union [ CommandContainer, Any ] , EnvObj : Optional [ EnvironmentControls ] = None , ** kwargs ) -> CommandContainer : \"\"\" Submits a new command to be executed via the 'submit' method in Pool. All commands ran should be within a CommandContainer. So the method first checks to see if the command is already a Container or not. - :param CC: [Either a CommandContainer or Any other datatype] - :param EnvObj: (EnvironmentControls) default None. This specifies a Channel to run the command on. This bypasses using a Thread and instead expects that the channelObject is already 'active' or 'taken' by the thread currently calling this method. - :param kwargs: used to create a new CommandContainer is 'cmd' is not a CommandContainer - :return: CommandContainer (The same container that either was submitted as the cmd or the one created) \"\"\" def _preparserCmd ( commands , ** kwargs ) : if isinstance ( commands , CommandContainer ) : return commands if 'commandKey' not in kwargs : kwargs [ 'commandKey' ] = None if 'tki' not in kwargs and self . tki is not None : kwargs [ 'tki' ] = self . tki return CommandContainer ( commands , ** kwargs ) CC = _preparserCmd ( cmd , ** kwargs ) if EnvObj is None : self . tPool . submit ( fn = self . _exeThread , CC = CC , submit_task_priority = CC . __PRIORITY__ ) return CC else : if not EnvObj . active : log . warning ( \"This channel is not active and it has been manually requested for use by the executor!\" ) with CC : return CC . executor ( EnvironmentObject = EnvObj )","title":"executeOnThread"},{"location":"reference/sshThreader/#getenvironment","text":"def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) -> Union [ bool , sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ] This grabs the next available EnvironmentControls object or creates one. :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False :param wait: (int) default 60. Tells how long to wait for a channel to become available. :param delay: (float) default 0.1. Tells how long to pause between waiting. :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: View Source def getEnvironment ( self , autoCreate = True , label = None , EnvironmentID = None , wait = 60 , delay = 1 , ** kwargs ) \\ -> Union [ bool, EnvironmentControls ] : \"\"\" This grabs the next available EnvironmentControls object or creates one. - :param autoCreate: (bool) default True, If no label or channelID is provided then this will make the method return a new _channelContainer if none available are found. - :param label: (str) default None. Looks for a particular label. Waits if it finds one but it is being used. Returns False is none are found. - :param channelID: (str) default None. Looks for a particular channelID. Waits if it finds it but finds it being used. Returns False - :param wait: (int) default 60. Tells how long to wait for a channel to become available. - :param delay: (float) default 0.1. Tells how long to pause between waiting. - :param kwargs: passed into a new _channelObject if this method tries to make a new channel. -:return: \"\"\" try : start_time = time . time () while time . time () < start_time + wait : channelObj = self . _checkEnvironments ( autoCreate , label , EnvironmentID ) if channelObj is True : channelObj = self . createEnvironment ( label = label , ** kwargs ) if channelObj is False : time . sleep ( delay ) continue if channelObj is not None : channelObj . active = True return channelObj return False except Exception as e : log . error ( f \"ERROR in getEnvironment: There was a failure getting Channel: {e}\" ) log . debug ( f \"[DEBUG] for getEnvironment: {traceback.format_exc()}\" )","title":"getEnvironment"},{"location":"reference/sshThreader/#getmaxsessionsvalue","text":"def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. :param maxChannels: :return: View Source def getMaxSessionsValue ( self , maxChannels : Optional [ int ] = None ) -> int : \"\"\" This attempts to change the max amount of channels this tool can use based on the target server's MaxSessions variable in sshd_config file. If the machine received the argument maxChannels it will attempt to use that as long as it isn't above 10. The default value is 8. - :param maxChannels: - :return: \"\"\" try : if type ( maxChannels ) is int and ( 10 >= maxChannels > 0 ) : return maxChannels output = self . executeOnEnvironment ( self . mainEnvironment , self . _MaxSessionsString % ( self . _DEFAULT_MAX_SESSIONS , self . _DEFAULT_MAX_SESSIONS ), self . mainEnvironment . prompt , runTimeout = 15 ) if not output : return self . _DEFAULT_MAX_SESSIONS return int ( output . strip (). splitlines () [ -1 ] . strip ()) - 1 except Exception as e : log . error ( f \"error in getMaxSessionsValue: {e}\" ) log . debug ( f \"[DEBUG] for getMaxSessionsValue: {traceback.format_exc()}\" ) return self . _DEFAULT_MAX_SESSIONS","title":"getMaxSessionsValue"},{"location":"reference/sshThreader/#getprompt","text":"def getPrompt ( self , environment : sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] This captures the current prompt which is used to improve the performance of the buffer. :param environment: sshEnvironment object :return: str or None View Source def getPrompt ( self , environment : sshEnvironment , reCapturePrompt : bool = False ) -> Optional [ str ] : \"\"\" This captures the current prompt which is used to improve the performance of the buffer. - :param environment: sshEnvironment object - :return: str or None \"\"\" # log . debug ( f \"ID: {environment._id} - Cached Prompt: {environment.prompt} - reCapturePrompt: {reCapturePrompt}\" ) if environment . prompt is not None and reCapturePrompt is False : return environment . prompt environment . prompt = self . _capturePrompt ( environment , StringIO ()) or None return environment . prompt","title":"getPrompt"},{"location":"reference/sshThreader/#isidle","text":"def isIdle ( self ) -> bool This checks the 'ThreadPool' class's 'isIdle()' function and returns the results. :return: bool View Source def isIdle ( self ) -> bool : \"\"\" This checks the ' ThreadPool ' class' s 'isIdle()' function and returns the results . - : return : bool \"\"\" return self.tPool.is_idle","title":"isIdle"},{"location":"reference/sshThreader/#logoutconsole","text":"def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> bool This reverses through past environment changes until it undoes the previous console escalation. Parameters: Name Type Description Default logoutCmd None (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. None environment None (sshEnvironment/Paramiko Channel) None Returns: Type Description None View Source def logoutConsole ( self , logoutCmd : Optional [ str ] = None , environment : Optional [ sshEnvironment ] = None ) -> bool : \"\"\" This reverses through past environment changes until it undoes the previous console escalation. :param logoutCmd: (str) (default None) This is a custom command to leave the console. For example 'exit' or 'quit'. :param environment: (sshEnvironment/Paramiko Channel) :return: \"\"\" environment = self . logoutCurrentEscalation ( environment = environment , logoutCmd = logoutCmd ) return environment . checkConnection ()","title":"logoutConsole"},{"location":"reference/sshThreader/#logoutcurrentescalation","text":"def logoutCurrentEscalation ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] View Source def logoutCurrentEscalation ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True , logoutCmd : Optional [ str ] = None ) -> Union [ sshEnvironment, bool ] : environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if not junkOut : junkOut : StringIO = StringIO () if not logoutCmd : logoutCmd = \"exit\" while environment . getPreviousEscalationType () == environment . __ENVIRONMENT_CHANGE__ : environment . pull () self . _bufferControl ( environment , logoutCmd , junkOut , unsafe = True ) environment . pull () if self . checkConnection ( environment ) : log . info ( f \"Connection still valid on: {environment._id} - Num Escalations: {environment.numEscalations}\" ) self . getPrompt ( environment = environment , reCapturePrompt = reCapturePrompt ) else : log . info ( f \"Connection closed on: {environment._id}\" ) return environment","title":"logoutCurrentEscalation"},{"location":"reference/sshThreader/#logoutcurrentuser","text":"def logoutCurrentUser ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None , junkOut : Optional [ _io . StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment , bool ] Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. :param environment: (sshEnvironment) default None - :param junkOut: (StringIO) default None - :param reCapturePrompt: (bool) default True - :return: Either 'sshEnvironment' (success) or False (Failure) View Source def logoutCurrentUser ( self , environment : Optional [ sshEnvironment ] = None , junkOut : Optional [ StringIO ] = None , reCapturePrompt : bool = True ) -> Union [ sshEnvironment, bool ] : \"\"\" Runs the command 'exit' once on a specified environment. Effectively logging out of a user or other escalation. - :param environment: (sshEnvironment) default None - - :param junkOut: (StringIO) default None - - :param reCapturePrompt: (bool) default True - - :return: Either 'sshEnvironment' (success) or False (Failure) \"\"\" environment = environment or self . mainEnvironment if not self . checkConnection ( environment ) : return environment if environment . consoleStack is None or len ( environment . consoleStack ) == 0 : return environment userList = environment . getUserList () userListLength = len ( userList ) expectedUser = userList [ -2 ] if userListLength > 1 else '' while environment . consoleStack : self . logoutCurrentEscalation ( environment = environment , junkOut = junkOut , reCapturePrompt = reCapturePrompt ) if userListLength > len ( environment . getUserList ()) and expectedUser == environment . getCurrentUser () : break return environment","title":"logoutCurrentUser"},{"location":"reference/sshThreader/#removeenvironment","text":"def removeEnvironment ( self , channel : sshConnector . sshLibs . sshChannelEnvironment . EnvironmentControls ) -> Optional [ bool ] Removed the provided object. :param channel: (_ChannelObject) :return: View Source def removeEnvironment ( self , channel : EnvironmentControls ) -> Optional [ bool ] : \"\"\" Removed the provided object. - :param channel: (_ChannelObject) - :return: \"\"\" try : if channel in self . _EnvironmentList : self . _EnvironmentList . remove ( channel ) return True else : log . debug ( \"Channel %s appears to have already been removed!\" % channel . EnvironmentID ) return None except Exception as e : log . error ( \"ERROR: There was a failure in removeEnvironment: %s\" % e ) log . error ( \"The failure is associated with channel: %s\" % channel . EnvironmentID ) return False","title":"removeEnvironment"},{"location":"reference/sshThreader/#resetenvironment","text":"def resetEnvironment ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> None As noted by the name this resets the values for the sshEnvironment class. BE CAREFUL this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. Parameters: Name Type Description Default environment None (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. None Returns: Type Description None None View Source def resetEnvironment ( self , environment : Optional [ sshEnvironment ] = None ) -> None : \"\"\" As noted by the name this resets the values for the sshEnvironment class. *BE CAREFUL* this doesn't run commands on the ssh channel environment meaning the actual environment on the target machine hasn't changed. This only clears the values recorded on the sshEnvironment class. :param environment: (sshEnvironment) default None - the sshEnvironment to run 'resetEnvironment' against. :return: None \"\"\" getattr ( environment or self . mainEnvironment , 'resetEnvironment' , dummy_func )()","title":"resetEnvironment"},{"location":"reference/sshThreader/#threadeddisconnect","text":"def threadedDisconnect ( self , wait : int = 90 ) -> None This does what it says. It disconnects the SSH connection to a server using a thread for each Environment. This is not necessary faster. In fact it is often slower. This is designed if there are many connections open that have many user and environment escalations. In that situation this becomes faster then 'disconnectEnvironments'. However, this is necessary to ensure that the logout commands are not given until all other threaded commands have finished. NOTE : If disconnect is called and then later another connection is established the ThreadPool will not work ! The function : 'setActiveThreads' will have to be called again in order for Threading to work . The var '_MAX_CHANNELS' must be passed to 'setActiveThreads' as the Parm 'maxThreads' . :param wait: (int) default 90 - How long the method is will too wait until all login commands are finished. :return: View Source def threadedDisconnect ( self , wait : int = 90 ) -> None : \"\"\" This does what it says. It disconnects the SSH connection to a server using a thread for each Environment. This is not necessary faster. In fact it is often slower. This is designed if there are many connections open that have many user and environment escalations. In that situation this becomes faster then 'disconnectEnvironments'. However, this is necessary to ensure that the logout commands are not given until all other threaded commands have finished. NOTE: If disconnect is called and then later another connection is established the ThreadPool will not work! The function: 'setActiveThreads' will have to be called again in order for Threading to work. The var '_MAX_CHANNELS' must be passed to 'setActiveThreads' as the Parm 'maxThreads'. - :param wait: (int) default 90 - How long the method is will too wait until all login commands are finished. - :return: \"\"\" log . info ( ' === Disconnecting the SSH connection' ) current_time = time () def _parseWait ( w ) : w = w - ( time () - current_time ) if w < 10 : w = 10 return w try : if not self . tPool : super ( sshThreader , self ). disconnectEnvironments () else : with self . tPool : self . tPool . wait_completion ( timeout = wait ) for env in [ envs for envs in self.EnvironmentList if not envs.isMain ] : self . tPool . submit ( env . disconnectEnvironment ) self . tPool . join ( _parseWait ( wait )) super ( sshThreader , self ). disconnect ( self . mainEnvironment ) except Exception as e : log . error ( f \"Error in threadedDisconnect: {e}\" ) log . debug ( f \"[DEBUG] for threadedDisconnect: {traceback.format_exc()}\" ) finally : if self . checkConnection () : super ( sshThreader , self ). disconnect ()","title":"threadedDisconnect"},{"location":"reference/sshThreader/#waitforidle","text":"def waitForIdle ( self , ** kwargs ) -> bool This is a wrapper for the 'waitCompletion' method in ThreadingPool. :param kwargs: Review the 'waitCompletion' method in ThreadingPool for all the arguments. :return: (bool) View Source def waitForIdle(self, **kwargs) -> bool: \"\"\" This is a wrapper for the 'waitCompletion' method in ThreadingPool. - :param kwargs: Review the 'waitCompletion' method in ThreadingPool for all the arguments. - :return: (bool) \"\"\" return self.tPool.wait_completion(**kwargs)","title":"waitForIdle"},{"location":"reference/sshThreader/#whoami","text":"def whoami ( self , environment : Optional [ sshConnector . sshLibs . sshChannelEnvironment . sshEnvironment ] = None ) -> str This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. :param environment: (sshEnvironment) default None - :return (str) View Source def whoami ( self , environment : Optional [ sshEnvironment ] = None ) -> str : \"\"\" This returns the 'whoami' of the provided sshEnvironment. If an environment is not provided it pulls this from the main Environment. Sense this is looking at a variable this is not always reliable because the variable may become de-synced with its actual environment. Also calling this from a thread may also result in the wrong information if the environment is also being acted upon. For accurate information use the 'checkWhoAmI' method as this runs the 'whoami' command on sshEnvironment. - :param environment: (sshEnvironment) default None - - :return (str) \"\"\" return getattr ( environment or self . mainEnvironment , 'whoami' , '' )","title":"whoami"}]}